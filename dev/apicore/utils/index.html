<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utility Functions · ConleyDynamics.jl</title><meta name="title" content="Utility Functions · ConleyDynamics.jl"/><meta property="og:title" content="Utility Functions · ConleyDynamics.jl"/><meta property="twitter:title" content="Utility Functions · ConleyDynamics.jl"/><meta name="description" content="Documentation for ConleyDynamics.jl."/><meta property="og:description" content="Documentation for ConleyDynamics.jl."/><meta property="twitter:description" content="Documentation for ConleyDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ConleyDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ConleyDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../man/lefschetz/">Lefschetz Complexes</a></li><li><a class="tocitem" href="../../man/homology/">Homology</a></li><li><a class="tocitem" href="../../man/conley/">Conley Theory</a></li><li><a class="tocitem" href="../../man/sparse/">Sparse Matrices</a></li><li><a class="tocitem" href="../../man/examples/">Examples</a></li><li><a class="tocitem" href="../../man/references/">References</a></li></ul></li><li><span class="tocitem">Core API</span><ul><li><a class="tocitem" href="../datastruct/">Composite Data Structures</a></li><li class="is-active"><a class="tocitem" href>Utility Functions</a><ul class="internal"><li><a class="tocitem" href="#Simplicial-Complexes"><span>Simplicial Complexes</span></a></li><li><a class="tocitem" href="#Cubical-Complexes"><span>Cubical Complexes</span></a></li><li><a class="tocitem" href="#General-Lefschetz-complexes"><span>General Lefschetz complexes</span></a></li><li><a class="tocitem" href="#Multivector-Fields"><span>Multivector Fields</span></a></li><li><a class="tocitem" href="#General-Helper-Functions"><span>General Helper Functions</span></a></li></ul></li><li><a class="tocitem" href="../plots/">Plotting Functions</a></li><li><a class="tocitem" href="../cmcore/">Conley Theory Functions</a></li><li><a class="tocitem" href="../homology/">Homology Functions</a></li><li><a class="tocitem" href="../sparse/">Sparse Matrix Functions</a></li><li><a class="tocitem" href="../apiindex/">Complete API Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Core API</a></li><li class="is-active"><a href>Utility Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Utility Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/main/docs/src/apicore/utils.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h1><h2 id="Simplicial-Complexes"><a class="docs-heading-anchor" href="#Simplicial-Complexes">Simplicial Complexes</a><a id="Simplicial-Complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Simplicial-Complexes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_simplicial_complex" href="#ConleyDynamics.create_simplicial_complex"><code>ConleyDynamics.create_simplicial_complex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_simplicial_complex(labels::Vector{String},
                          simplices::Vector{Vector{Int}})</code></pre><p>Initialize a Lefschetz complex from a simplicial complex.</p><p>The vector <code>labels</code> contains a label for every vertex, while <code>simplices</code> contains all the highest-dimensional simplices necessary to define the simplicial complex. Every simplex is represented as a vector of <code>Int</code>, with entries corresponding to the vertex indices.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Note that the labels all have to have the same character length!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/create_simplicial_complex.jl#L3-L16">source</a></section><section><div><pre><code class="language-julia hljs">create_simplicial_complex(labels::Vector{String},
                          simplices::Vector{Vector{String}})</code></pre><p>Initialize a Lefschetz complex from a simplicial complex.</p><p>The vector <code>labels</code> contains a label for every vertex, while <code>simplices</code> contains all the highest-dimensional simplices necessary to define the simplicial complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/create_simplicial_complex.jl#L120-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_simplicial_rectangle" href="#ConleyDynamics.create_simplicial_rectangle"><code>ConleyDynamics.create_simplicial_rectangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_simplicial_rectangle(nx::Int, ny::Int)</code></pre><p>Create a simplicial complex covering a rectangle in the plane.</p><p>The rectangle is given by the subset <code>[0,nx] x [0,ny]</code> of the plane. Each unit square is represented by four triangles, which meet in the center point of the square. Labels have the following meaning:</p><ul><li>The label <code>XXXYYYb</code> corresponds to the point <code>(XXX, YYY)</code>.</li><li>The label <code>XXXYYYc</code> corresponds to <code>(XXX + 1/2, YYY + 1/2)</code>.</li></ul><p>The number of characters in <code>XXX</code> and <code>YYY</code> matches the number  of digits of the larger number of <code>nx</code> and <code>ny</code>. The function returns the following objects:</p><ul><li>A simplicial complex <code>sc::LefschetzComplex</code>.</li><li>A vector <code>coords::Vector{Vector{Float64}}</code> of vertex coordinates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/create_simplicial_rectangle.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_simplicial_delaunay" href="#ConleyDynamics.create_simplicial_delaunay"><code>ConleyDynamics.create_simplicial_delaunay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_simplicial_delaunay(boxw::Real, boxh::Real, pdist::Real, attmpt::Int)</code></pre><p>Create a planar Delaunay triangulation inside a box.</p><p>The function selects a random sample of points inside the rectangular box <code>[0,boxw] x [0,boxh]</code>, while trying to maintain a minimum distance  of <code>pdist</code> between the points. The argument <code>attmpt</code> specifies the number of attempts when trying to add points. A standard value is 20, and larger values tend to fill holes better, but at the expense of runtime. From the random sample, the function then creates a Delaunay triangulation, and returns the following objects:</p><ul><li>A simplicial complex <code>sc::LefschetzComplex</code>.</li><li>A vector <code>coords::Vector{Vector{Float64}}</code> of vertex coordinates.</li></ul><p>Note that the function does not provide a full triangulation of the given rectangle. Close to the boundary there will be gaps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/create_simplicial_delaunay.jl#L3-L21">source</a></section><section><div><pre><code class="language-julia hljs">create_simplicial_delaunay(boxw::Real, boxh::Real, npoints::Int)</code></pre><p>Create a planar Delaunay triangulation inside a box.</p><p>The function selects a random sample of <code>npoints</code> points inside the rectangular box <code>[0,boxw] x [0,boxh]</code>. From the random sample, the function then creates a Delaunay triangulation, and returns the following objects:</p><ul><li>A simplicial complex <code>sc::LefschetzComplex</code>.</li><li>A vector <code>coords::Vector{Vector{Float64}}</code> of vertex coordinates.</li></ul><p>Note that the function does not provide a full triangulation of the given rectangle. Close to the boundary there will be gaps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/create_simplicial_delaunay.jl#L75-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.convert_simplices" href="#ConleyDynamics.convert_simplices"><code>ConleyDynamics.convert_simplices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert_simplices(simplices::Vector{Vector{Int}},
                  labels::Vector{String})</code></pre><p>Convert list of simplices from index form to label form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/convert_simplices.jl#L3-L8">source</a></section><section><div><pre><code class="language-julia hljs">convert_simplices(simplices::Vector{Vector{String}},
                  labels::Vector{String})</code></pre><p>Convert list of simplices from label form to index form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/convert_simplices.jl#L27-L32">source</a></section></article><h2 id="Cubical-Complexes"><a class="docs-heading-anchor" href="#Cubical-Complexes">Cubical Complexes</a><a id="Cubical-Complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Cubical-Complexes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_cubical_complex" href="#ConleyDynamics.create_cubical_complex"><code>ConleyDynamics.create_cubical_complex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_cubical_complex(cubes::Vector{String})</code></pre><p>Initialize a Lefschetz complex from a cubical complex.</p><p>The vector <code>cubes</code> contains a list of all the highest-dimensional cubes necessary to define the cubical complex. Every cube is represented as a string as follows:</p><ul><li>d integers, which correspond to the coordinates of a point in d-dimensional Euclidean space</li><li>a point <code>.</code></li><li>d integers 0 or 1, which give the interval length in the respective dimension</li></ul><p>The first d integers all have to occupy the same number of characters. In addition, if the occupied space is L characters for each coordinate, the coordinates only can take values from 0 to 10^L - 2. This is due to the fact that the boundary operator will add one to certain coordinates, and they still need to be  representable withing the same L digits.</p><p>For example, the string <code>030600.101</code> corresponds to the point <code>(3,6,0)</code> in three dimensions. The dimensions are 1, 0, and 1, and therefore this string corresponds to the cube <code>[3,4] x [6] x [0,1]</code>. The same cube could have also been represented by <code>360.101</code> or by <code>003006000.101</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Note that the labels all have to have the same format!</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cubes = [&quot;00.11&quot;, &quot;01.01&quot;, &quot;02.10&quot;, &quot;11.10&quot;, &quot;11.01&quot;, &quot;22.00&quot;];

julia&gt; lc = create_cubical_complex(cubes);

julia&gt; lc.ncells
17

julia&gt; homology(lc, p=0)
3-element Vector{Int64}:
 2
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/create_cubical_complex.jl#L3-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_cubical_rectangle" href="#ConleyDynamics.create_cubical_rectangle"><code>ConleyDynamics.create_cubical_rectangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_cubical_rectangle(nx::Int, ny::Int)</code></pre><p>Create a cubical complex covering a rectangle in the plane.</p><p>The rectangle is given by the subset <code>[0,nx] x [0,ny]</code> of the plane, and each unit square gives a two-dimensional cube in the resulting cubical complex. The function returns the following objects:</p><ul><li>A cubical complex <code>cc::LefschetzComplex</code>.</li><li>A vector <code>coords::Vector{Vector{Float64}}</code> of vertex coordinates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/create_cubical_rectangle.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.cube_field_size" href="#ConleyDynamics.cube_field_size"><code>ConleyDynamics.cube_field_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cube_field_size(cube::String)</code></pre><p>Determine the field sizes of a given cube label.</p><p>The function returns the dimension of the ambient space in the first output parameter <code>pointdim</code>, and the length of the individual coordinate fields in the second return variable <code>pointlen</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cube_field_size(&quot;011654003020.0110&quot;)
(4, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/create_cubical_complex.jl#L189-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.cube_information" href="#ConleyDynamics.cube_information"><code>ConleyDynamics.cube_information</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cube_information(cube::String)</code></pre><p>Compute a cube&#39;s coordinate information.</p><p>The function returns an integer vector with the cubes coordinate information. The return vector <code>intinfo</code> contains in its components the following data:</p><ul><li><code>1:pointdim</code>: Coordinates of the anchor point</li><li><code>1+pointdim:2*pointdim</code>: Interval length in each dimension</li><li><code>1+2*pointdim</code>: Dimension of the cube</li></ul><p>Note that <code>pointdim</code> equals the dimension of the points specifying the cube.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cube_information(&quot;011654003.011&quot;)
7-element Vector{Int64}:
  11
 654
   3
   0
   1
   1
   2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/create_cubical_complex.jl#L215-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.cube_label" href="#ConleyDynamics.cube_label"><code>ConleyDynamics.cube_label</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cube_label(pointdim::Int, pointlen::Int, pointinfo::Vector{Int})</code></pre><p>Create a label from a cube&#39;s coordinate information.</p><p>The dimension of the ambient Eucliden space is <code>pointdim</code>, while the field length for each coordinate is <code>pointlen</code>. The vector <code>pointinfo</code> has to be of length at least two times <code>pointdim</code>. The first <code>pointdim</code> entries contain the coordinates of the anchor point, while the next <code>pointdim</code> entries are either 0 or 1 depending on the size of the interval. For example, if <code>poindim = 3</code> and <code>pointinfo = [1,2,3,1,0,1]</code>, then we represent the cube in three-dimensional space given by <code>[1,2] x [2] x [3 4]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cube_label(3,2,[10,23,5,1,1,0])
&quot;102305.110&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/create_cubical_complex.jl#L291-L309">source</a></section></article><h2 id="General-Lefschetz-complexes"><a class="docs-heading-anchor" href="#General-Lefschetz-complexes">General Lefschetz complexes</a><a id="General-Lefschetz-complexes-1"></a><a class="docs-heading-anchor-permalink" href="#General-Lefschetz-complexes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_boundary" href="#ConleyDynamics.lefschetz_boundary"><code>ConleyDynamics.lefschetz_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lefschetz_boundary(lc::LefschetzComplex, cellI::Int)</code></pre><p>Compute the support of the boundary of a Lefschetz complex cell.</p><p>This method returns the boundary support as a <code>Vector{Int}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_boundary.jl#L3-L9">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_boundary(lc::LefschetzComplex, cellS::String)</code></pre><p>Compute the support of the boundary of a Lefschetz complex cell.</p><p>This method returns the boundary support as a <code>Vector{String}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_boundary.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_coboundary" href="#ConleyDynamics.lefschetz_coboundary"><code>ConleyDynamics.lefschetz_coboundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lefschetz_coboundary(lc::LefschetzComplex, cellI::Int)</code></pre><p>Compute the support of the coboundary of a Lefschetz complex cell.</p><p>This method returns the boundary support as a <code>Vector{Int}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_boundary.jl#L59-L65">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_coboundary(lc::LefschetzComplex, cellS::String)</code></pre><p>Compute the support of the coboundary of a Lefschetz complex cell.</p><p>This method returns the boundary support as a <code>Vector{String}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_boundary.jl#L88-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_openhull" href="#ConleyDynamics.lefschetz_openhull"><code>ConleyDynamics.lefschetz_openhull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lefschetz_openhull(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Compute the open hull of a Lefschetz complex subset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_openhull.jl#L3-L7">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_openhull(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Compute the open hull of a Lefschetz complex subset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_openhull.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_closure" href="#ConleyDynamics.lefschetz_closure"><code>ConleyDynamics.lefschetz_closure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lefschetz_closure(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Compute the closure of a Lefschetz complex subset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_closure.jl#L3-L7">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_closure(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Compute the closure of a Lefschetz complex subset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_closure.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_lchull" href="#ConleyDynamics.lefschetz_lchull"><code>ConleyDynamics.lefschetz_lchull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lefschetz_lchull(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Compute the locally closed hull of a Lefschetz complex subset.</p><p>The locally closed hull is the smallest locally closed set which contains the given cells. It is the intersection of the closure and the open hull.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_lchull.jl#L3-L11">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_lchull(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Compute the locally closed hull of a Lefschetz complex subset.</p><p>The locally closed hull is the smallest locally closed set which contains the given cells. It is the intersection of the closure and the open hull.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_lchull.jl#L28-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_is_closed" href="#ConleyDynamics.lefschetz_is_closed"><code>ConleyDynamics.lefschetz_is_closed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lefschetz_is_closed(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Determine whether a Lefschetz complex subset is closed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_is_closed.jl#L3-L7">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_is_closed(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Determine whether a Lefschetz complex subset is closed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_is_closed.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_clomo_pair" href="#ConleyDynamics.lefschetz_clomo_pair"><code>ConleyDynamics.lefschetz_clomo_pair</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lefschetz_clomopair(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Determine the closure-mouth-pair associated with a Lefschetz complex subset.</p><p>The function returns the pair <code>(closure,mouth)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_clomo_pair.jl#L3-L9">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_clomopair(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Determine the closure-mouth-pair associated with a Lefschetz complex subset.</p><p>The function returns the pair <code>(closure,mouth)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_clomo_pair.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_skeleton" href="#ConleyDynamics.lefschetz_skeleton"><code>ConleyDynamics.lefschetz_skeleton</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lefschetz_skeleton(lc::LefschetzComplex, subcomp::Vector{Int}, skdim::Int)</code></pre><p>Compute the <code>skdim</code>-dimensional skeleton of a Lefschetz complex subset.</p><p>The computed skeleton is for the closure of the subcomplex given by <code>subcomp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_skeleton.jl#L3-L9">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_skeleton(lc::LefschetzComplex, subcomp::Vector{String}, skdim::Int)</code></pre><p>Compute the <code>skdim</code>-dimensional skeleton of a Lefschetz complex subset.</p><p>The computed skeleton is for the closure of the subcomplex given by <code>subcomp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_skeleton.jl#L34-L40">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_skeleton(lc::LefschetzComplex, skdim::Int)</code></pre><p>Compute the <code>skdim</code>-dimensional skeleton of a Lefschetz complex.</p><p>The computed skeleton is for the full Lefschetz complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_skeleton.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_subcomplex" href="#ConleyDynamics.lefschetz_subcomplex"><code>ConleyDynamics.lefschetz_subcomplex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lefschetz_subcomplex(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Extract a closed subcomplex from a Lefschetz complex. The subcomplex is the closure of the collection of cells given in <code>subcomp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_subcomplex.jl#L3-L8">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_subcomplex(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Extract a closed subcomplex from a Lefschetz complex. The subcomplex is the closure of the collection of cells given in <code>subcomp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_subcomplex.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_filtration" href="#ConleyDynamics.lefschetz_filtration"><code>ConleyDynamics.lefschetz_filtration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lefschetz_filtration(lc::LefschetzComplex, fvalues::Vector{Int})</code></pre><p>Compute a filtration on a Lefschetz subset.</p><p>The considered Lefschetz complex is given in <code>lc</code>. The vector <code>fvalues</code> assigns an integer between 0 and N to every cell in <code>lc</code>. For every k the complex <code>L_k</code> is given by the closure of all cells with values between 1 and k. The function returns the following variables:</p><ul><li><code>lcsub</code>: The subcomplex <code>L_N</code></li><li><code>fvalsub</code>: The filtration on the subcomplex with values 1,...,N</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; labels = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;];

julia&gt; simplices = [[&quot;A&quot;,&quot;B&quot;,&quot;D&quot;],[&quot;B&quot;,&quot;D&quot;,&quot;E&quot;],[&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;C&quot;,&quot;E&quot;,&quot;F&quot;],[&quot;F&quot;,&quot;G&quot;]];

julia&gt; sc = create_simplicial_complex(labels,simplices);

julia&gt; filtration = [0,0,0,0,0,0,0,1,1,0,1,2,0,4,2,4,0,5,3,7,6];

julia&gt; lcsub, fvalsub = lefschetz_filtration(sc,filtration);

julia&gt; phinf, phint = persistent_homology(lcsub, fvalsub, p=2);

julia&gt; phinf
3-element Vector{Vector{Int64}}:
 [1]
 []
 []

julia&gt; phint
3-element Vector{Vector{Tuple{Int64, Int64}}}:
 []
 [(1, 5), (2, 7), (4, 6)]
 []</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_filtration.jl#L3-L41">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_filtration(lc::LefschetzComplex, strfilt::Vector{Vector{String}})</code></pre><p>Compute a filtration on a Lefschetz subset.</p><p>The considered Lefschetz complex is given in <code>lc</code>. The vector of string vectors <code>strfilt</code> contains the necessary simplices to build the filtration. The list <code>strfilt[k]</code> contains the simplices that are added at the k-th step, together with their closures. Thus, for every k the complex <code>L_k</code> is given by the closure of all cells listed in <code>strfilt[i]</code> for <code>i</code> between 1 and k. The function returns the following variables:</p><ul><li><code>lcsub</code>: The subcomplex <code>L_N</code>, where <code>N = length(strfilt)</code></li><li><code>fvalsub</code>: The filtration on the subcomplex with values 1,...,N</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; labels = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;];

julia&gt; simplices = [[&quot;A&quot;,&quot;B&quot;,&quot;D&quot;],[&quot;B&quot;,&quot;D&quot;,&quot;E&quot;],[&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;C&quot;,&quot;E&quot;,&quot;F&quot;],[&quot;F&quot;,&quot;G&quot;]];

julia&gt; sc = create_simplicial_complex(labels,simplices);

julia&gt; strfiltration = [[&quot;AB&quot;,&quot;AD&quot;,&quot;BD&quot;],[&quot;BE&quot;,&quot;DE&quot;],[&quot;BCE&quot;],[&quot;CF&quot;,&quot;EF&quot;],[&quot;ABD&quot;],[&quot;CEF&quot;],[&quot;BDE&quot;]];

julia&gt; lcsub, fvalsub = lefschetz_filtration(sc, strfiltration);

julia&gt; phinf, phint = persistent_homology(lcsub, fvalsub, p=2);

julia&gt; phinf
3-element Vector{Vector{Int64}}:
 [1]
 []
 []

julia&gt; phint
3-element Vector{Vector{Tuple{Int64, Int64}}}:
 []
 [(1, 5), (2, 7), (4, 6)]
 []</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/lefschetz_filtration.jl#L85-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.permute_lefschetz_complex" href="#ConleyDynamics.permute_lefschetz_complex"><code>ConleyDynamics.permute_lefschetz_complex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permute_lefschetz_complex(lc::LefschetzComplex,
                          permutation::Vector{Int})</code></pre><p>Permute the indices of a Lefschetz complex.</p><p>The vector <code>permutation</code> contains a permutation of the indices for the given Lefschetz complex <code>lc</code>. If no permutation is specified, or if the length of the vector is not correct, then a randomly generated one will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/permute_lefschetz_complex.jl#L3-L13">source</a></section></article><h2 id="Multivector-Fields"><a class="docs-heading-anchor" href="#Multivector-Fields">Multivector Fields</a><a id="Multivector-Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Multivector-Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.convert_mvf" href="#ConleyDynamics.convert_mvf"><code>ConleyDynamics.convert_mvf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert_mvf(lc::LefschetzComplex, mvf::Vector{Vector{Int}})</code></pre><p>Convert multivector field <code>mvf</code> on the Lefschetz complex <code>lc</code> from  index form to label form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/convert_mvf.jl#L3-L8">source</a></section><section><div><pre><code class="language-julia hljs">convert_mvf(lc::LefschetzComplex, mvf::Vector{Vector{String}})</code></pre><p>Convert multivector field <code>mvf</code> on the Lefschetz complex <code>lc</code> from  label form to index form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/convert_mvf.jl#L26-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_mvf_hull" href="#ConleyDynamics.create_mvf_hull"><code>ConleyDynamics.create_mvf_hull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_mvf_hull(lc::LefschetzComplex, mvfbase::Vector{Vector{Int}})</code></pre><p>Create the smallest multivector field containing the given sets.</p><p>The resulting multivector field has the property that every set of the form <code>mvfbase[k]</code> is contained in a minimal multivector. Notice that these sets do not have to be disjoint, and that not even their locally closed hulls have to be disjoint. In the latter case, this leads to two such sets having to be contained in the same multivector. If the sets in <code>mvfbase</code> are poorly chosen, one might end up with extremely large multivectors due to the above potential merging of locally closed hulls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/create_mvf_hull.jl#L3-L16">source</a></section><section><div><pre><code class="language-julia hljs">create_mvf_hull(lc::LefschetzComplex, mvfbase::Vector{Vector{String}})</code></pre><p>Create the smallest multivector field containing the given sets.</p><p>The resulting multivector field has the property that every set of the form <code>mvfbase[k]</code> is contained in a minimal multivector. Notice that these sets do not have to be disjoint, and that not even their locally closed hulls have to be disjoint. In the latter case, this leads to two such sets having to be contained in the same multivector. If the sets in <code>mvfbase</code> are poorly chosen, one might end up with extremely large multivectors due to the above potential merging of locally closed hulls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/create_mvf_hull.jl#L79-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_planar_mvf" href="#ConleyDynamics.create_planar_mvf"><code>ConleyDynamics.create_planar_mvf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_planar_mvf(lc::LefschetzComplex, coords::Vector{Vector{Float64}}, vf)</code></pre><p>Create a planar multivector field from a regular vector field.</p><p>The function expects a planar Lefschetz complex <code>lc</code> and a coordinate vector <code>coords</code> of coordinates for all the 0-dimensional cells in the complex. Moreover, the underlying vector field is specified by the function <code>vf(z::Vector{Float64})::Vector{Float64}</code>, where both the input and output vectors have length two. The function <code>create_planar_mvf</code> returns a multivector field <code>mvf</code> on <code>lc</code>, which can then be further analyzed using for example the function <code>connection_matrix</code>.</p><p>The input data <code>lc</code> and <code>coords</code> can be generated using one of the following methods:</p><ul><li><code>create_cubical_rectangle</code></li><li><code>create_simplicial_rectangle</code></li><li><code>create_simplicial_delaunay</code></li></ul><p>In each case, the provided coordinate vector can be transformed to the correct bounding box using <code>convert_planar_coordinates</code>.</p><p><strong>Example 1</strong></p><p>Suppose we define a sample vector field using the commands</p><pre><code class="language-julia hljs">function samplevf(x::Vector{Float64})
    #
    # Sample vector field with nontrivial Morse decomposition
    #
    x1, x2 = x
    y1 = x1 * (1.0 - x1*x1 - 3.0*x2*x2)
    y2 = x2 * (1.0 - 3.0*x1*x1 - x2*x2)
    return [y1, y2]
end</code></pre><p>One first creates a triangulation of the enclosing box, which in this case is given by <code>[-2,2] x [-2,2]</code> using the commands</p><pre><code class="language-julia hljs">n = 21
lc, coords = create_simplicial_rectangle(n,n);
coordsN = convert_planar_coordinates(coords,[-2.0,-2.0],[2.0,2.0]);</code></pre><p>The multivector field is then generated using</p><pre><code class="language-julia hljs">mvf = create_planar_mvf(lc,coordsN,samplevf);</code></pre><p>and the commands</p><pre><code class="language-julia hljs">cm = connection_matrix(lc, mvf, p=2);
cm.poincare
full_from_sparse(cm.cm)</code></pre><p>finally show that this vector field gives rise to a Morse decomposition with nine Morse sets, and twelve connecting orbits. Using the commands</p><pre><code class="language-julia hljs">fname = &quot;morse_test.pdf&quot;
plot_planar_simplicial_morse(lc, coordsN, fname, cm.morsesets, pv=true)</code></pre><p>these Morse sets can be visualized. The image will be saved in <code>fname</code>.</p><p><strong>Example 2</strong></p><p>An example with periodic orbits can be generated using the vector field</p><pre><code class="language-julia hljs">function samplevf2(x::Vector{Float64})
    #
    # Sample vector field with nontrivial Morse decomposition
    #
    x1, x2 = x
    c0 = x1*x1 + x2*x2
    c1 = (c0 - 4.0) * (c0 - 1.0)
    y1 = -x2 + x1 * c1
    y2 =  x1 + x2 * c1
    return [-y1, -y2]
end</code></pre><p>The Morse decomposition can now be computed via</p><pre><code class="language-julia hljs">n2 = 51
lc2, coords2 = create_cubical_rectangle(n2,n2);
coords2N = convert_planar_coordinates(coords2,[-4.0,-4.0],[4.0,4.0]);
mvf2 = create_planar_mvf(lc2,coords2N,samplevf2);
cm2 = connection_matrix(lc2, mvf2, p=2);
cm2.poincare
cm2.poset
full_from_sparse(cm2.cm)

fname2 = &quot;morse_test2.pdf&quot;
plot_planar_cubical_morse(lc2, fname2, cm2.morsesets, pv=true)</code></pre><p>In this case, one obtains three Morse sets: One is a stable equilibrium, one is an unstable periodic orbit, and the last is a stable periodic orbit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/create_planar_mvf.jl#L3-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.extract_multivectors" href="#ConleyDynamics.extract_multivectors"><code>ConleyDynamics.extract_multivectors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_multivectors(lc::LefschetzComplex, mvf::Vector{Vector{Int}},
                     scells::Vector{Int})</code></pre><p>Extract all multivectors containing a provided selection of cells.</p><p>The function returns all multivectors which contain at least one of the cells in the input vector <code>scells</code>. The return argument has type <code>Vector{Vector{Int}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/extract_multivectors.jl#L3-L11">source</a></section><section><div><pre><code class="language-julia hljs">extract_multivectors(lc::LefschetzComplex, mvf::Vector{Vector{String}},
                     scells::Vector{String})</code></pre><p>Extract all multivectors containing a provided selection of cells.</p><p>The function returns all multivectors which contain at least one of the cells in the input vector <code>scells</code>. The return argument has type <code>Vector{Vector{String}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/extract_multivectors.jl#L44-L52">source</a></section></article><h2 id="General-Helper-Functions"><a class="docs-heading-anchor" href="#General-Helper-Functions">General Helper Functions</a><a id="General-Helper-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#General-Helper-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.convert_planar_coordinates" href="#ConleyDynamics.convert_planar_coordinates"><code>ConleyDynamics.convert_planar_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert_planar_coordinates(coords::Vector{Vector{Float64}},
                           p0::Vector{Float64},
                           p1::Vector{Float64})</code></pre><p>Convert a given collection of planar coordinates.</p><p>The vector <code>coords</code> contains pairs of coordinates, which are then transformed to fit into the box with vertices <code>p0 = (p0x,p0y)</code> and <code>p1 = (p1x,p1y)</code>. It is assumed that <code>p0</code> denotes the lower left box corner, while <code>p1</code> is the upper right corner. The function shifts and scales the coordinates in such a way that every side of the box contains at least one point. Upon completion, it returns a new coordinate vector <code>coordsNew</code>.</p><p>More precisely, if the x-coordinates are spanning the interval <code>[xmin,xmax]</code> and the y-coordinates span <code>[ymin,ymax]</code>, then the point <code>(x,y)</code> is transformed to <code>(xn,yn)</code> with:</p><ul><li><code>xn = p0x + (p1x-p0x) * (x-cxmin) / (cxmax-cxmin)</code></li><li><code>yn = p0y + (p1y-p0y) * (y-cymin) / (cymax-cymin)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/convert_coordinates.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.convert_matrix_gfp" href="#ConleyDynamics.convert_matrix_gfp"><code>ConleyDynamics.convert_matrix_gfp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert_matrix_gfp(matrix::SparseMatrix{Int}, p::Int)</code></pre><p>Convert a sparse integer matrix to a finite field sparse matrix over <code>GF(p)</code>. For the choice <code>p=0</code> the rationals are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/convert_matrix_gfp.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.planar_nontransverse_edges" href="#ConleyDynamics.planar_nontransverse_edges"><code>ConleyDynamics.planar_nontransverse_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">planar_nontransverse_edges(lc::LefschetzComplex, coords::Vector{Vector{Float64}}, vf;
                           npts::Int=100)</code></pre><p>Find all edges of a planar Lefschetz complex which are not flow transverse.</p><p>The Lefschetz complex is given in <code>lc</code>, the coordinates of all vertices of the complex in <code>coords</code>, and the vector field is specified in <code>vf</code>. The optional parameter <code>npts</code> determines how many points along an edge are evaluated for the transversality check. The function returns a list of nontransverse edges as <code>Vector{Int}</code>, which contains the edge indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/1113583f6a418827fd17b4476a618fb0e00a2e9b/src/utils/planar_nontransverse_edges.jl#L3-L14">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../datastruct/">« Composite Data Structures</a><a class="docs-footer-nextpage" href="../plots/">Plotting Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Tuesday 26 March 2024 20:15">Tuesday 26 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
