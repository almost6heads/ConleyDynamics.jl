<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conley Theory Functions · ConleyDynamics.jl</title><meta name="title" content="Conley Theory Functions · ConleyDynamics.jl"/><meta property="og:title" content="Conley Theory Functions · ConleyDynamics.jl"/><meta property="twitter:title" content="Conley Theory Functions · ConleyDynamics.jl"/><meta name="description" content="Documentation for ConleyDynamics.jl."/><meta property="og:description" content="Documentation for ConleyDynamics.jl."/><meta property="twitter:description" content="Documentation for ConleyDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ConleyDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ConleyDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../man/lefschetz/">Lefschetz Complexes</a></li><li><a class="tocitem" href="../../man/homology/">Homology</a></li><li><a class="tocitem" href="../../man/conley/">Conley Theory</a></li><li><a class="tocitem" href="../../man/examples/">Examples</a></li><li><a class="tocitem" href="../../man/sparse/">Sparse Matrices</a></li><li><a class="tocitem" href="../../man/references/">References</a></li></ul></li><li><span class="tocitem">Core API</span><ul><li><a class="tocitem" href="../datastruct/">Composite Data Structures</a></li><li><a class="tocitem" href="../lefschetz/">Lefschetz Complex Functions</a></li><li><a class="tocitem" href="../homology/">Homology Functions</a></li><li class="is-active"><a class="tocitem" href>Conley Theory Functions</a><ul class="internal"><li><a class="tocitem" href="#Multivector-Fields"><span>Multivector Fields</span></a></li><li><a class="tocitem" href="#Conley-Index-Computations"><span>Conley Index Computations</span></a></li><li><a class="tocitem" href="#Connection-Matrix-Computation"><span>Connection Matrix Computation</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Example Functions</a></li><li><a class="tocitem" href="../plots/">Plotting Functions</a></li><li><a class="tocitem" href="../sparse/">Sparse Matrix Functions</a></li><li><a class="tocitem" href="../apiindex/">Complete API Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Core API</a></li><li class="is-active"><a href>Conley Theory Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Conley Theory Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/main/docs/src/apicore/conley.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Conley-Theory-Functions"><a class="docs-heading-anchor" href="#Conley-Theory-Functions">Conley Theory Functions</a><a id="Conley-Theory-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Conley-Theory-Functions" title="Permalink"></a></h1><h2 id="Multivector-Fields"><a class="docs-heading-anchor" href="#Multivector-Fields">Multivector Fields</a><a id="Multivector-Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Multivector-Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_mvf_hull" href="#ConleyDynamics.create_mvf_hull"><code>ConleyDynamics.create_mvf_hull</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_mvf_hull(lc::LefschetzComplex, mvfbase::Vector{Vector{Int}})</code></pre><p>Create the smallest multivector field containing the given sets.</p><p>The resulting multivector field has the property that every set of the form <code>mvfbase[k]</code> is contained in a minimal multivector. Notice that these sets do not have to be disjoint, and that not even their locally closed hulls have to be disjoint. In the latter case, this leads to two such sets having to be contained in the same multivector. If the sets in <code>mvfbase</code> are poorly chosen, one might end up with extremely large multivectors due to the above potential merging of locally closed hulls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/mvf/create_mvf_hull.jl#L3-L16">source</a></section><section><div><pre><code class="language-julia hljs">create_mvf_hull(lc::LefschetzComplex, mvfbase::Vector{Vector{String}})</code></pre><p>Create the smallest multivector field containing the given sets.</p><p>The resulting multivector field has the property that every set of the form <code>mvfbase[k]</code> is contained in a minimal multivector. Notice that these sets do not have to be disjoint, and that not even their locally closed hulls have to be disjoint. In the latter case, this leads to two such sets having to be contained in the same multivector. If the sets in <code>mvfbase</code> are poorly chosen, one might end up with extremely large multivectors due to the above potential merging of locally closed hulls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/mvf/create_mvf_hull.jl#L79-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_planar_mvf" href="#ConleyDynamics.create_planar_mvf"><code>ConleyDynamics.create_planar_mvf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_planar_mvf(lc::LefschetzComplex, coords::Vector{Vector{Float64}}, vf)</code></pre><p>Create a planar multivector field from a regular vector field.</p><p>The function expects a planar Lefschetz complex <code>lc</code> and a coordinate vector <code>coords</code> of coordinates for all the 0-dimensional cells in the complex. Moreover, the underlying vector field is specified by the function <code>vf(z::Vector{Float64})::Vector{Float64}</code>, where both the input and output vectors have length two. The function <code>create_planar_mvf</code> returns a multivector field <code>mvf</code> on <code>lc</code>, which can then be further analyzed using for example the function <code>connection_matrix</code>.</p><p>The input data <code>lc</code> and <code>coords</code> can be generated using one of the following methods:</p><ul><li><code>create_cubical_rectangle</code></li><li><code>create_simplicial_rectangle</code></li><li><code>create_simplicial_delaunay</code></li></ul><p>In each case, the provided coordinate vector can be transformed to the correct bounding box using <code>convert_planar_coordinates</code>.</p><p><strong>Example 1</strong></p><p>Suppose we define a sample vector field using the commands</p><pre><code class="language-julia hljs">function samplevf(x::Vector{Float64})
    #
    # Sample vector field with nontrivial Morse decomposition
    #
    x1, x2 = x
    y1 = x1 * (1.0 - x1*x1 - 3.0*x2*x2)
    y2 = x2 * (1.0 - 3.0*x1*x1 - x2*x2)
    return [y1, y2]
end</code></pre><p>One first creates a triangulation of the enclosing box, which in this case is given by <code>[-2,2] x [-2,2]</code> using the commands</p><pre><code class="language-julia hljs">n = 21
lc, coords = create_simplicial_rectangle(n,n);
coordsN = convert_planar_coordinates(coords,[-2.0,-2.0],[2.0,2.0]);</code></pre><p>The multivector field is then generated using</p><pre><code class="language-julia hljs">mvf = create_planar_mvf(lc,coordsN,samplevf);</code></pre><p>and the commands</p><pre><code class="language-julia hljs">cm = connection_matrix(lc, mvf);
cm.conley
full_from_sparse(cm.matrix)</code></pre><p>finally show that this vector field gives rise to a Morse decomposition with nine Morse sets, and twelve connecting orbits. Using the commands</p><pre><code class="language-julia hljs">fname = &quot;morse_test.pdf&quot;
plot_planar_simplicial_morse(lc, coordsN, fname, cm.morse, pv=true)</code></pre><p>these Morse sets can be visualized. The image will be saved in <code>fname</code>.</p><p><strong>Example 2</strong></p><p>An example with periodic orbits can be generated using the vector field</p><pre><code class="language-julia hljs">function samplevf2(x::Vector{Float64})
    #
    # Sample vector field with nontrivial Morse decomposition
    #
    x1, x2 = x
    c0 = x1*x1 + x2*x2
    c1 = (c0 - 4.0) * (c0 - 1.0)
    y1 = -x2 + x1 * c1
    y2 =  x1 + x2 * c1
    return [-y1, -y2]
end</code></pre><p>The Morse decomposition can now be computed via</p><pre><code class="language-julia hljs">n2 = 51
lc2, coords2 = create_cubical_rectangle(n2,n2);
coords2N = convert_planar_coordinates(coords2,[-4.0,-4.0],[4.0,4.0]);
mvf2 = create_planar_mvf(lc2,coords2N,samplevf2);
cm2 = connection_matrix(lc2, mvf2);
cm2.conley
cm2.poset
full_from_sparse(cm2.matrix)

fname2 = &quot;morse_test2.pdf&quot;
plot_planar_cubical_morse(lc2, fname2, cm2.morse, pv=true)</code></pre><p>In this case, one obtains three Morse sets: One is a stable equilibrium, one is an unstable periodic orbit, and the last is a stable periodic orbit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/mvf/create_planar_mvf.jl#L3-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_spatial_mvf" href="#ConleyDynamics.create_spatial_mvf"><code>ConleyDynamics.create_spatial_mvf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_spatial_mvf(lc::LefschetzComplex, coords::Vector{Vector{Float64}}, vf)</code></pre><p>Create a spatial multivector field from a regular vector field.</p><p>The function expects a three-dimensional Lefschetz complex <code>lc</code> and a coordinate vector <code>coords</code> of coordinates for all the 0-dimensional cells in the complex. Moreover, the underlying vector field is specified by the function <code>vf(z::Vector{Float64})::Vector{Float64}</code>, where both the input and output vectors have length three. The function <code>create_spatial_mvf</code> returns a multivector field <code>mvf</code> on <code>lc</code>, which can then be further analyzed using for example the function <code>connection_matrix</code>.</p><p>The input data <code>lc</code> and <code>coords</code> has to be of one of the following two types:</p><ul><li><code>lc</code> is a tetrahedral mesh of a region in three dimensions. In other words, the underlying Lefschetz complex is in fact a simplicial  complex, and the vector <code>coords</code> contains the vertex coordinates.</li><li><code>lc</code> is a three-dimensional cubical complex, i.e., it is the closure of a collection of three-dimensional cubes in space. The vertex coordinates can be slight;y perturbed from the original position in the cubical lattice, as long as the overall structure  of the complex stays intact. In that case, the faces are interpreted as Bezier surfaces with straight edges.</li></ul><p><strong>Example 1</strong></p><p>Suppose we define a sample vector field using the commands</p><pre><code class="language-julia hljs">function samplevf(x::Vector{Float64})
    #
    # Sample vector field with nontrivial Morse decomposition
    #
    x1, x2, x3 = x
    y1 = x1 * (1.0 - x1*x1)
    y2 = -x2
    y3 = -x3
    return [y1, y2, y3]
end</code></pre><p>One first creates a cubical complex covering the interesting dynamics, say the trapping region <code>[-1.5,1.5] x [-1,1] x [-1,1]</code>, using the commands</p><pre><code class="language-julia hljs">lc, coords = create_cubical_box(3,3,3);
coordsN = convert_spatial_coordinates(coords,[-1.5,-1.0,-1.0],[1.5,1.0,1.0]);</code></pre><p>The multivector field is then generated using</p><pre><code class="language-julia hljs">mvf = create_spatial_mvf(lc,coordsN,samplevf);</code></pre><p>and the commands</p><pre><code class="language-julia hljs">cm = connection_matrix(lc, mvf);
cm.conley
full_from_sparse(cm.matrix)</code></pre><p>finally show that this vector field gives rise to a Morse decomposition with three Morse sets, and two connecting orbits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/mvf/create_spatial_mvf.jl#L3-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.extract_multivectors" href="#ConleyDynamics.extract_multivectors"><code>ConleyDynamics.extract_multivectors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_multivectors(lc::LefschetzComplex, mvf::Vector{Vector{Int}},
                     scells::Vector{Int})</code></pre><p>Extract all multivectors containing a provided selection of cells.</p><p>The function returns all multivectors which contain at least one of the cells in the input vector <code>scells</code>. The return argument has type <code>Vector{Vector{Int}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/mvf/extract_multivectors.jl#L3-L11">source</a></section><section><div><pre><code class="language-julia hljs">extract_multivectors(lc::LefschetzComplex, mvf::Vector{Vector{String}},
                     scells::Vector{String})</code></pre><p>Extract all multivectors containing a provided selection of cells.</p><p>The function returns all multivectors which contain at least one of the cells in the input vector <code>scells</code>. The return argument has type <code>Vector{Vector{String}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/mvf/extract_multivectors.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.planar_nontransverse_edges" href="#ConleyDynamics.planar_nontransverse_edges"><code>ConleyDynamics.planar_nontransverse_edges</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">planar_nontransverse_edges(lc::LefschetzComplex, coords::Vector{Vector{Float64}}, vf;
                           npts::Int=100)</code></pre><p>Find all edges of a planar Lefschetz complex which are not flow transverse.</p><p>The Lefschetz complex is given in <code>lc</code>, the coordinates of all vertices of the complex in <code>coords</code>, and the vector field is specified in <code>vf</code>. The optional parameter <code>npts</code> determines how many points along an edge are evaluated for the transversality check. The function returns a list of nontransverse edges as <code>Vector{Int}</code>, which contains the edge indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/mvf/planar_nontransverse_edges.jl#L3-L14">source</a></section></article><h2 id="Conley-Index-Computations"><a class="docs-heading-anchor" href="#Conley-Index-Computations">Conley Index Computations</a><a id="Conley-Index-Computations-1"></a><a class="docs-heading-anchor-permalink" href="#Conley-Index-Computations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.conley_index" href="#ConleyDynamics.conley_index"><code>ConleyDynamics.conley_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conley_index(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Determine the Conley index of a Lefschetz complex subset.</p><p>The function raises an error if the subset <code>subcomp</code> is not locally closed. The computations are performed over the field associated with the Lefschetz complex boundary matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/conley/conley_index.jl#L3-L11">source</a></section><section><div><pre><code class="language-julia hljs">conley_index(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Determine the Conley index of a Lefschetz complex subset.</p><p>The function raises an error if the subset <code>subcomp</code> is not locally closed. The computations are performed over the field associated with the Lefschetz complex boundary matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/conley/conley_index.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.morse_sets" href="#ConleyDynamics.morse_sets"><code>ConleyDynamics.morse_sets</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">morse_sets(lc::LefschetzComplex, mvf::CellSubsets; poset::Bool=false)</code></pre><p>Find the nontrivial Morse sets of a multivector field on a Lefschetz complex.</p><p>The input argument <code>lc</code> contains the Lefschetz complex, and <code>mvf</code> describes the multivector field. The function returns the nontrivial Morse sets as a <code>Vector{Vector{Int}}</code>. If the optional argument <code>poset=true</code> is added, then the function returns both the Morse sets and the adjacency matrix of the Hasse diagram of the underlying poset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/conley/morse_sets.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.morse_interval" href="#ConleyDynamics.morse_interval"><code>ConleyDynamics.morse_interval</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">morse_interval(lc::LefschetzComplex, mvf::CellSubsets,
               ms::CellSubsets)</code></pre><p>Find the isolated invariant set for a Morse set interval.</p><p>The input argument <code>lc</code> contains the Lefschetz complex, and <code>mvf</code> describes the multivector field. The collection of Morse sets are contained in<code>ms</code>. All of these sets should be Morse sets in the sense of being strongly connected components of the flow graph. (Nevertheless, this will be enforced in the function!) In other words, the sets in <code>ms</code> should be determined using the function <code>morse_sets</code>!</p><p>The function returns the smallest isolated invariant set which contains the Morse sets and their connections as a <code>Vector{Int}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/conley/morse_interval.jl#L3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.restrict_dynamics" href="#ConleyDynamics.restrict_dynamics"><code>ConleyDynamics.restrict_dynamics</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">restrict_dynamics(lc::LefschetzComplex, mvf::CellSubsets, lcsub::Cells)</code></pre><p>Restrict a multivector field to a Lefschetz subcomplex.</p><p>For a given multivector field <code>mvf</code> on a Lefschetz complex <code>lc</code>, and a subcomplex which is given by the locally closed set represented by <code>lcsub</code>, create the associated Lefschetz subcomplex <code>lcreduced</code> and the induced multivector field <code>mvfreduced</code> on the subcomplex. The multivectors of the new multivector field are the intersections of the original multivectors and the subcomplex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/conley/restrict_dynamics.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.remove_exit_set" href="#ConleyDynamics.remove_exit_set"><code>ConleyDynamics.remove_exit_set</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_exit_set(lc::LefschetzComplex, mvf::CellSubsets)</code></pre><p>Exit set removal for a multivector field on a Lefschetz subcomplex.</p><p>It is assumed that the Lefschetz complex <code>lc</code> is a topological manifold and that <code>mvf</code> contains a multivector field that is created via either <code>create_planar_mvf</code> or <code>create_spatial_mvf</code>. The function identifies cells on the boundary at which the flows exits the region covered by the Lefschetz complex. If this exit set is closed, we have found an  isolated invariant set and the function returns a Lefschetz complex <code>lcr</code> restricted to it, as well as the restricted multivector field <code>mvfr</code>. If the exit set is not closed, a warning is displayed and the function returns the restricted Lefschetz complex and multivector field obtained by removing the closure of the exit set. In the latter case, unexpected results might be obtained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/conley/remove_exit_set.jl#L3-L19">source</a></section></article><h2 id="Connection-Matrix-Computation"><a class="docs-heading-anchor" href="#Connection-Matrix-Computation">Connection Matrix Computation</a><a id="Connection-Matrix-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Connection-Matrix-Computation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.connection_matrix" href="#ConleyDynamics.connection_matrix"><code>ConleyDynamics.connection_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">connection_matrix(lc::LefschetzComplex, mvf::CellSubsets;
                  [returnbasis::Bool])</code></pre><p>Compute a connection matrix for the multivector field <code>mvf</code> on the Lefschetz complex <code>lc</code> over the field associated with the Lefschetz complex boundary matrix.</p><p>The function returns an object of type <code>ConleyMorseCM</code>. If the optional argument <code>returnbasis::Bool=true</code> is given, then the function also returns a dictionary which gives the basis for the connection matrix columns in terms of the original labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/conley/connection_matrix.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.cm_reduce!" href="#ConleyDynamics.cm_reduce!"><code>ConleyDynamics.cm_reduce!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cm_reduce!(matrix::SparseMatrix, psetvec::Vector{Int};
           [returnbasis::Bool],[returntm::Bool])</code></pre><p>Compute the connection matrix.</p><p>Assumes that <code>matrix</code> is upper triangular and filtered according to <code>psetvec</code>. Modifies the argument <code>matrix</code>.</p><p><strong>Return values:</strong></p><ul><li><code>cmatrix</code>: Connection matrix</li><li><code>cmatrix_cols</code>: Columns of the connection matrix in the boundary</li><li><code>basisvecs</code> (optional): If the argument <code>returnbasis=true</code> is given, this returns information about the computed basis. The k-th entry of <code>basisvecs</code> is a vector containing the columns making up the k-th basis vector, which corresponds to column <code>cmatrix_cols[k]</code>.</li><li><code>tmatrix</code> (optional): If the argument <code>returntm=true</code> is given in addition to <code>returnbasis=true</code>, then instead of <code>basisvecs</code> the function returns the complete transformation matrix. In this case, <code>basicvecs</code> is not returned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/33b581f5c3220bc28a8f266ef1af3e68e2a6d05a/src/conley/cm_reduce.jl#L3-L23">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../homology/">« Homology Functions</a><a class="docs-footer-nextpage" href="../examples/">Example Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 26 September 2024 18:12">Thursday 26 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
