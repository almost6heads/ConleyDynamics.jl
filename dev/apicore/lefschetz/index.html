<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lefschetz Complex Functions · ConleyDynamics.jl</title><meta name="title" content="Lefschetz Complex Functions · ConleyDynamics.jl"/><meta property="og:title" content="Lefschetz Complex Functions · ConleyDynamics.jl"/><meta property="twitter:title" content="Lefschetz Complex Functions · ConleyDynamics.jl"/><meta name="description" content="Documentation for ConleyDynamics.jl."/><meta property="og:description" content="Documentation for ConleyDynamics.jl."/><meta property="twitter:description" content="Documentation for ConleyDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ConleyDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ConleyDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../man/lefschetz/">Lefschetz Complexes</a></li><li><a class="tocitem" href="../../man/homology/">Homology</a></li><li><a class="tocitem" href="../../man/conley/">Conley Theory</a></li><li><a class="tocitem" href="../../man/examples/">Examples</a></li><li><a class="tocitem" href="../../man/sparse/">Sparse Matrices</a></li><li><a class="tocitem" href="../../man/references/">References</a></li></ul></li><li><span class="tocitem">Core API</span><ul><li><a class="tocitem" href="../datastruct/">Composite Data Structures</a></li><li class="is-active"><a class="tocitem" href>Lefschetz Complex Functions</a><ul class="internal"><li><a class="tocitem" href="#Simplicial-Complexes"><span>Simplicial Complexes</span></a></li><li><a class="tocitem" href="#Cubical-Complexes"><span>Cubical Complexes</span></a></li><li><a class="tocitem" href="#Lefschetz-Complex-Creation"><span>Lefschetz Complex Creation</span></a></li><li><a class="tocitem" href="#Lefschetz-Complex-Queries"><span>Lefschetz Complex Queries</span></a></li><li><a class="tocitem" href="#Topological-Features"><span>Topological Features</span></a></li><li><a class="tocitem" href="#Filters-on-Lefschetz-Complexes"><span>Filters on Lefschetz Complexes</span></a></li><li><a class="tocitem" href="#Lefschetz-Helper-Functions"><span>Lefschetz Helper Functions</span></a></li><li><a class="tocitem" href="#Cell-Subset-Helper-Functions"><span>Cell Subset Helper Functions</span></a></li><li><a class="tocitem" href="#Coordinate-Helper-Functions"><span>Coordinate Helper Functions</span></a></li></ul></li><li><a class="tocitem" href="../homology/">Homology Functions</a></li><li><a class="tocitem" href="../conley/">Conley Theory Functions</a></li><li><a class="tocitem" href="../examples/">Example Functions</a></li><li><a class="tocitem" href="../plots/">Plotting Functions</a></li><li><a class="tocitem" href="../sparse/">Sparse Matrix Functions</a></li><li><a class="tocitem" href="../apiindex/">Complete API Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Core API</a></li><li class="is-active"><a href>Lefschetz Complex Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lefschetz Complex Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/main/docs/src/apicore/lefschetz.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lefschetz-Complex-Functions"><a class="docs-heading-anchor" href="#Lefschetz-Complex-Functions">Lefschetz Complex Functions</a><a id="Lefschetz-Complex-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Lefschetz-Complex-Functions" title="Permalink"></a></h1><h2 id="Simplicial-Complexes"><a class="docs-heading-anchor" href="#Simplicial-Complexes">Simplicial Complexes</a><a id="Simplicial-Complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Simplicial-Complexes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_simplicial_complex" href="#ConleyDynamics.create_simplicial_complex"><code>ConleyDynamics.create_simplicial_complex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_simplicial_complex(labels::Vector{String},
                          simplices::Vector{Vector{Int}};
                          p::Int=2)</code></pre><p>Initialize a Lefschetz complex from a simplicial complex. The complex is over the rationals if <code>p=0</code>, and over <code>GF(p)</code> if <code>p&gt;0</code>.</p><p>The vector <code>labels</code> contains a label for every vertex, while <code>simplices</code> contains all the highest-dimensional simplices necessary to define the simplicial complex. Every simplex is represented as a vector of <code>Int</code>, with entries corresponding to the vertex indices.</p><div class="admonition is-warning" id="Warning-4d39d6fae07d8c03"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-4d39d6fae07d8c03" title="Permalink"></a></header><div class="admonition-body"><p>Note that the labels all have to have the same character length!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/create_simplicial_complex.jl#L3-L18">source</a></section><section><div><pre><code class="language-julia hljs">create_simplicial_complex(labels::Vector{String},
                          simplices::Vector{Vector{String}};
                          p::Int=2)</code></pre><p>Initialize a Lefschetz complex from a simplicial complex. The complex is over the rationals if <code>p=0</code>, and over <code>GF(p)</code> if <code>p&gt;0</code>.</p><p>The vector <code>labels</code> contains a label for every vertex, while <code>simplices</code> contains all the highest-dimensional simplices necessary to define the simplicial complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/create_simplicial_complex.jl#L130-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_simplicial_rectangle" href="#ConleyDynamics.create_simplicial_rectangle"><code>ConleyDynamics.create_simplicial_rectangle</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_simplicial_rectangle(nx::Int, ny::Int; p::Int=2)</code></pre><p>Create a simplicial complex covering a rectangle in the plane. The complex is over the rationals if <code>p=0</code>, and over <code>GF(p)</code> if <code>p&gt;0</code>.</p><p>The rectangle is given by the subset <code>[0,nx] x [0,ny]</code> of the plane. Each unit square is represented by four triangles, which meet in the center point of the square. Labels have the following meaning:</p><ul><li>The label <code>XXXYYYb</code> corresponds to the point <code>(XXX, YYY)</code>.</li><li>The label <code>XXXYYYc</code> corresponds to <code>(XXX + 1/2, YYY + 1/2)</code>.</li></ul><p>The number of characters in <code>XXX</code> and <code>YYY</code> matches the number  of digits of the larger number of <code>nx</code> and <code>ny</code>. The function returns the following objects:</p><ul><li>A simplicial complex <code>sc::LefschetzComplex</code>.</li><li>A vector <code>coords::Vector{Vector{Float64}}</code> of vertex coordinates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/create_simplicial_rectangle.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_simplicial_delaunay" href="#ConleyDynamics.create_simplicial_delaunay"><code>ConleyDynamics.create_simplicial_delaunay</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_simplicial_delaunay(boxw::Real, boxh::Real, pdist::Real, attmpt::Int;
                           p::Int=2)</code></pre><p>Create a planar Delaunay triangulation inside a box. The complex is over the rationals if <code>p=0</code>, and over <code>GF(p)</code> if <code>p&gt;0</code>.</p><p>The function selects a random sample of points inside the rectangular box <code>[0,boxw] x [0,boxh]</code>, while trying to maintain a minimum distance  of <code>pdist</code> between the points. The argument <code>attmpt</code> specifies the number of attempts when trying to add points. A standard value is 20, and larger values tend to fill holes better, but at the expense of runtime. From the random sample, the function then creates a Delaunay triangulation, and returns the following objects:</p><ul><li>A simplicial complex <code>sc::LefschetzComplex</code>.</li><li>A vector <code>coords::Vector{Vector{Float64}}</code> of vertex coordinates.</li></ul><p>Note that the function does not provide a full triangulation of the given rectangle. Close to the boundary there will be gaps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/create_simplicial_delaunay.jl#L3-L23">source</a></section><section><div><pre><code class="language-julia hljs">create_simplicial_delaunay(boxw::Real, boxh::Real, npoints::Int;
                           p::Int=2)</code></pre><p>Create a planar Delaunay triangulation inside a box. The complex is over the rationals if <code>p=0</code>, and over <code>GF(p)</code> if <code>p&gt;0</code>.</p><p>The function selects a random sample of <code>npoints</code> points inside the rectangular box <code>[0,boxw] x [0,boxh]</code>. From the random sample, the function then creates a Delaunay triangulation, and returns the following objects:</p><ul><li>A simplicial complex <code>sc::LefschetzComplex</code>.</li><li>A vector <code>coords::Vector{Vector{Float64}}</code> of vertex coordinates.</li></ul><p>Note that the function does not provide a full triangulation of the given rectangle. Close to the boundary there will be gaps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/create_simplicial_delaunay.jl#L78-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.simplicial_torus" href="#ConleyDynamics.simplicial_torus"><code>ConleyDynamics.simplicial_torus</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sc = simplicial_torus(p::Int)</code></pre><p>Create a triangulation of the two-dimensional torus.</p><p>The function returns a simplicial complex which represents a two-dimensional torus. The argument <code>p</code> specifies the characteristic of the underlying field. This triangulation is taken from Figure 6.4 in Munkres&#39; book on Algebraic Topology. The boundary vertices are labeled as letters as in the book, the five center vertices are labeled by <code>1</code> through <code>5</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; println(homology(simplicial_torus(0)))
[1, 2, 1]

julia&gt; println(homology(simplicial_torus(2)))
[1, 2, 1]

julia&gt; println(homology(simplicial_torus(3)))
[1, 2, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/surfaces.jl#L6-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.simplicial_klein_bottle" href="#ConleyDynamics.simplicial_klein_bottle"><code>ConleyDynamics.simplicial_klein_bottle</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sc = simplicial_klein_bottle(p::Int)</code></pre><p>Create a triangulation of the two-dimensional Klein bottle.</p><p>The function returns a simplicial complex which represents the two-dimensional Klein bottle. The argument <code>p</code> specifies the characteristic of the underlying field. This triangulation is taken from Figure 6.6 in Munkres&#39; book on Algebraic Topology. The boundary vertices are labeled as letters as in the book, the five center vertices are labeled by <code>1</code> through <code>5</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; println(homology(simplicial_klein_bottle(0)))
[1, 1, 0]

julia&gt; println(homology(simplicial_klein_bottle(2)))
[1, 2, 1]

julia&gt; println(homology(simplicial_klein_bottle(3)))
[1, 1, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/surfaces.jl#L47-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.simplicial_projective_plane" href="#ConleyDynamics.simplicial_projective_plane"><code>ConleyDynamics.simplicial_projective_plane</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sc = simplicial_projective_plane(p::Int)</code></pre><p>Create a triangulation of the projective plane.</p><p>The function returns a simplicial complex which represents the projective plane. The argument <code>p</code> specifies the characteristic of the underlying field. This triangulation is taken from Figure 6.6 in Munkres&#39; book on Algebraic Topology. The boundary vertices are labeled as letters as in the book, the five center vertices are labeled by <code>1</code> through <code>5</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; println(homology(simplicial_projective_plane(0)))
[1, 0, 0]

julia&gt; println(homology(simplicial_projective_plane(2)))
[1, 1, 1]

julia&gt; println(homology(simplicial_projective_plane(3)))
[1, 0, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/surfaces.jl#L88-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.simplicial_torsion_space" href="#ConleyDynamics.simplicial_torsion_space"><code>ConleyDynamics.simplicial_torsion_space</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sc = simplicial_torsion_space(n::Int, p::Int)</code></pre><p>Create a triangulation of a space with 1-dimensional torsion.</p><p>The function returns a simplicial complex which has the following integer homology groups:</p><ul><li>In dimension 0 it is the group of integers.</li><li>In dimension 1 it is the integers modulo <code>n</code>.</li><li>In dimension 2 it is the trivial group.</li></ul><p>In other words, the simplicial complex has nontrivial torsion in dimension 1. It is a triangulation of an <code>n</code>-gon, in which all boundary edges are oriented counterclockwise, and all of these edges are identified. The parameter <code>p</code> specifies the characteristic of the underlying field.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; println(homology(simplicial_torsion_space(6,2)))
[1, 1, 1]

julia&gt; println(homology(simplicial_torsion_space(6,3)))
[1, 1, 1]

julia&gt; println(homology(simplicial_torsion_space(6,5)))
[1, 0, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/surfaces.jl#L129-L158">source</a></section></article><h2 id="Cubical-Complexes"><a class="docs-heading-anchor" href="#Cubical-Complexes">Cubical Complexes</a><a id="Cubical-Complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Cubical-Complexes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_cubical_complex" href="#ConleyDynamics.create_cubical_complex"><code>ConleyDynamics.create_cubical_complex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_cubical_complex(cubes::Vector{String}; p::Int=2)</code></pre><p>Initialize a Lefschetz complex from a cubical complex. The complex is over the rationals if <code>p=0</code>, and over <code>GF(p)</code> if <code>p&gt;0</code>.</p><p>The vector <code>cubes</code> contains a list of all the highest-dimensional cubes necessary to define the cubical complex. Every cube is represented as a string as follows:</p><ul><li>d integers, which correspond to the coordinates of a point in d-dimensional Euclidean space</li><li>a point <code>.</code></li><li>d integers 0 or 1, which give the interval length in the respective dimension</li></ul><p>The first d integers all have to occupy the same number of characters. In addition, if the occupied space is L characters for each coordinate, the coordinates only can take values from 0 to 10^L - 2. This is due to the fact that the boundary operator will add one to certain coordinates, and they still need to be  representable withing the same L digits.</p><p>For example, the string <code>030600.101</code> corresponds to the point <code>(3,6,0)</code> in three dimensions. The dimensions are 1, 0, and 1, and therefore this string corresponds to the cube <code>[3,4] x [6] x [0,1]</code>. The same cube could have also been represented by <code>360.101</code> or by <code>003006000.101</code>.</p><div class="admonition is-warning" id="Warning-520e32d19edc8d15"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-520e32d19edc8d15" title="Permalink"></a></header><div class="admonition-body"><p>Note that the labels all have to have the same format!</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cubes = [&quot;00.11&quot;, &quot;01.01&quot;, &quot;02.10&quot;, &quot;11.10&quot;, &quot;11.01&quot;, &quot;22.00&quot;];

julia&gt; lc = create_cubical_complex(cubes);

julia&gt; lc.ncells
17

julia&gt; homology(lc)
3-element Vector{Int64}:
 2
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/create_cubical_complex.jl#L3-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_cubical_rectangle" href="#ConleyDynamics.create_cubical_rectangle"><code>ConleyDynamics.create_cubical_rectangle</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_cubical_rectangle(nx::Int, ny::Int;
                         p::Int=2, randomize::Real=0.0)</code></pre><p>Create a cubical complex covering a rectangle in the plane. The complex is over the rationals if <code>p=0</code>, and over <code>GF(p)</code> if <code>p&gt;0</code>.</p><p>The rectangle is given by the subset <code>[0,nx] x [0,ny]</code> of the plane, and each unit square gives a two-dimensional cube in the resulting cubical complex. The function returns the following objects:</p><ul><li>A cubical complex <code>cc::LefschetzComplex</code></li><li>A vector <code>coords::Vector{Vector{Float64}}</code> of vertex coordinates</li></ul><p>If the optional parameter <code>randomize</code> is assigned a positive real fraction <code>r</code> less that 0.5, then the actual coordinates will be randomized. They are chosen uniformly from discs of radius <code>r</code> centered at each vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/create_cubical_rectangle.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_cubical_box" href="#ConleyDynamics.create_cubical_box"><code>ConleyDynamics.create_cubical_box</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_cubical_box(nx::Int, ny::Int, nz::Int;
                   p::Int=2, randomize::Real=0.0)</code></pre><p>Create a cubical complex covering a box in space. The complex is over the rationals if <code>p=0</code>, and over <code>GF(p)</code> if <code>p&gt;0</code>.</p><p>The box is given by the subset <code>[0,nx] x [0,ny] x [0,nz]</code> of space, and each unit cube gives a three-dimensional cube in the resulting cubical complex. The function returns the following objects:</p><ul><li>A cubical complex <code>cc::LefschetzComplex</code></li><li>A vector <code>coords::Vector{Vector{Float64}}</code> of vertex coordinates</li></ul><p>If the optional parameter <code>randomize</code> is assigned a positive real fraction <code>r</code> less that 0.5, then the actual coordinates will be randomized. They are chosen uniformly from balls of radius <code>r</code> centered at each vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/create_cubical_box.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.cube_field_size" href="#ConleyDynamics.cube_field_size"><code>ConleyDynamics.cube_field_size</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cube_field_size(cube::String)</code></pre><p>Determine the field sizes of a given cube label.</p><p>The function returns the dimension of the ambient space in the first output parameter <code>pointdim</code>, and the length of the individual coordinate fields in the second return variable <code>pointlen</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cube_field_size(&quot;011654003020.0110&quot;)
(4, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/create_cubical_complex.jl#L225-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.cube_information" href="#ConleyDynamics.cube_information"><code>ConleyDynamics.cube_information</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cube_information(cube::String)</code></pre><p>Compute a cube&#39;s coordinate information.</p><p>The function returns an integer vector with the cubes coordinate information. The return vector <code>intinfo</code> contains in its components the following data:</p><ul><li><code>1:pointdim</code>: Coordinates of the anchor point</li><li><code>1+pointdim:2*pointdim</code>: Interval length in each dimension</li><li><code>1+2*pointdim</code>: Dimension of the cube</li></ul><p>Note that <code>pointdim</code> equals the dimension of the points specifying the cube.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cube_information(&quot;011654003.011&quot;)
7-element Vector{Int64}:
  11
 654
   3
   0
   1
   1
   2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/create_cubical_complex.jl#L251-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.cube_label" href="#ConleyDynamics.cube_label"><code>ConleyDynamics.cube_label</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cube_label(pointdim::Int, pointlen::Int, pointinfo::Vector{Int})</code></pre><p>Create a label from a cube&#39;s coordinate information.</p><p>The dimension of the ambient Eucliden space is <code>pointdim</code>, while the field length for each coordinate is <code>pointlen</code>. The vector <code>pointinfo</code> has to be of length at least two times <code>pointdim</code>. The first <code>pointdim</code> entries contain the coordinates of the anchor point, while the next <code>pointdim</code> entries are either 0 or 1 depending on the size of the interval. For example, if <code>poindim = 3</code> and <code>pointinfo = [1,2,3,1,0,1]</code>, then we represent the cube in three-dimensional space given by <code>[1,2] x [2] x [3 4]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cube_label(3,2,[10,23,5,1,1,0])
&quot;102305.110&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/create_cubical_complex.jl#L327-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.get_cubical_coords" href="#ConleyDynamics.get_cubical_coords"><code>ConleyDynamics.get_cubical_coords</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_cubical_coords(cc::LefschetzComplex)</code></pre><p>Compute the vertex coordinates for a cubical complex.</p><p>The variable <code>cc</code> has to contain a cubical complex, and the function returns a vector of coordinates for the vertices of the complex, that can then be used for plotting. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/create_cubical_complex.jl#L367-L376">source</a></section></article><h2 id="Lefschetz-Complex-Creation"><a class="docs-heading-anchor" href="#Lefschetz-Complex-Creation">Lefschetz Complex Creation</a><a id="Lefschetz-Complex-Creation-1"></a><a class="docs-heading-anchor-permalink" href="#Lefschetz-Complex-Creation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_lefschetz_gf2" href="#ConleyDynamics.create_lefschetz_gf2"><code>ConleyDynamics.create_lefschetz_gf2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_lefschetz_gf2(defcellbnd)</code></pre><p>Create a Lefschetz complex over <code>GF(2)</code> by specifying its essential cells and boundaries.</p><p>The input argument <code>defcellbnd</code> has to be a vector of vectors. Each entry <code>defcellbnd[k]</code> has to be of one of the following two forms:</p><ul><li><code>[String, Int, String, String, ...]</code>: The first <code>String</code> contains  the label for the cell <code>k</code>, followed by its dimension in the second  entry. The remaining entries are for the labels of the cells which  make up the boundary.</li><li><code>[String, Int]</code>: This shorther form is for cells with empty boundary. The first entry denotes the cell label, and the second its dimension.</li></ul><p>The cells of the resulting Lefschetz complex correspond to the union of all occurring labels. Cell labels that only occur in the boundary specification are assumed to have empty boundary, and they do not have to be specified separately in the second form above. However, if their boundary is not empty, they have to be listed via the above first form as well.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; defcellbnd = [[&quot;A&quot;,0], [&quot;a&quot;,1,&quot;B&quot;,&quot;C&quot;], [&quot;b&quot;,1,&quot;B&quot;,&quot;C&quot;]];

julia&gt; push!(defcellbnd, [&quot;c&quot;,1,&quot;B&quot;,&quot;C&quot;]);

julia&gt; push!(defcellbnd, [&quot;alpha&quot;,2,&quot;b&quot;,&quot;c&quot;]);

julia&gt; lc = create_lefschetz_gf2(defcellbnd);

julia&gt; lc.labels
7-element Vector{String}:
 &quot;A&quot;
 &quot;B&quot;
 &quot;C&quot;
 &quot;a&quot;
 &quot;b&quot;
 &quot;c&quot;
 &quot;alpha&quot;

julia&gt; homology(lc)
3-element Vector{Int64}:
 2
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/create_lefschetz_gf2.jl#L3-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_subcomplex" href="#ConleyDynamics.lefschetz_subcomplex"><code>ConleyDynamics.lefschetz_subcomplex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_subcomplex(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Extract a subcomplex from a Lefschetz complex. The subcomplex has to be locally closed, and is given by the collection of cells in <code>subcomp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_subcomplex.jl#L3-L8">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_subcomplex(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Extract a subcomplex from a Lefschetz complex. The subcomplex has to be locally closed, and is given by the collection of cells in <code>subcomp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_subcomplex.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_closed_subcomplex" href="#ConleyDynamics.lefschetz_closed_subcomplex"><code>ConleyDynamics.lefschetz_closed_subcomplex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_closed_subcomplex(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Extract a closed subcomplex from a Lefschetz complex. The subcomplex is the closure of the collection of cells given in <code>subcomp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_closed_subcomplex.jl#L3-L8">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_closed_subcomplex(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Extract a closed subcomplex from a Lefschetz complex. The subcomplex is the closure of the collection of cells given in <code>subcomp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_closed_subcomplex.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_reduction" href="#ConleyDynamics.lefschetz_reduction"><code>ConleyDynamics.lefschetz_reduction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_reduction(lc::LefschetzComplex, redpairs::Vector{Vector{Int}})</code></pre><p>Apply a sequence of elementary reductions to a Lefschetz complex.</p><p>The reduction pairs have to be specified in the argument <code>redpairs</code>. Each entry has to be a vector of length two which contains an elementary reduction pair in index form. In particular, the dimensions of the two cells in the pair have to differ by one, and once the pair is reached in the reduction sequence, one cell has to be a face of the other. The function returns a new Lefschetz complex, where all cells in <code>redpairs</code> have been removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_reduction.jl#L3-L14">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_reduction(lc::LefschetzComplex, redpairs::Vector{Vector{String}})</code></pre><p>Apply a sequence of elementary reductions to a Lefschetz complex.</p><p>The reduction pairs have to be specified in the argument <code>redpairs</code>. Each entry has to be a vector of length two which contains an elementary reduction pair in label form. In particular, the dimensions of the two cells in the pair have to differ by one, and once the pair is reached in the reduction sequence, one cell has to be a face of the other. The function returns a new Lefschetz complex, where all cells in <code>redpairs</code> have been removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_reduction.jl#L96-L107">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_reduction(lc::LefschetzComplex, r1::Int, r2::Int)</code></pre><p>Apply a single elementary reduction to a Lefschetz complex.</p><p>This method expects that the two cells <code>r1</code> and <code>r2</code> which form the reduction pair are given in index form. The function returns the reduced Lefschetz complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_reduction.jl#L122-L129">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_reduction(lc::LefschetzComplex, r1::String, r2::String)</code></pre><p>Apply a single elementary reduction to a Lefschetz complex.</p><p>This method expects that the two cells <code>r1</code> and <code>r2</code> which form the reduction pair are given in label form. The function returns the reduced Lefschetz complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_reduction.jl#L132-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_reduction_maps" href="#ConleyDynamics.lefschetz_reduction_maps"><code>ConleyDynamics.lefschetz_reduction_maps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_reduction_maps(lc::LefschetzComplex, redpairs::Vector{Vector{Int}})</code></pre><p>Apply a sequence of elementary reductions to a Lefschetz complex and return the associated chain maps.</p><p>The reduction pairs have to be specified in the argument <code>redpairs</code>. Each entry has to be a vector of length two which contains an elementary reduction pair in index form. In particular, the dimensions of the two cells in the pair have to differ by one, and once the pair is reached in the reduction sequence, one cell has to be a face of the other. The function returns a new Lefschetz complex, where all cells in <code>redpairs</code> have been removed, as well as the associated chain maps.</p><p>The return values are as follows:</p><ul><li><code>lcred</code>: The first variable contains the reduced Lefschetz complex.</li><li><code>pp</code>: This is a sparse matrix representation of the chain equivalence between the original complex and the reduced one.</li><li><code>jj</code>: This is a sparse matrix representation of the chain equivalence between the reduced complex and the original one.</li><li><code>hh</code>: This is a sparse matrix representation of the chain homotopy which shows that the composition <code>jj * pp</code> is chain homotopic to the identity.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; labels = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;, &quot;d&quot;];

julia&gt; simplices = [[&quot;a&quot;,&quot;b&quot;], [&quot;b&quot;,&quot;c&quot;], [&quot;c&quot;,&quot;d&quot;]];

julia&gt; sc = create_simplicial_complex(labels, simplices, p=0);

julia&gt; redpairs = [[&quot;b&quot;, &quot;bc&quot;], [&quot;d&quot;, &quot;cd&quot;]];

julia&gt; scr, pp, jj, hh = lefschetz_reduction_maps(sc,redpairs);

julia&gt; bnd = deepcopy(sc.boundary);

julia&gt; bndr = deepcopy(scr.boundary);

julia&gt; ii = sparse_identity(sc.ncells, p=0);

julia&gt; sparse_nz_count(pp*bnd - bndr*pp)
0

julia&gt; sparse_nz_count(jj*bndr - bnd*jj)
0

julia&gt; full_from_sparse(pp*jj)
3×3 Matrix{Rational{Int64}}:
 1  0  0
 0  1  0
 0  0  1

julia&gt; full_from_sparse(jj*pp)
7×7 Matrix{Rational{Int64}}:
 1  0  0  0  0  0  0
 0  0  0  0  0  0  0
 0  1  1  1  0  0  0
 0  0  0  0  0  0  0
 0  0  0  0  1  0  0
 0  0  0  0  1  0  0
 0  0  0  0  0  0  0

julia&gt; sparse_nz_count(ii + bnd*hh + hh*bnd - jj*pp)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_reduction_maps.jl#L4-L70">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_reduction_maps(lc::LefschetzComplex, redpairs::Vector{Vector{String}})</code></pre><p>Apply a sequence of elementary reductions to a Lefschetz complex and return the chain maps.</p><p>The reduction pairs have to be specified in the argument <code>redpairs</code>. Each entry has to be a vector of length two which contains an elementary reduction pair in label form. In particular, the dimensions of the two cells in the pair have to differ by one, and once the pair is reached in the reduction sequence, one cell has to be a face of the other. The function returns a new Lefschetz complex, where all cells in <code>redpairs</code> have been removed, as well as the involved chain maps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_reduction_maps.jl#L206-L218">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_reduction_maps(lc::LefschetzComplex, r1::Int, r2::Int)</code></pre><p>Apply a single elementary reduction to a Lefschetz complex and return the chain maps.</p><p>This method expects that the two cells <code>r1</code> and <code>r2</code> which form the reduction pair are given in index form. The function returns the reduced Lefschetz complex, as well as the involved chain maps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_reduction_maps.jl#L234-L243">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_reduction_maps(lc::LefschetzComplex, r1::String, r2::String)</code></pre><p>Apply a single elementary reduction to a Lefschetz complex and return the chain maps.</p><p>This method expects that the two cells <code>r1</code> and <code>r2</code> which form the reduction pair are given in label form. The function returns the reduced Lefschetz complex, as well as the involved chain maps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_reduction_maps.jl#L247-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_newbasis" href="#ConleyDynamics.lefschetz_newbasis"><code>ConleyDynamics.lefschetz_newbasis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_newbasis(lc::LefschetzComplex, basis::SparseMatrix; maps::Bool=false)</code></pre><p>Create a new Lefschetz complex via change of basis.</p><p>The new basis has to be specified in the sparse matrix <code>basis</code>, whose columns represent the new basis in terms of the existing one. This matrix has to respect the grading by dimension, i.e., the cells which are used to form a new basis chain have to have the same dimensions as the cell which is being replaced. The function returns the new Lefschetz complex <code>lcnew</code>. If the optional parameter <code>maps = true</code> is passed, the the function also returns the chain maps <code>pp</code> and <code>jj</code> which are the isomorphisms from <code>lc</code> to <code>lcnew</code>, and vice versa, as well as the zero chain homotopy <code>hh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_newbasis.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_newbasis_maps" href="#ConleyDynamics.lefschetz_newbasis_maps"><code>ConleyDynamics.lefschetz_newbasis_maps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_newbasis_maps(lc::LefschetzComplex, basis::SparseMatrix)</code></pre><p>Create a new Lefschetz complex via change of basis and return the associated chain maps.</p><p>The new basis has to be specified in the sparse matrix <code>basis</code>, whose columns represent the new basis in terms of the existing one. This matrix has to respect the grading by dimension, i.e., the cells which are used to form a new basis chain have to have the same dimensions as the cell which is being replaced. The function returns the new Lefschetz complex <code>lcnew</code>, as well as the chain maps <code>pp</code> and <code>jj</code> which are the isomorphisms from <code>lc</code> to <code>lcnew</code>, and vice versa.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_newbasis.jl#L66-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.compose_reductions" href="#ConleyDynamics.compose_reductions"><code>ConleyDynamics.compose_reductions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compose_reductions(pp1::SparseMatrix, jj1::SparseMatrix, hh1::SparseMatrix, 
                   pp2::SparseMatrix, jj2::SparseMatrix, hh2::SparseMatrix)</code></pre><p>Combine the chain maps and chain homotopies of two reductions.</p><p>The function expects the chain maps and chain homotopies of two Lefschetz complex reductions, and computes the chain maps and chain homotopy for the composition of both. The maps <code>ppX</code>, <code>jjX</code>, and <code>hhX</code> can be obtained via either <code>lefschetz_reduction_maps</code> or <code>lefschetz_newbasis_maps</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_reduction_maps.jl#L260-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.permute_lefschetz_complex" href="#ConleyDynamics.permute_lefschetz_complex"><code>ConleyDynamics.permute_lefschetz_complex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">permute_lefschetz_complex(lc::LefschetzComplex,
                          permutation::Vector{Int})</code></pre><p>Permute the indices of a Lefschetz complex.</p><p>The vector <code>permutation</code> contains a permutation of the indices for the given Lefschetz complex <code>lc</code>. If no permutation is specified, or if the length of the vector is not correct, then a randomly generated one will be used. Note that the permutation has to respect the ordering of the cells by dimension, otherwise an error is raised. In other words,  the permutation has to decompose into permutations within each dimension. This is automatically done if no permutation is explicitly specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/permute_lefschetz_complex.jl#L3-L16">source</a></section></article><h2 id="Lefschetz-Complex-Queries"><a class="docs-heading-anchor" href="#Lefschetz-Complex-Queries">Lefschetz Complex Queries</a><a id="Lefschetz-Complex-Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Lefschetz-Complex-Queries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_information" href="#ConleyDynamics.lefschetz_information"><code>ConleyDynamics.lefschetz_information</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_information(lc::LefschetzComplex)</code></pre><p>Extract basic information about a Lefschetz complex.</p><p>The input argument <code>lc</code> contains the Lefschetz complex. The function returns the information in the form of a <code>Dict{String,Any}</code>. You can use the command <code>keys</code> to see the keyset of the return dictionary:</p><ul><li><code>&quot;Dimension&quot;</code>: Dimension of the Lefschetz complex</li><li><code>&quot;Coefficient field&quot;</code>: Underlying coefficient field</li><li><code>&quot;Euler characteristic&quot;</code>: Euler characteristic of the complex</li><li><code>&quot;Homology&quot;</code>: Betti numbers of the Lefschetz complex</li><li><code>&quot;Boundary sparsity&quot;</code>: Sparsity percentage of the boundary matrix</li><li><code>&quot;Number of cells&quot;</code>: Total number of cells in the complex</li><li><code>&quot;Cell counts by dim&quot;</code>: Cell counts by dimension</li></ul><p>In the last case, the dictionary entry is a vector of pairs <code>(dimension, cell count)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_information.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_cell_count" href="#ConleyDynamics.lefschetz_cell_count"><code>ConleyDynamics.lefschetz_cell_count</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_cell_count(lc::LefschetzComplex; bounds::Bool=false)</code></pre><p>Returns the number of cells in each dimension.</p><p>The function returns the number of cells in each dimension. The return variable is of type <code>Vector{Int}</code>, has length <code>lc.dim + 1</code>, and its k-th entry contains the number of cells in dimension k-1. If the optional parameter <code>bounds=true</code> is passed, then the  function also returns two integer vectors <code>lo</code> and <code>hi</code>. These contain the beginning and end indices of the cells in each  dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_cell_count.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_field" href="#ConleyDynamics.lefschetz_field"><code>ConleyDynamics.lefschetz_field</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fieldstr = lefschetz_field(lc::LefschetzComplex)</code></pre><p>Returns the Lefschetz complex coefficient field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_field.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_is_closed" href="#ConleyDynamics.lefschetz_is_closed"><code>ConleyDynamics.lefschetz_is_closed</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_is_closed(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Determine whether a Lefschetz complex subset is closed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_is_closed.jl#L3-L7">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_is_closed(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Determine whether a Lefschetz complex subset is closed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_is_closed.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_is_locally_closed" href="#ConleyDynamics.lefschetz_is_locally_closed"><code>ConleyDynamics.lefschetz_is_locally_closed</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_is_locally_closed(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Determine whether a Lefschetz complex subset is locally closed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_is_locally_closed.jl#L3-L7">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_is_locally_closed(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Determine whether a Lefschetz complex subset is locally closed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_is_locally_closed.jl#L28-L32">source</a></section></article><h2 id="Topological-Features"><a class="docs-heading-anchor" href="#Topological-Features">Topological Features</a><a id="Topological-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Topological-Features" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_boundary" href="#ConleyDynamics.lefschetz_boundary"><code>ConleyDynamics.lefschetz_boundary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_boundary(lc::LefschetzComplex, cellI::Int)</code></pre><p>Compute the support of the boundary of a Lefschetz complex cell.</p><p>This method returns the boundary support as a <code>Vector{Int}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_boundary.jl#L3-L9">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_boundary(lc::LefschetzComplex, cellS::String)</code></pre><p>Compute the support of the boundary of a Lefschetz complex cell.</p><p>This method returns the boundary support as a <code>Vector{String}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_boundary.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_coboundary" href="#ConleyDynamics.lefschetz_coboundary"><code>ConleyDynamics.lefschetz_coboundary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_coboundary(lc::LefschetzComplex, cellI::Int)</code></pre><p>Compute the support of the coboundary of a Lefschetz complex cell.</p><p>This method returns the boundary support as a <code>Vector{Int}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_boundary.jl#L59-L65">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_coboundary(lc::LefschetzComplex, cellS::String)</code></pre><p>Compute the support of the coboundary of a Lefschetz complex cell.</p><p>This method returns the boundary support as a <code>Vector{String}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_boundary.jl#L88-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_closure" href="#ConleyDynamics.lefschetz_closure"><code>ConleyDynamics.lefschetz_closure</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_closure(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Compute the closure of a Lefschetz complex subset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_closure.jl#L3-L7">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_closure(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Compute the closure of a Lefschetz complex subset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_closure.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_interior" href="#ConleyDynamics.lefschetz_interior"><code>ConleyDynamics.lefschetz_interior</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_interior(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Compute the interior of a Lefschetz complex subset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_interior.jl#L3-L7">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_interior(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Compute the interior of a Lefschetz complex subset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_interior.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_topboundary" href="#ConleyDynamics.lefschetz_topboundary"><code>ConleyDynamics.lefschetz_topboundary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_topboundary(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Compute the topological boundary of a Lefschetz complex subset.</p><p>In contrast to the algebraic boundary defined via the boundary operator, this function computes the boundary of the Lefschetz complex subset specified in <code>subcomp</code> if the Lefschetz complex is interpreted as a finite topological space. In other words, the topological boundary is the set difference of the closure and the interior of the subset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_topboundary.jl#L3-L13">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_topboundary(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Compute the topological boundary of a Lefschetz complex subset.</p><p>In contrast to the algebraic boundary defined via the boundary operator, this function computes the boundary of the Lefschetz complex subset specified in <code>subcomp</code> if the Lefschetz complex is interpreted as a finite topological space. In other words, the topological boundary is the set difference of the closure and the interior of the subset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_topboundary.jl#L29-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_openhull" href="#ConleyDynamics.lefschetz_openhull"><code>ConleyDynamics.lefschetz_openhull</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_openhull(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Compute the open hull of a Lefschetz complex subset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_openhull.jl#L3-L7">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_openhull(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Compute the open hull of a Lefschetz complex subset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_openhull.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_lchull" href="#ConleyDynamics.lefschetz_lchull"><code>ConleyDynamics.lefschetz_lchull</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_lchull(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Compute the locally closed hull of a Lefschetz complex subset.</p><p>The locally closed hull is the smallest locally closed set which contains the given cells. It is the intersection of the closure and the open hull.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_lchull.jl#L3-L11">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_lchull(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Compute the locally closed hull of a Lefschetz complex subset.</p><p>The locally closed hull is the smallest locally closed set which contains the given cells. It is the intersection of the closure and the open hull.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_lchull.jl#L28-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_clomo_pair" href="#ConleyDynamics.lefschetz_clomo_pair"><code>ConleyDynamics.lefschetz_clomo_pair</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_clomopair(lc::LefschetzComplex, subcomp::Vector{Int})</code></pre><p>Determine the closure-mouth-pair associated with a Lefschetz complex subset.</p><p>The function returns the pair <code>(closure,mouth)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_clomo_pair.jl#L3-L9">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_clomopair(lc::LefschetzComplex, subcomp::Vector{String})</code></pre><p>Determine the closure-mouth-pair associated with a Lefschetz complex subset.</p><p>The function returns the pair <code>(closure,mouth)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_clomo_pair.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_skeleton" href="#ConleyDynamics.lefschetz_skeleton"><code>ConleyDynamics.lefschetz_skeleton</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_skeleton(lc::LefschetzComplex, subcomp::Vector{Int}, skdim::Int)</code></pre><p>Compute the <code>skdim</code>-dimensional skeleton of a Lefschetz complex subset.</p><p>The computed skeleton is for the closure of the subcomplex given by <code>subcomp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_skeleton.jl#L3-L9">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_skeleton(lc::LefschetzComplex, subcomp::Vector{String}, skdim::Int)</code></pre><p>Compute the <code>skdim</code>-dimensional skeleton of a Lefschetz complex subset.</p><p>The computed skeleton is for the closure of the subcomplex given by <code>subcomp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_skeleton.jl#L34-L40">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_skeleton(lc::LefschetzComplex, skdim::Int)</code></pre><p>Compute the <code>skdim</code>-dimensional skeleton of a Lefschetz complex.</p><p>The computed skeleton is for the full Lefschetz complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_skeleton.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.manifold_boundary" href="#ConleyDynamics.manifold_boundary"><code>ConleyDynamics.manifold_boundary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">manifold_boundary(lc::LefschetzComplex)</code></pre><p>Extract the manifold boundary from a Lefschetz complex.</p><p>The function expects a Lefschetz complex which represents a compact d-dimensional manifold with boundary. It returns a  list of all cells which lie on the topological boundary of the manifold, in the form of a <code>Vector{Int}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/manifold_boundary.jl#L3-L12">source</a></section></article><h2 id="Filters-on-Lefschetz-Complexes"><a class="docs-heading-anchor" href="#Filters-on-Lefschetz-Complexes">Filters on Lefschetz Complexes</a><a id="Filters-on-Lefschetz-Complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Filters-on-Lefschetz-Complexes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.create_random_filter" href="#ConleyDynamics.create_random_filter"><code>ConleyDynamics.create_random_filter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_random_filter(lc::LefschetzComplex)</code></pre><p>Create a random injective filter on a Lefschetz complex.</p><p>The function creates a random injective filter on a Lefschetz complex. The filter is created by assigning integers to cell groups, increasing with dimension. Within each dimension the assignment is random, but all filter values of cells of dimension <code>k</code> are less than all filter values of cells with dimension <code>k+1</code>. The function returns the filter as <code>Vector{Int}</code>, with indices corresponding to the cell indices in the Lefschetz complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/filters.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.filter_shallow_pairs" href="#ConleyDynamics.filter_shallow_pairs"><code>ConleyDynamics.filter_shallow_pairs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter_shallow_pairs(lc::LefschetzComplex, phi)</code></pre><p>Find all shallow pairs for a filter.</p><p>This function finds all shallow pairs for the filter <code>phi</code>. These are face-coface pairs <code>(x,y)</code> whose dimensions differ by one, and such that <code>y</code> has the smallest filter value on the coboundary of <code>x</code>, and <code>x</code> has the largest filter value on the boundary of <code>y</code>.</p><p>If the filter is injective, these pairs give rise to a Forman vector field on the underlying Lefschetz complex. For noninjective filters this is not true in general.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/filters.jl#L45-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.filter_induced_mvf" href="#ConleyDynamics.filter_induced_mvf"><code>ConleyDynamics.filter_induced_mvf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter_induced_mvf(lc::LefschetzComplex, phi)</code></pre><p>Compute the multivector field induced by a filter.</p><p>This function returns the smallest multivector field which has the property that every shallow pair is contained in a multivector. For injective filters this is a Forman vector field, but in the noninjective case it can be a general multivector field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/filters.jl#L77-L86">source</a></section></article><h2 id="Lefschetz-Helper-Functions"><a class="docs-heading-anchor" href="#Lefschetz-Helper-Functions">Lefschetz Helper Functions</a><a id="Lefschetz-Helper-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Lefschetz-Helper-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_gfp_conversion" href="#ConleyDynamics.lefschetz_gfp_conversion"><code>ConleyDynamics.lefschetz_gfp_conversion</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lcgfp = lefschetz_gfp_conversion(lc::LefschetzComplex, p::Int)</code></pre><p>Convert a Lefschetz complex to the same complex over a finite field.</p><p>It is expected that the boundary matrix of the given Lefschetz complex <code>lc</code> is defined over the rationals, and that the target characteristic <code>p</code> is a prime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_gfp_conversion.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.lefschetz_filtration" href="#ConleyDynamics.lefschetz_filtration"><code>ConleyDynamics.lefschetz_filtration</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lefschetz_filtration(lc::LefschetzComplex, fvalues::Vector{Int})</code></pre><p>Compute a filtration on a Lefschetz subset.</p><p>The considered Lefschetz complex is given in <code>lc</code>. The vector <code>fvalues</code> assigns an integer between 0 and N to every cell in <code>lc</code>. For every k the complex <code>L_k</code> is given by the closure of all cells with values between 1 and k. The function returns the following variables:</p><ul><li><code>lcsub</code>: The subcomplex <code>L_N</code></li><li><code>fvalsub</code>: The filtration on the subcomplex with values 1,...,N</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; labels = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;];

julia&gt; simplices = [[&quot;A&quot;,&quot;B&quot;,&quot;D&quot;],[&quot;B&quot;,&quot;D&quot;,&quot;E&quot;],[&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;C&quot;,&quot;E&quot;,&quot;F&quot;],[&quot;F&quot;,&quot;G&quot;]];

julia&gt; sc = create_simplicial_complex(labels,simplices);

julia&gt; filtration = [0,0,0,0,0,0,0,1,1,0,1,2,0,4,2,4,0,5,3,7,6];

julia&gt; lcsub, fvalsub = lefschetz_filtration(sc,filtration);

julia&gt; phinf, phint = persistent_homology(lcsub,fvalsub);

julia&gt; phinf
3-element Vector{Vector{Int64}}:
 [1]
 []
 []

julia&gt; phint
3-element Vector{Vector{Tuple{Int64, Int64}}}:
 []
 [(1, 5), (2, 7), (4, 6)]
 []</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_filtration.jl#L3-L41">source</a></section><section><div><pre><code class="language-julia hljs">lefschetz_filtration(lc::LefschetzComplex, strfilt::Vector{Vector{String}})</code></pre><p>Compute a filtration on a Lefschetz subset.</p><p>The considered Lefschetz complex is given in <code>lc</code>. The vector of string vectors <code>strfilt</code> contains the necessary simplices to build the filtration. The list <code>strfilt[k]</code> contains the simplices that are added at the k-th step, together with their closures. Thus, for every k the complex <code>L_k</code> is given by the closure of all cells listed in <code>strfilt[i]</code> for <code>i</code> between 1 and k. The function returns the following variables:</p><ul><li><code>lcsub</code>: The subcomplex <code>L_N</code>, where <code>N = length(strfilt)</code></li><li><code>fvalsub</code>: The filtration on the subcomplex with values 1,...,N</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; labels = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;];

julia&gt; simplices = [[&quot;A&quot;,&quot;B&quot;,&quot;D&quot;],[&quot;B&quot;,&quot;D&quot;,&quot;E&quot;],[&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;C&quot;,&quot;E&quot;,&quot;F&quot;],[&quot;F&quot;,&quot;G&quot;]];

julia&gt; sc = create_simplicial_complex(labels,simplices);

julia&gt; strfiltration = [[&quot;AB&quot;,&quot;AD&quot;,&quot;BD&quot;],[&quot;BE&quot;,&quot;DE&quot;],[&quot;BCE&quot;],[&quot;CF&quot;,&quot;EF&quot;],[&quot;ABD&quot;],[&quot;CEF&quot;],[&quot;BDE&quot;]];

julia&gt; lcsub, fvalsub = lefschetz_filtration(sc, strfiltration);

julia&gt; phinf, phint = persistent_homology(lcsub,fvalsub);

julia&gt; phinf
3-element Vector{Vector{Int64}}:
 [1]
 []
 []

julia&gt; phint
3-element Vector{Vector{Tuple{Int64, Int64}}}:
 []
 [(1, 5), (2, 7), (4, 6)]
 []</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/lefschetz_filtration.jl#L85-L125">source</a></section></article><h2 id="Cell-Subset-Helper-Functions"><a class="docs-heading-anchor" href="#Cell-Subset-Helper-Functions">Cell Subset Helper Functions</a><a id="Cell-Subset-Helper-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Cell-Subset-Helper-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.convert_cells" href="#ConleyDynamics.convert_cells"><code>ConleyDynamics.convert_cells</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_cells(lc::LefschetzComplex, cl::Vector{Int})</code></pre><p>Convert cell list <code>cl</code> in the Lefschetz complex <code>lc</code> from  index form to label form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/convert_cells.jl#L3-L8">source</a></section><section><div><pre><code class="language-julia hljs">convert_cells(lc::LefschetzComplex, cl::Vector{String})</code></pre><p>Convert cell list <code>cl</code> in the Lefschetz complex <code>lc</code> from  label form to index form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/convert_cells.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.convert_cellsubsets" href="#ConleyDynamics.convert_cellsubsets"><code>ConleyDynamics.convert_cellsubsets</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_cellsubsets(lc::LefschetzComplex, clsub::Vector{Vector{Int}})</code></pre><p>Convert CellSubsets <code>clsub</code> in the Lefschetz complex <code>lc</code> from  index form to label form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/convert_cells.jl#L31-L36">source</a></section><section><div><pre><code class="language-julia hljs">convert_cellsubsets(lc::LefschetzComplex, clsub::Vector{Vector{String}})</code></pre><p>Convert CellSubsets <code>clsub</code> in the Lefschetz complex <code>lc</code> from  label form to index form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/convert_cells.jl#L54-L59">source</a></section></article><h2 id="Coordinate-Helper-Functions"><a class="docs-heading-anchor" href="#Coordinate-Helper-Functions">Coordinate Helper Functions</a><a id="Coordinate-Helper-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinate-Helper-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.convert_planar_coordinates" href="#ConleyDynamics.convert_planar_coordinates"><code>ConleyDynamics.convert_planar_coordinates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_planar_coordinates(coords::Vector{Vector{Float64}},
                           p0::Vector{Float64},
                           p1::Vector{Float64})</code></pre><p>Convert a given collection of planar coordinates.</p><p>The vector <code>coords</code> contains pairs of coordinates, which are then transformed to fit into the box with vertices <code>p0 = (p0x,p0y)</code> and <code>p1 = (p1x,p1y)</code>. It is assumed that <code>p0</code> denotes the lower left box corner, while <code>p1</code> is the upper right corner. The function shifts and scales the coordinates in such a way that every side of the box contains at least one point. Upon completion, it returns a new coordinate vector <code>coordsNew</code>.</p><p>More precisely, if the x-coordinates are spanning the interval <code>[xmin,xmax]</code> and the y-coordinates span <code>[ymin,ymax]</code>, then the point <code>(x,y)</code> is transformed to <code>(xn,yn)</code> with:</p><ul><li><code>xn = p0x + (p1x-p0x) * (x-cxmin) / (cxmax-cxmin)</code></li><li><code>yn = p0y + (p1y-p0y) * (y-cymin) / (cymax-cymin)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/convert_coordinates.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.convert_spatial_coordinates" href="#ConleyDynamics.convert_spatial_coordinates"><code>ConleyDynamics.convert_spatial_coordinates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_spatial_coordinates(coords::Vector{Vector{Float64}},
                            p0::Vector{Float64},
                            p1::Vector{Float64})</code></pre><p>Convert a given collection of spatial coordinates.</p><p>The vector <code>coords</code> contains triples of coordinates, which are then transformed to fit into the box with vertices <code>p0 = (p0x,p0y,p0z)</code> and <code>p1 = (p1x,p1y,p1z)</code>. It is assumed that each coordinate of <code>p0</code> is strictly smaller than the corresponding coordinate of <code>p1</code>. The function shifts and scales the coordinates in such a way that every side of the box contains at least one point. Upon completion, it returns a new coordinate vector <code>coordsNew</code>.</p><p>More precisely, if the x-coordinates are spanning the interval <code>[xmin,xmax]</code>, the y-coordinates span <code>[ymin,ymax]</code>, and the z-coordinates span <code>[zmin,zmax]</code>, then the point <code>(x,y,z)</code> is transformed to <code>(xn,yn,zn)</code> with:</p><ul><li><code>xn = p0x + (p1x-p0x) * (x-cxmin) / (cxmax-cxmin)</code></li><li><code>yn = p0y + (p1y-p0y) * (y-cymin) / (cymax-cymin)</code></li><li><code>zn = p0z + (p1z-p0z) * (z-czmin) / (czmax-czmin)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/7d1e2274aacbba4c01023c9e87912035c8f771f6/src/lefschetz/convert_coordinates.jl#L52-L75">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../datastruct/">« Composite Data Structures</a><a class="docs-footer-nextpage" href="../homology/">Homology Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 28 July 2025 15:52">Monday 28 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
