<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sparse Matrices · ConleyDynamics.jl</title><meta name="title" content="Sparse Matrices · ConleyDynamics.jl"/><meta property="og:title" content="Sparse Matrices · ConleyDynamics.jl"/><meta property="twitter:title" content="Sparse Matrices · ConleyDynamics.jl"/><meta name="description" content="Documentation for ConleyDynamics.jl."/><meta property="og:description" content="Documentation for ConleyDynamics.jl."/><meta property="twitter:description" content="Documentation for ConleyDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ConleyDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ConleyDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../lefschetz/">Lefschetz Complexes</a></li><li><a class="tocitem" href="../homology/">Homology</a></li><li><a class="tocitem" href="../conley/">Conley Theory</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Sparse Matrices</a><ul class="internal"><li><a class="tocitem" href="#Sparse-Matrix-Format"><span>Sparse Matrix Format</span></a></li><li><a class="tocitem" href="#Creating-Sparse-Matrices"><span>Creating Sparse Matrices</span></a></li><li><a class="tocitem" href="#Sparse-Matrix-Access"><span>Sparse Matrix Access</span></a></li><li><a class="tocitem" href="#Elementary-Matrix-Operations"><span>Elementary Matrix Operations</span></a></li><li><a class="tocitem" href="#Sparse-Matrix-Information"><span>Sparse Matrix Information</span></a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul></li><li><span class="tocitem">Core API</span><ul><li><a class="tocitem" href="../../apicore/datastruct/">Composite Data Structures</a></li><li><a class="tocitem" href="../../apicore/lefschetz/">Lefschetz Complex Functions</a></li><li><a class="tocitem" href="../../apicore/homology/">Homology Functions</a></li><li><a class="tocitem" href="../../apicore/conley/">Conley Theory Functions</a></li><li><a class="tocitem" href="../../apicore/examples/">Example Functions</a></li><li><a class="tocitem" href="../../apicore/plots/">Plotting Functions</a></li><li><a class="tocitem" href="../../apicore/sparse/">Sparse Matrix Functions</a></li><li><a class="tocitem" href="../../apicore/apiindex/">Complete API Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Sparse Matrices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sparse Matrices</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/main/docs/src/man/sparse.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sparse-Matrices"><a class="docs-heading-anchor" href="#Sparse-Matrices">Sparse Matrices</a><a id="Sparse-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Matrices" title="Permalink"></a></h1><p>While Julia provides a data structure for sparse matrix computations, the employed design decisions make it difficult to use this implementation for computations over finite fields. This is mainly due to the fact that in the Julia implementation, it is assumed that one can determine the zero and one elements from the data type alone. However, a finite field data type generally also depends on additional parameters, such as the characteristic of the field.</p><p>Since the algorithms underlying <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> only require basic row and column operations, a specialized sparse matrix implementation is provided in the package. It is briefly described in the following.</p><h2 id="Sparse-Matrix-Format"><a class="docs-heading-anchor" href="#Sparse-Matrix-Format">Sparse Matrix Format</a><a id="Sparse-Matrix-Format-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Matrix-Format" title="Permalink"></a></h2><p>Sparse matrices in this package have to be of the composite data type <a href="../../apicore/sparse/#ConleyDynamics.SparseMatrix"><code>SparseMatrix</code></a>, which is structured as follows:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.SparseMatrix-man-sparse" href="#ConleyDynamics.SparseMatrix-man-sparse"><code>ConleyDynamics.SparseMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SparseMatrix{T}</code></pre><p>Composite data type for a sparse matrix with entries of type <code>T</code>.</p><p>The struct has the following fields:</p><ul><li><code>const nrow::Int</code>: Number of rows</li><li><code>const ncol::Int</code>: Number of columns</li><li><code>const char::Int</code>: Characteristic of type <code>T</code></li><li><code>const zero::T</code>: Number 0 of type <code>T</code></li><li><code>const one::T</code>:  Number 1 of type <code>T</code></li><li><code>entries::Vector{Vector{T}}</code>: Matrix entries corresponding to <code>columns</code></li><li><code>columns::Vector{Vector{Int}}</code>: <code>column[k]</code> points to nonzero entries in column k</li><li><code>rows::Vector{Vector{Int}}</code>: <code>rows[k]</code> points to nonzero entries in the k-th row</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/aba6605f51b99f057b0abd610827595cd1d6bc82/src/sparse/sparse_type.jl#L3-L17">source</a></section></article><p>In this struct, the type <code>T</code> has to be either <code>Int</code> or <code>Rational{Int}</code>, depending on whether the sparse matrix is interpreted as a matrix with entries in the finite field <span>$GF(p)$</span> for some prime <span>$p$</span>, or over the field of rationals, respectively. The data type has the following fields:</p><ul><li><code>nrow::Int</code> designates the number of rows.</li><li><code>ncol::Int</code> gives the number of columns.</li><li><code>char::Int</code> specifies the characteristic of the underlying field <span>$F$</span>. If <code>char=0</code>, then the field is the rationals <span>$\mathbb{Q}$</span>, and one has to have <code>T = Rational{Int}</code>. If, on the other hand, the finite field <span>$F = GF(p)$</span> is used, then <code>char=p</code> has to be a prime number. In this case, the data type of the matrix entries has to be <code>T = Int</code>.</li><li><code>zero::T</code> provides 0 in the data type <code>T</code>.</li><li><code>one::T</code> provides 1 in the data type <code>T</code>.</li><li><code>columns::Vector{Vector{Int}}</code> is a vector of integer vectors, which contains the row indices of nonzero matrix entries in each column. More precisely, <code>columns[k]</code> contains an increasing list of row indices, which give the locations of all nonzero entries in column <code>k</code>. Note that the list for each colum has to be strictly increasing.</li><li><code>rows::Vector{Vector{Int}}</code> is a vector of integer vectors, which contains the column indices of nonzero matrix entries in each row. It is the precise dual to the previous field. This time, <code>rows[k]</code> contains an increasing list of column indices, which correspond to the nonzero entries of the matrix in the <code>k</code>-th row.</li><li><code>entries::Vector{Vector{T}}</code> is a vector of vectors which contains  the actual matrix entries. It is organized in exactly the same way as the field <code>columns</code>. In other words, for every <code>k = 1,..,ncol</code> the matrix entry in column <code>k</code> and row <code>columns[k][j]</code> is given by <code>entries[k][j]</code>, where <code>j</code> indexes the nonzero column entries from top to bottom.</li></ul><p>This data structure is clearly redundant, in the sense that the field <code>rows</code> is not needed to uniquely determine the matrix. However, the type <a href="../../apicore/sparse/#ConleyDynamics.SparseMatrix"><code>SparseMatrix</code></a> is fundamental for almost every aspect of <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a>, as it is used to encode the incidence coefficient map <span>$\kappa$</span>, and therefore also the matrix representation of the boundary operator <span>$\partial$</span>. And for many operations on or queries of Lefschetz complexes, one needs fast access to both the cells in the boundary and the coboundary of a given cells. While the boundary can easily be accessed via the field <code>columns</code>, the fast coboundary access is aided by the field <code>rows</code>.</p><p>We would like to point out that in view of the different underlying fields, sparse matrices should only be manipulated using the specific commands provided by the package. These are described in detail below. If there is a need for additional functionality beyond these first methods, it can be added at a later point in time.</p><h2 id="Creating-Sparse-Matrices"><a class="docs-heading-anchor" href="#Creating-Sparse-Matrices">Creating Sparse Matrices</a><a id="Creating-Sparse-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Sparse-Matrices" title="Permalink"></a></h2><p>The package provides a number of methods for creating sparse  matrices with the data type <a href="../../apicore/sparse/#ConleyDynamics.SparseMatrix"><code>SparseMatrix</code></a>. These are geared towards their usage within <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> and are therefore by no means exhaustive:</p><ul><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_from_full"><code>sparse_from_full</code></a> is usually invoked in the form <code>A = sparse_from_full(AF, p=PP)</code>. The first input argument <code>AF</code> has to be a regular Julia integer matrix. This matrix is then converted to sparse format and returned as <code>A</code>. If the optional parameter <code>p</code> is omitted, the resulting sparse matrix is over the rational numbers <span>$\mathbb{Q}$</span>, otherwise it is over the finite field with characteristic <code>PP</code>.</li><li><a href="../../apicore/sparse/#ConleyDynamics.full_from_sparse"><code>full_from_sparse</code></a> converts a given sparse matrix into a standard full matrix in Julia. The data type of the entries is either <code>Rational{Int}</code> or <code>Int</code>, depending on whether the sparse input matrix is considered over the rationals <span>$\mathbb{Q}$</span> or over a finite field, respectively. When invoking this command,  be mindful of the size of the sparse matrix!</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_from_lists"><code>sparse_from_lists</code></a> creates a sparse matrix solely based on its nonzero entries and their locations. It expects the following required input arguments, in the order they are listed:<ul><li><code>nr::Int</code>: Number of rows</li><li><code>nc::Int</code>: Number of columns</li><li><code>tchar</code>: Field characteristic, which has to be 0 if <span>$F = \mathbb{Q}$</span> and a positive prime otherwise</li><li><code>tzero::T</code>: Number 0 of type <code>T</code></li><li><code>tone::T</code>:  Number 1 of type <code>T</code></li><li><code>r::Vector{Int}</code>: Vector of row indices</li><li><code>c::Vector{Int}</code>: Vector of column indices</li><li><code>v::Vector{T}</code>: Vector of matrix entries</li></ul>The function assumes that the vectors <code>r</code>, <code>c</code>, and <code>v</code> have the same length and that the matrix has entry <code>v[k]</code> at the location <code>(r[k],c[k])</code>. Zero entries will be ignored, and multiple entries for the same matrix position raise an error. Furthermore, if <code>tchar&gt;0</code>, then the entries in <code>v</code> are all replaced by their values modulo <code>tchar</code>. As mentioned before, if <code>tchar=0</code> then the entry type has to be <code>T = Rational{Int}</code>, otherwise we have <code>T = Int</code>.</li><li><a href="../../apicore/sparse/#ConleyDynamics.lists_from_sparse"><code>lists_from_sparse</code></a> takes a sparse matrix and disassembles it into the separate ingredients specified in the discussion of the previous function. In this sense, it is precisely the inverse method of <a href="../../apicore/sparse/#ConleyDynamics.sparse_from_lists"><code>sparse_from_lists</code></a>.</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_identity"><code>sparse_identity</code></a> creates a sparse identity matrix. It is invoked as <code>A = sparse_identity(n, p=PP)</code>, and returns a sparse identity matrix <code>A</code> with <code>n</code> rows and <code>n</code> columns. If the optional characteristic parameter specified and positive, then the matrix is considered over the finite field with characteristic <code>PP</code><code>, otherwise it is over the rationals</code><code>\mathbb{Q}</code>`.</li></ul><p>Of these methods, the function <a href="../../apicore/sparse/#ConleyDynamics.sparse_from_lists"><code>sparse_from_lists</code></a> provides the easiest and quickest way to create a sparse matrix.</p><h2 id="Sparse-Matrix-Access"><a class="docs-heading-anchor" href="#Sparse-Matrix-Access">Sparse Matrix Access</a><a id="Sparse-Matrix-Access-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Matrix-Access" title="Permalink"></a></h2><p>Access to the entries of sparse matrices is provided via the following commands:</p><ul><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_get_entry"><code>sparse_get_entry</code></a> extracts the matrix entry <code>val</code> of the matrix <code>A</code> located in row <code>ri</code> and column <code>ci</code>, if it is invoked using the command <code>val = sparse_get_entry(A,ri,ci)</code>.</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_set_entry!"><code>sparse_set_entry!</code></a> sets the matrix entry of the matrix <code>A</code> located in row <code>ri</code> and column <code>ci</code> to the value &#39;val&#39;, if it is invoked using the command <code>sparse_set_entry!(A,ri,ci,val)</code>. Internally, this commands makes sure that the above-defined format of the fields of a sparse matrix is preserved. Note that the data type of <code>val</code> has to match the type of <code>A.zero</code>. Moreover, if the matrix is considered over a finite field the value <code>val</code> has to be given as an integer between <code>0</code> and <code>A.char-1</code>.</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_get_column"><code>sparse_get_column</code></a> is invoked as <code>Acol = sparse_get_column(A,ci)</code>, and it returns the full <code>ci</code>-th column of the matrix <code>A</code> as a <code>Vector{T}</code> of length <code>A.nrow</code>.</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_get_nz_column"><code>sparse_get_nz_column</code></a> returns the row indices for the nonzero entries in the <code>ci</code>-th column of the sparse matrix <code>A</code>, if invoked as <code>rivec = sparse_get_nz_column(A,ci)</code>.</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_minor"><code>sparse_minor</code></a> creates a minor from a given sparse matrix <code>A</code>. For this, one needs to specify the row and column indices of the minor in the integer vectors <code>rvec</code> and <code>cvec</code>, respectively, and then invoke the function using the command <code>AM = sparse_minor(A,rvec,cvec)</code>. Note that the entries in <code>rvec</code> and <code>cvec</code> do not have to be in increasing order, but they are not allowed to contain repeated indices.</li></ul><p>One can also read and set sparse matrix values using the overloaded methods <code>y = A[i,j]</code> and <code>A[i,j] = val</code>. In the latter case, it is up to the user to make sure that <code>val</code> respects the underlying sparse matrix field.</p><h2 id="Elementary-Matrix-Operations"><a class="docs-heading-anchor" href="#Elementary-Matrix-Operations">Elementary Matrix Operations</a><a id="Elementary-Matrix-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Elementary-Matrix-Operations" title="Permalink"></a></h2><p>The following commands perform the basic sparse matrix operations that are needed for the functionality of the package:</p><ul><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_add_column!"><code>sparse_add_column!</code></a> is invoked using the form <code>sparse_add_column!(A,ci1,ci2,cn,cd)</code>, and it replaces the <code>ci1</code>-th column <code>column[ci1]</code> of <code>A</code> by <code>column[ci1] + (cn/cd) * column[ci2]</code>. This operation automatically performs the computations over the field <span>$F$</span> underlying the sparse matrix <code>A</code>. In other words, if this field is finite, then it determines the inverse of the argument <code>cd</code> as part of the computation.</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_add_row!"><code>sparse_add_row!</code></a> is invoked using the form <code>sparse_add_row!(A,ri1,ri2,cn,cd)</code>, and it replaces the <code>ri1</code>-th row <code>row[ri1]</code> of <code>A</code> by <code>row[ri1] + (cn/cd) * row[ri2]</code>. As before, this operation automatically performs the computations over the field <span>$F$</span> underlying the sparse matrix <code>A</code>.</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_permute"><code>sparse_permute</code></a> creates a new sparse matrix by permuting the row and column indices. It is invoked using the command <code>AP = sparse_permute(A,pr,pc)</code>, and the integer vectors <code>pr</code> and <code>pc</code> have to describe the row and column permutations, respectively.</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_remove!"><code>sparse_remove!</code></a> is invoked as <code>sparse_remove!(A,ri,ci)</code> and removes the sparse matrix entry in the <code>ri</code>-th row and <code>ci</code>-th colum, i.e., it effectively sets the entry equal to zero.</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_multiply"><code>sparse_multiply</code></a> computes the matrix product of  two sparse matrices. Exceptions are raised if the matrix product is not defined, or if the involved sparse matrices are defined over different fields. One can also use the operator form <code>A*B</code> to compute the product of sparse matrices.</li></ul><p>As mentioned earlier, additional operations can easily be implemented if they become necessary.</p><h2 id="Sparse-Matrix-Information"><a class="docs-heading-anchor" href="#Sparse-Matrix-Information">Sparse Matrix Information</a><a id="Sparse-Matrix-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Matrix-Information" title="Permalink"></a></h2><p>Finally, <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> provides the following functions  for quickly extracting certain information from sparse matrices:</p><ul><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_size"><code>sparse_size</code></a> is invoked as <code>size = sparse_size(A,dim)</code>, and it returns the number of rows if <code>dim=1</code>, or the number of columns for <code>dim=2</code>.</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_low"><code>sparse_low</code></a> returns the largest row index <code>ri</code> of a nonzero entry in the <code>ci</code>-th column of the matrix <code>A</code>, if used in the form <code>ri = sparse_low(A,ci)</code>. In other words, it returns the row index of the lowest nonzero matrix entry in the column.</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_is_sut"><code>sparse_is_sut</code></a> checks whether a given sparse matrix is strictly upper triangular, and returns either <code>true</code> or <code>false</code>.</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_fullness"><code>sparse_fullness</code></a> returns the fullness of a sparse matrix as a floating point number. Here fullness refers to the ratio of the number of nonzero matrix elements and the total number of matrix entries.</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_sparsity"><code>sparse_sparsity</code></a> computes the sparseness of a sparse matrix, which is defined as <span>$1$</span> minus its fullness, i.e., it is the ratio of the number of zero matrix elements and the total number of matrix entries.</li><li><a href="../../apicore/sparse/#ConleyDynamics.sparse_show"><code>sparse_show</code></a> can be used to display a sparse matrix in traditional matrix form at the Julia REPL prompt.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 26 November 2024 20:43">Tuesday 26 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
