<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · ConleyDynamics.jl</title><meta name="title" content="Tutorial · ConleyDynamics.jl"/><meta property="og:title" content="Tutorial · ConleyDynamics.jl"/><meta property="twitter:title" content="Tutorial · ConleyDynamics.jl"/><meta name="description" content="Documentation for ConleyDynamics.jl."/><meta property="og:description" content="Documentation for ConleyDynamics.jl."/><meta property="twitter:description" content="Documentation for ConleyDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ConleyDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ConleyDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Creating-Lefschetz-Complexes"><span>Creating Lefschetz Complexes</span></a></li><li><a class="tocitem" href="#Computing-Homology-and-Persistence"><span>Computing Homology and Persistence</span></a></li><li><a class="tocitem" href="#Forman-Vector-Fields-and-Connecting-Orbits"><span>Forman Vector Fields and Connecting Orbits</span></a></li><li><a class="tocitem" href="#Finding-Connection-Matrices"><span>Finding Connection Matrices</span></a></li><li><a class="tocitem" href="#Working-with-Sparse-Matrices"><span>Working with Sparse Matrices</span></a></li></ul></li><li><a class="tocitem" href="../lefschetz/">Lefschetz Complexes</a></li><li><a class="tocitem" href="../connections/">Connection Matrices</a></li><li><a class="tocitem" href="../homology/">Homology</a></li><li><a class="tocitem" href="../sparse/">Sparse Matrices</a></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul></li><li><span class="tocitem">Core API</span><ul><li><a class="tocitem" href="../../apicore/datastruct/">Composite Data Structures</a></li><li><a class="tocitem" href="../../apicore/utils/">Utility Functions</a></li><li><a class="tocitem" href="../../apicore/cmcore/">Connection Matrix Functions</a></li><li><a class="tocitem" href="../../apicore/homology/">Homology Functions</a></li><li><a class="tocitem" href="../../apicore/sparse/">Sparse Matrix Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/main/docs/src/man/guide.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>This tutorial explains the basic usage of the main components of ConleyDynamics. It is not meant to be exhaustive, since more  details will be provided in the more indiviualized sections. Also, precise mathematical definitions will be delayed until then.</p><h2 id="Creating-Lefschetz-Complexes"><a class="docs-heading-anchor" href="#Creating-Lefschetz-Complexes">Creating Lefschetz Complexes</a><a id="Creating-Lefschetz-Complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Lefschetz-Complexes" title="Permalink"></a></h2><p>The fundamental mathematical object for ConleyDynamics is a Lefschetz complex. For now we note that both simplicial complexes and cubical complexes are special cases, and ConleyDynamics provides convenient interfaces for generating them.</p><p>We begin by considering the case of a simplicial complex. Recall that an <em>abstract simplicial complex</em> <span>$K$</span> is just a collection of finite sets, called <em>simplices</em>, which is closed under taking subsets. In other words, every subset of a simplex is again a simplex. Each simplex has an associated <em>dimension</em>, which is one less than the  number of its elements. One usually calls simplices of dimension 0 <em>vertices</em>, <em>edges</em> have dimension 1, and simplices of dimension 2 are <em>triangles</em>. It follows easily from these definitions that every simplex is the union of its vertices.</p><p>In ConleyDynamics it is easy to generate a simplicial complex. This requires two objects:</p><ul><li>The vertices are described by a vector <code>labels</code> of string labels for the vertices of the simplicial complex. Thus, the length of the vector equals the number of vertices, and the k-th entry is the label for the k-th vertex.</li><li>In addition, a second vector <code>simplices</code> has to describe enough simplices so that the simplicial complex is determined. This object is a vector of vectors, and the vector <code>simplices[k]</code> describes the index values of all the vertices in the k-th simplex. These indices are precisely the corresponding locations of the vertices in <code>labels</code>.</li></ul><div class="admonition is-success"><header class="admonition-header">Simplices via labels</header><div class="admonition-body"><p>It is also possible to specify the list of simplices using a <code>Vector{Vector{String}}</code>, i.e., as a vector of string vectors. In this case, the entry <code>simplices[k]</code> is a list of the labels of the vertices.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Watch the label length</header><div class="admonition-body"><p>It is expected that the labels in <code>labels</code> all have the same number of characters. This is due to the fact that when creating the simplicial complex, ConleyDynamics automatically creates  labels for each of the simplices in <span>$K$</span>, by concatenating the vertex labels. Not using a fixed label size could lead to  ambiguities, and will therefore raise an error message.</p></div></div><p><img src="../img/tutorialsimplex.png" alt="A first simplicial complex"/></p><p>The following first example creates a simple simplicial complex. The complex is shown in the above figure, and it has six vertices which we label by the first six letters.</p><pre><code class="language-julia hljs">labels = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;]
simplices = [[&quot;A&quot;,&quot;B&quot;],[&quot;A&quot;,&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;B&quot;,&quot;D&quot;],[&quot;D&quot;,&quot;E&quot;,&quot;F&quot;]]
sc = create_simplicial_complex(labels,simplices)
fieldnames(typeof(sc))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:ncells, :dim, :boundary, :labels, :indices, :dimensions)</code></pre><p>Based on the simplex specifications, the generated simplicial complex <span>$K$</span> consists of three edges connecting each of the vertices <code>A</code>, <code>B</code>, and <code>C</code>, a two-dimensional triangle <code>DEF</code>, as well as the edge <code>BD</code> which connects the triangle boundary and the filled triangle. The created struct <code>sc</code> is of type <code>LefschetzComplex</code>, with fieldnames as indicated in the above output. The number of cells in the complex can be seen as follows:</p><pre><code class="language-julia hljs">println(sc.ncells)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">14</code></pre><p>Note that the final simplicial complex has a total of seven edges, since also the edges of <code>DEF</code> are part of the simplicial complex. They are automatically generated by <code>create_simplicial_complex</code>. The dimension of <code>K</code> is the largest simplex dimensions, and can be seen via</p><pre><code class="language-julia hljs">println(sc.dim)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><p>The <code>sc</code> struct also contains a vector of labels, which in this case takes the form</p><pre><code class="language-julia hljs">println(sc.labels)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;, &quot;BD&quot;, &quot;DE&quot;, &quot;DF&quot;, &quot;EF&quot;, &quot;DEF&quot;]</code></pre><p>Finally, the Lefschetz complex data structure for our simplicial complex <span>$K$</span> also includes the dimensions for the corresponding cells in the integer vector <code>sc.dimensions</code>, a dictionary <code>sc.indices</code> which associates each simplex label with its integer index, and the boundary map <code>sc.boundary</code> which will be described in more detail in <a href="../lefschetz/#Lefschetz-Complexes">Lefschetz Complexes</a>.</p><h2 id="Computing-Homology-and-Persistence"><a class="docs-heading-anchor" href="#Computing-Homology-and-Persistence">Computing Homology and Persistence</a><a id="Computing-Homology-and-Persistence-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Homology-and-Persistence" title="Permalink"></a></h2><p>Any simplicial complex, and in fact any Lefschetz complex, has an associated <em>homology</em>. Informally, the latter describes the connectivity structure of the object described by the simplicial complex. More  precisely, the homology consists in our case of a sequence of integers, called the <em>Betti numbers</em>, which are indexed by dimension. There are Betti numbers <span>$\beta_k(K)$</span> for every <span>$k = 0,\ldots,\dim K$</span>. The 0-dimensional Betti number <span>$\beta_0(K)$</span> gives the number of connected components of <span>$K$</span>, while <span>$\beta_1(K)$</span> counts the number of independent loops that can be found in <span>$K$</span>. Finally, <span>$\beta_2(K)$</span> equals the number of cavities. In our case, we have</p><pre><code class="language-julia hljs">homology(sc)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 1
 1
 0</code></pre><p>This means that the simplicial complex <span>$K$</span> has one component, as well as one loop, and no cavities. The function <code>homology</code> returns  a vector of integers, whose k-th entry is <span>$\beta_{k-1}(K)$</span>.</p><p>ConleyDynamics also allows for the computation of <em>relative  homology</em>. In the case of relative homology, together with the simplicial complex <span>$K$</span> one has to specify a closed subcomplex <span>$K_0$</span>. Intuitively, the relative homology <span>$H_*(K,K_0)$</span> is the homology of a new space, which is obtained from <span>$K$</span> by identitying <span>$K_0$</span> to a single point, and then decreasing the Betti number in dimension 0 by 1. Consider for example the  following command.</p><pre><code class="language-julia hljs">relative_homology(sc, [1,6])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 0
 2
 0</code></pre><p>In this case, the subcomplex <span>$K_0$</span> consists of the two vertices <code>A</code> and <code>F</code>, and so these are glued together. This leads to zero Betti numbers in dimension 0 and 2 (remember that in dimension 0 one subtracts 1), and a one-dimensional Betti number of 2. The latter is increased by one since we obtain a second loop by moving from <code>A</code> to <code>F = A</code> along the bottom three edges of <span>$K$</span>. Another example is the following:</p><pre><code class="language-julia hljs">relative_homology(sc, [&quot;DE&quot;,&quot;DF&quot;,&quot;EF&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 0
 1
 1</code></pre><p>In this case, the subcomplex <span>$K_0$</span> consists of the edges <code>DE</code>, <code>DF</code>, and <code>EF</code> – together will the three vertices <code>D</code>, <code>E</code>, and <code>F</code> which are automatically added by <code>relative_homology</code>. Identifying them all to one point creates a hollow two-dimensional sphere, and the relative Betti numbers reflect that fact.</p><pre><code class="language-julia hljs">filtration = [1,1,1,2,2,2,1,1,1,3,2,2,2,4]
phsingles, phpairs = persistent_homology(sc, filtration)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([[1], [1], Int64[]], [[(2, 3)], [(2, 4)], Tuple{Int64, Int64}[]])</code></pre><h2 id="Forman-Vector-Fields-and-Connecting-Orbits"><a class="docs-heading-anchor" href="#Forman-Vector-Fields-and-Connecting-Orbits">Forman Vector Fields and Connecting Orbits</a><a id="Forman-Vector-Fields-and-Connecting-Orbits-1"></a><a class="docs-heading-anchor-permalink" href="#Forman-Vector-Fields-and-Connecting-Orbits" title="Permalink"></a></h2><p><img src="../img/tutorialforman.png" alt="A first Forman vector field"/></p><h2 id="Finding-Connection-Matrices"><a class="docs-heading-anchor" href="#Finding-Connection-Matrices">Finding Connection Matrices</a><a id="Finding-Connection-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-Connection-Matrices" title="Permalink"></a></h2><p><img src="../img/multivectorex.png" alt="The logo multivector field"/></p><p>We begin by discussion an elementary example from Mrozek &amp; Wanner<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><h2 id="Working-with-Sparse-Matrices"><a class="docs-heading-anchor" href="#Working-with-Sparse-Matrices">Working with Sparse Matrices</a><a id="Working-with-Sparse-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Sparse-Matrices" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Marian Mrozek, Thomas Wanner: <a href="https://arxiv.org/abs/2103.04269">Connection matrices in combinatorial topological dynamics</a>, <em>Preprint</em>, submitted for publication, 115 pp, 2023.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Overview</a><a class="docs-footer-nextpage" href="../lefschetz/">Lefschetz Complexes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 5 February 2024 22:47">Monday 5 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
