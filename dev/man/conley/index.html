<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conley Theory · ConleyDynamics.jl</title><meta name="title" content="Conley Theory · ConleyDynamics.jl"/><meta property="og:title" content="Conley Theory · ConleyDynamics.jl"/><meta property="twitter:title" content="Conley Theory · ConleyDynamics.jl"/><meta name="description" content="Documentation for ConleyDynamics.jl."/><meta property="og:description" content="Documentation for ConleyDynamics.jl."/><meta property="twitter:description" content="Documentation for ConleyDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ConleyDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ConleyDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../lefschetz/">Lefschetz Complexes</a></li><li><a class="tocitem" href="../homology/">Homology</a></li><li class="is-active"><a class="tocitem" href>Conley Theory</a><ul class="internal"><li><a class="tocitem" href="#Morse-Decomposition-Intervals"><span>Morse Decomposition Intervals</span></a></li><li><a class="tocitem" href="#Cubical-Analysis-of-a-Planar-System"><span>Cubical Analysis of a Planar System</span></a></li><li><a class="tocitem" href="#Cubical-Analysis-of-a-Spatial-System"><span>Cubical Analysis of a Spatial System</span></a></li><li><a class="tocitem" href="#refconley"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../sparse/">Sparse Matrices</a></li><li><a class="tocitem" href="../references/">References</a></li></ul></li><li><span class="tocitem">Core API</span><ul><li><a class="tocitem" href="../../apicore/datastruct/">Composite Data Structures</a></li><li><a class="tocitem" href="../../apicore/lefschetz/">Lefschetz Complex Functions</a></li><li><a class="tocitem" href="../../apicore/homology/">Homology Functions</a></li><li><a class="tocitem" href="../../apicore/conley/">Conley Theory Functions</a></li><li><a class="tocitem" href="../../apicore/examples/">Example Functions</a></li><li><a class="tocitem" href="../../apicore/plots/">Plotting Functions</a></li><li><a class="tocitem" href="../../apicore/sparse/">Sparse Matrix Functions</a></li><li><a class="tocitem" href="../../apicore/apiindex/">Complete API Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Conley Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Conley Theory</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/main/docs/src/man/conley.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Conley-Theory"><a class="docs-heading-anchor" href="#Conley-Theory">Conley Theory</a><a id="Conley-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Conley-Theory" title="Permalink"></a></h1><p>Here we need a more detailed description of Conley theory, and in particular connection matrices.  In particular, this should discuss the various field types that can be used, as well as all the entries in the <a href="../../apicore/datastruct/#ConleyDynamics.ConleyMorseCM"><code>ConleyMorseCM</code></a> data structure.</p><p>[<a href="../references/#kaczynski:etal:16a">KMW16</a>] [<a href="../references/#mrozek:wanner:21a">MW21</a>] [<a href="../references/#dey:etal:24a">DLMS24</a>] [<a href="../references/#stephens:wanner:14a">SW14b</a>] [<a href="../references/#isoblockval:website">SW14a</a>]</p><h2 id="Morse-Decomposition-Intervals"><a class="docs-heading-anchor" href="#Morse-Decomposition-Intervals">Morse Decomposition Intervals</a><a id="Morse-Decomposition-Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Morse-Decomposition-Intervals" title="Permalink"></a></h2><p>We briefly return to one of the examples in the tutorial. More precisely, we consider the planar ordinary differential equation given by</p><p class="math-container">\[   \begin{array}{rcl}
     \dot{x}_1 &amp; = &amp; x_1 \left( 1 - x_1^2 - 3 x_2^2 \right) \\[1ex]
     \dot{x}_2 &amp; = &amp; x_2 \left( 1 - 3 x_1^2 - x_2^2 \right)
   \end{array}\]</p><p>The dynamics of this system is characterized by the existence of a global attractor in the shape of a closed disk. Inside the attractor, there are nine different Morse sets:</p><ul><li>The origin is an equilibrium of index 2, i.e., it is an unstable stationary state with a two-dimensional unstable manifold.</li><li>The four points <span>$(\pm 1/2, \pm 1/2)$</span> are unstable equilibria of index 1, i.e., with a one-dimensional unstable manifold.</li><li>Finally, the four points <span>$(\pm 1, 0)$</span> and <span>$(0, \pm 1)$</span> are asymptotically stable stationary states.</li></ul><p>We saw in the tutorial that the Morse decomposition of this system can easily be found using <code>ConleyDynamics.jl</code>, as well as the associated connection matrix. Yet, in certain situations one might only be interested in part of the dynamics on the attractor. Moreover, while the Morse sets describe the recurrent part of the dynamics, they do not provide information on the geometry of the connecting sets between the Morse sets. In the following, we illustrate how this can be analyzed further.</p><p>The right-hand side of the above vector field can be implemented using the Julia function</p><pre><code class="language-julia hljs">function planarvf(x::Vector{Float64})
    #
    # Sample planar vector field with nontrivial Morse decomposition
    #
    x1, x2 = x
    y1 = x1 * (1.0 - x1*x1 - 3.0*x2*x2)
    y2 = x2 * (1.0 - 3.0*x1*x1 - x2*x2)
    return [y1, y2]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">planarvf (generic function with 1 method)</code></pre><p>To analyze the resulting global dynamical behavior, we first create a simplicial mesh covering the square <span>$[-6/5, 6/5]^2$</span> using the commands</p><pre><code class="language-julia hljs">lc, coords = create_simplicial_delaunay(300, 300, 5, 50);
coordsN = convert_planar_coordinates(coords,[-1.2,-1.2], [1.2,1.2]);
lc.ncells</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">14395</code></pre><p>The integer in the output gives the number of cells in the created Lefschetz complex <span>$X$</span>. Note that we are using a Delaunay triangulation over an initial box of size <span>$300 \times 300$</span>, where the target triangle size is about 5. This box is then rescaled to cover the above square. We can then create a  multivector field on the simplicial complex <code>lc</code> and find its Morse decomposition using the commands</p><pre><code class="language-julia hljs">mvf = create_planar_mvf(lc, coordsN, planarvf);
morsedecomp = morse_sets(lc, mvf);
length(morsedecomp)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9</code></pre><p>As expected, <code>ConleyDynamics.jl</code> finds exactly nine Morse sets. Their  Conley indices can be computed and stored in a <code>Vector{Vector{Int}}</code> using the command</p><pre><code class="language-julia hljs">conleyindices = [conley_index(lc, mset) for mset in morsedecomp]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Vector{Int64}}:
 [1, 0, 0]
 [1, 0, 0]
 [0, 1, 0]
 [1, 0, 0]
 [0, 1, 0]
 [1, 0, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 0, 1]</code></pre><p>These Conley indices correspond to the dynamical behavior near the equilibrium solutions described above.</p><p>Suppose now that rather than finding the connection matrix for the complete Morse decomposition, we would only like to consider a  part of it. This can be done as long as we restrict our attention to an <em>interval in the Morse decomposition</em>. Such an interval <span>$\mathcal{I}$</span> can be created from a selection <span>$\mathcal{S}$</span> of the Morse sets in the following way:</p><ul><li>In addition to the Morse sets in <span>$\mathcal{S}$</span>, the interval <span>$\mathcal{I}$</span> contains all Morse sets that lie between two Morse sets in <span>$\mathcal{S}$</span> with respect to the poset order underlying the Morse decomposition. Recall that this poset order can be computed via <a href="../../apicore/conley/#ConleyDynamics.morse_sets"><code>morse_sets</code></a> by activating the extra return object <code>hasse</code>, which describes the Hasse diagram of the poset.</li></ul><p>With every interval <span>$\mathcal{I}$</span> of the Morse decomposition one can assign a smallest isolated invariant set <span>$X_{\mathcal{I}} \subset X$</span> which describes the complete dynamics within and between the Morse sets in <span>$\mathcal{I}$</span>. In fact, in can be characterized as follows:</p><ul><li>The set <span>$X_{\mathcal{I}}$</span> consists of all cells in the  underlying Lefschetz complex <span>$X$</span> through which one can find a solution which originates in one Morse set of <span>$\mathcal{I}$</span> and ends in another Morse set of <span>$\mathcal{I}$</span>, where the two involved Morse sets can be the same. In other words, one needs to combine the interval Morse sets with all <em>connecting orbits</em> between them.</li></ul><p>The two above steps can be performed in <code>ConleyDynamics.jl</code> using the function <a href="../../apicore/conley/#ConleyDynamics.morse_interval"><code>morse_interval</code></a>.</p><p>In our example, we consider two intervals. The first interval consists of the five Morse sets corresponding to all unstable equilibrium solutions, while the second one considers the four index 1 and the four stable stationary states. The associated isolated invariant sets for these two intervals can be computed as follows:</p><pre><code class="language-julia hljs">subset1 = findall(x -&gt; x[2]+x[3]&gt;0, conleyindices);
subset2 = findall(x -&gt; x[1]+x[2]&gt;0, conleyindices);
lcsub1 = morse_interval(lc, mvf, morsedecomp[subset1]);
lcsub2 = morse_interval(lc, mvf, morsedecomp[subset2]);
[length(subset1), length(subset2), length(lcsub1), length(lcsub2)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Int64}:
    5
    8
 1201
 2256</code></pre><p>The output shows that we have in fact extracted five and eight Morse sets, respectively. It also shows that the Lefschetz complexes corresponding to these two isolated invariant sets are much smaller than <span>$X$</span>.</p><p>So far, we have just determined the collections of cells that  correspond to the two isolated invariant sets for these intervals. We can now restrict the combinatorial dynamics to these subsets.  Note that since they are both isolated invariant sets, they are locally closed in <span>$X$</span>, and therefore the restrictions provide us with two new Lefschetz complexes <code>lcr1</code> and <code>lcr2</code>, along with induced multivector fields <code>mvfr1</code> and <code>mvfr2</code>, respectively. In <code>ConleyDynamics.jl</code>, this is achieved using the commands</p><pre><code class="language-julia hljs">lcr1, mvfr1 = restrict_dynamics(lc, mvf, lcsub1);
lcr2, mvfr2 = restrict_dynamics(lc, mvf, lcsub2);
[lcr1.ncells, lcr2.ncells]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Int64}:
 1201
 2256</code></pre><p>It is now easy to find the connection matrices for these two intervals. The first connection matrix is given by</p><pre><code class="language-julia hljs">cmr1 = connection_matrix(lcr1, mvfr1);
cmr1.conley</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Vector{Int64}}:
 [0, 1, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 0, 1]</code></pre><pre><code class="language-julia hljs">full_from_sparse(cmr1.matrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5×5 Matrix{Int64}:
 0  0  0  0  1
 0  0  0  0  1
 0  0  0  0  1
 0  0  0  0  1
 0  0  0  0  0</code></pre><p>It clearly shows that the unstable index 2 Morse set has connecting orbits to every one of the four index 1  equilibria. Similarly, the second connection matrix can be determined as</p><pre><code class="language-julia hljs">cmr2 = connection_matrix(lcr2, mvfr2);
cmr2.conley</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{Vector{Int64}}:
 [1, 0, 0]
 [1, 0, 0]
 [1, 0, 0]
 [1, 0, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 1, 0]</code></pre><pre><code class="language-julia hljs">full_from_sparse(cmr2.matrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8×8 Matrix{Int64}:
 0  0  0  0  0  1  1  0
 0  0  0  0  0  0  1  1
 0  0  0  0  1  1  0  0
 0  0  0  0  1  0  0  1
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0</code></pre><p>In this case, every index 1 equilibrium is connected  two its two neighboring stable stationary states via heteroclinics that are detected by the connection matrix.</p><p>The Lefschetz complexes associated with the two Morse decomposition intervals can also be visualized in <code>ConleyDynamics.jl</code>. For this, recall that the function <a href="../../apicore/plots/#ConleyDynamics.plot_planar_simplicial_morse"><code>plot_planar_simplicial_morse</code></a> can plot an underlying simplicial complex together with any collection of cell  subsets. For our purposes, we use the following commands:</p><pre><code class="language-julia hljs">show1 = [[lcr1.labels]; cmr1.morse];
show2 = [[lcr2.labels]; cmr2.morse];
fname1 = &quot;/Users/wanner/Desktop/invariantinterval2d1.png&quot;
fname2 = &quot;/Users/wanner/Desktop/invariantinterval2d2.png&quot;
plot_planar_simplicial_morse(lc, coordsN, fname1, show1, vfac=1.1, hfac=2.0)
plot_planar_simplicial_morse(lc, coordsN, fname2, show2, vfac=1.1, hfac=2.0)</code></pre><p>The variable <code>show1</code> collects not only the Morse sets that are part of the first connection matrix <code>cmr1</code>, but also the support of the Lefschetz complex <code>lcr1</code>. This support is accessed via <code>[lcr1.labels]</code>, and we add it as a first vector of cells in <code>show1</code>. Similarly, we determine the support of the second  isolated invariant set, together with the Morse sets of <code>cmr2</code>. The remaining four commands create two images.</p><p><img src="../img/invariantinterval2d1.png" alt="Interval support for the first interval"/></p><p>The first image shows the five Morse sets surrounding the stationary states at the origin and at <span>$(\pm 1/2, \pm 1/2)$</span>. In addition, it highlights the support of the isolated invariant set associated with this Morse decomposition interval. One can clearly see rough outer approxomations for the four heteroclinics which start at the origin and end at the index 1 equilibria. These approximations are necessarily coarse, since we are not working with a very fine triangulation.</p><p><img src="../img/invariantinterval2d2.png" alt="Interval support for the second interval"/></p><p>Finally, the second image depicts the eight Morse sets enclosing the index 1 and the stable stationary states. It also shows the support of the Lefschetz complex <code>lcr2</code> which is associated with this Morse decomposition interval. In this case, it covers eight different heteroclinic orbits, which are in fact better approximated than the four in the previous image.</p><h2 id="Cubical-Analysis-of-a-Planar-System"><a class="docs-heading-anchor" href="#Cubical-Analysis-of-a-Planar-System">Cubical Analysis of a Planar System</a><a id="Cubical-Analysis-of-a-Planar-System-1"></a><a class="docs-heading-anchor-permalink" href="#Cubical-Analysis-of-a-Planar-System" title="Permalink"></a></h2><p>Our next example illustrates how <code>ConleyDynamics.jl</code> can be used to analyze the global dynamics of a planar ordinary differential equations. For this, consider the planar system</p><p class="math-container">\[   \begin{array}{rcl}
     \dot{x}_1 &amp; = &amp;  x_2 - x_1 \left( x_1^2 + x_2^2 - 4 \right)
       \left( x_1^2 + x_2^2 - 1 \right) \\[1ex]
     \dot{x}_2 &amp; = &amp; -x_1 - x_2 \left( x_1^2 + x_2^2 - 4 \right)
       \left( x_1^2 + x_2^2 - 1 \right)
   \end{array}\]</p><p>This system has already been considered in [<a href="../references/#mrozek:etal:22a">MSTW22</a>]. The right-hand side of this vector field can be implemented using the Julia function</p><pre><code class="language-julia hljs">function circlevf(x::Vector{Float64})
    #
    # Sample vector field with nontrivial Morse decomposition
    #
    x1, x2 = x
    c0 = x1*x1 + x2*x2
    c1 = (c0 - 4.0) * (c0 - 1.0)
    y1 =  x2 - x1 * c1
    y2 = -x1 - x2 * c1
    return [y1, y2]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">circlevf (generic function with 1 method)</code></pre><p>To analyze the global dynamics of this vector field, we first create a cubical complex covering the square <span>$[-3, 3]^2$</span> using the commands</p><pre><code class="language-julia hljs">n = 51
lc, coords = create_cubical_rectangle(n,n,p=2);
coordsN = convert_planar_coordinates(coords,[-3.0,-3.0],[3.0,3.0]);
lc.ncells</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10609</code></pre><p>As the last result shows, this gives a Lefschetz complex with 10609 cells. The multivector field can be generated using</p><pre><code class="language-julia hljs">mvf = create_planar_mvf(lc, coordsN, circlevf);
length(mvf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2449</code></pre><p>This multivector field consists of 2437 multivectors. Finally, the  connection matrix can be determined using the command</p><pre><code class="language-julia hljs">cm = connection_matrix(lc, mvf);
cm.conley</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Vector{Int64}}:
 [1, 1, 0]
 [1, 0, 0]
 [0, 1, 1]</code></pre><p>Therefore, the above planar system has three isolated invariant sets. One has the Conley index of a stable equilibrium, while the other two have that of a stable and an unstable periodic orbit. The columns of the connection matrix correspond to these invariant sets as follows</p><pre><code class="language-julia hljs">cm.poset</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Int64}:
 1
 1
 2
 3
 3</code></pre><p>The connection matrix itself is given by</p><pre><code class="language-julia hljs">full_from_sparse(cm.matrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5×5 Matrix{Int64}:
 0  0  0  1  0
 0  0  0  0  1
 0  0  0  1  0
 0  0  0  0  0
 0  0  0  0  0</code></pre><p>This implies that there are connecting orbits from the unstable  periodic orbit to both the stable equilibrium, and the stable periodic orbit. To visualize these Morse sets, we employ the  commands</p><pre><code class="language-julia hljs">fname = &quot;cubicalcircles.pdf&quot;
plot_planar_cubical_morse(lc, fname, cm.morse, pv=true)</code></pre><p><img src="../img/cubicalcircles.png" alt="Morse sets of the planar circles vector field"/></p><p>In the above example we used the original fixed cubical grid, which is just a scaled version of the grid on the integer lattice. It is also possible to work with a <em>randomized grid</em>, in which the coordinates of the vertices are randomly perturbed. This can be achieved with the following commands:</p><pre><code class="language-julia hljs">nR = 75
lcR, coordsR = create_cubical_rectangle(nR,nR,p=2,randomize=0.33);
coordsRN = convert_planar_coordinates(coordsR,[-3.0,-3.0],[3.0,3.0]);
mvfR = create_planar_mvf(lcR, coordsRN, circlevf);
cmR = connection_matrix(lcR, mvfR);
fnameR = &quot;cubicalcirclesR.pdf&quot;
plot_planar_cubical_morse(lcR, coordsRN, fnameR, cmR.morse, pv=true, vfac=1.1, hfac=2.0)</code></pre><p><img src="../img/cubicalcirclesR.png" alt="Morse sets of the planar circles vector field via randomized cubes"/></p><p>To constrast the above example with the use of a Delaunay triangulation, we reanalyze the vector field in the following way:</p><pre><code class="language-julia hljs">lc2, coords2 = create_simplicial_delaunay(400, 400, 10, 30, p=2)
coords2N = convert_planar_coordinates(coords2,[-3.0,-3.0], [3.0,3.0])
mvf2 = create_planar_mvf(lc2, coords2N, circlevf)
cm2 = connection_matrix(lc2, mvf2)

fname2 = &quot;cubicalcircles2.pdf&quot;
plot_planar_simplicial_morse(lc2, coords2N, fname2, cm2.morse, pv=true)</code></pre><p>In this case, the Morse sets can be visualized as in the figure.</p><p><img src="../img/cubicalcircles2.png" alt="Morse sets of the planar circles vector field via Delaunay"/></p><p>Notice that we can also show the individual multivectors in more detail. For the above example, we can plot all multivectors of the multivector field <code>mvf2</code> which consist of at least 10 cells using the commands</p><pre><code class="language-julia hljs">mv_indices = findall(x -&gt; (length(x)&gt;9), mvf2)
large_mv = mvf2[mv_indices]

fname3 = &quot;cubicalcircles3.pdf&quot;
plot_planar_simplicial_morse(lc2, coords2N, fname3, large_mv, pv=true)</code></pre><p><img src="../img/cubicalcircles3.png" alt="Large multivectors in the Delaunay multivector field"/></p><p>Note that in this example, there are only 20 large multivectors.</p><h2 id="Cubical-Analysis-of-a-Spatial-System"><a class="docs-heading-anchor" href="#Cubical-Analysis-of-a-Spatial-System">Cubical Analysis of a Spatial System</a><a id="Cubical-Analysis-of-a-Spatial-System-1"></a><a class="docs-heading-anchor-permalink" href="#Cubical-Analysis-of-a-Spatial-System" title="Permalink"></a></h2><p>It is also possible to analyze certain three-dimensional ordinary differential equations in <code>ConleyDynamics.jl</code>. To provide one such example, consider the system</p><p class="math-container">\[   \begin{array}{rcl}
     \dot{x}_1 &amp; = &amp; (\lambda-1) x_1 - \frac{3\lambda}{2\pi}
       \left( (x_1^3 - x_1^2 x_3 + x_2^2 x_3 + 2 x_1
       \left( x_2^2 + x_3^2 \right) \right) \\[1ex]
     \dot{x}_2 &amp; = &amp; (\lambda-4) x_2 - \frac{3\lambda}{2\pi} \;
       x_2 \left( 2 x_1^2 + x_2^2 + 2 x_1 x_3 + 2 x_3^2 \right) \\[1ex]
     \dot{x}_3 &amp; = &amp; (\lambda-9) x_3 + \frac{\lambda}{2\pi}
       \left( x_1 \left( x_1^2 - 3 x_2^2 \right) - 3 x_3
       \left( 2 x_1^2 + 2 x_2^2 + x_3^2 \right) \right)
   \end{array}\]</p><p>This system arises in the study of the so-called <em>Allen-Cahn equation</em>, which is the parabolic partial differential equation given by</p><p class="math-container">\[   u_t = \Delta u + \lambda \left( u - u^3 \right)
   \;\;\;\text{ in }\;\;\; \Omega = (0,\pi)
   \quad\text{ with }\quad
   u = 0 \;\;\;\text{ on }\;\;\; \partial\Omega \; .\]</p><p>This partial differential equation can be interpreted as an infinite-dimensional system of ordinary differential equations, see for example [<a href="../references/#sander:wanner:pdebook">SW24</a>, Section 6.1]. For this, one has to expand the unknown function <span>$u(t,\cdot)$</span> as a generalized Fourier series with respect to the basis functions</p><p class="math-container">\[   \varphi_k(x) = \sqrt{\frac{2}{\pi}} \, \sin(k \pi x)
   \quad\text{ for }\quad
   k \in \mathbb{N} \; .\]</p><p>If one truncates this series representation after three terms, and projects the right-hand side of the partial differential equation onto the linear space spanned by the first three basis functions, then the three coefficients of the approximating sum satisfy the above three-dimensional ordinary differential equation. Thus, this system provides a model for the dynamics of the partial differential equation, at least for sufficiently small values of the parameter <span>$\lambda$</span>. It can be implemented in Julia using the following commands:</p><pre><code class="language-julia hljs">function allencahn3d(x::Vector{Float64})
    #
    # Allen-Cahn projection
    #
    lambda = 3.0 * pi
    c      = lambda / pi
    x1, x2, x3 = x
    y1 = (lambda-1)*x1 - 1.5*c * (x1*x1*x1-x1*x1*x3+x2*x2*x3+2*x1*(x2*x2+x3*x3))
    y2 = (lambda-4)*x2 - 1.5*c * x2 * (2*x1*x1+x2*x2+2*x1*x3+2*x3*x3)
    y3 = (lambda-9)*x3 + 0.5*c * (x1*(x1*x1-3*x2*x2)-3*x3*(2*x1*x1+2*x2*x2+x3*x3))
    return [y1, y2, y3]
end</code></pre><p>Notice that for our example we use the parameter value <span>$\lambda = 3\pi$</span>. In this particular case, one can show numerically that the system has seven equilibrium solutions. These are approximately given as follows:</p><ul><li>Two equilibria <span>$\pm(1.45165, \; 0, \; 0.24396)$</span> of index 0.</li><li>Two equilibria <span>$\pm(0, \; 1.09796, \; 0)$</span> of index 1.</li><li>Two equilibria <span>$\pm(0, \; 0, \; 0.307238)$</span> of index 2.</li><li>One equilibrium <span>$(0, \; 0, \; 0)$</span> of index 3.</li></ul><p>In order to find the associated Morse decomposition, one can use the commands</p><pre><code class="language-julia hljs">N = 25
bmax = [1.8, 1.5, 1.0]
lc, coordsI = create_cubical_box(N,N,N);
coordsN = convert_spatial_coordinates(coordsI, -bmax, bmax);
mvf = create_spatial_mvf(lc, coordsN, allencahn3d);</code></pre><p>These commands create a cubical box of size <span>$25 \times 25 \times 25$</span> which covers the region <span>$[-1.8,1.8] \times [-1.5,1.5] \times [-1.0,1.0]$</span>. In addition, we construct a multivector field <code>mvf</code> which encapsulates the possible dynamics of the system. After these preparations, the Morse decomposition can be computed via</p><pre><code class="language-julia hljs">morsedecomp = morse_sets(lc, mvf);
morseinterval = morse_interval(lc, mvf, morsedecomp);
lci, mvfi = restrict_dynamics(lc, mvf, morseinterval);
cmi = connection_matrix(lci, mvfi);</code></pre><p>While the first command finds the actual Morse decomposition, the second one restricts the Lefschetz complex and the multivector field to the smallest isolated invariant set which contains all Morse sets and  connecting orbits between them. The last command finds the connection matrix.</p><p>To see whether the above commands did indeed find the correct dynamical behavior, we first inspect the computed Conley indices of the Morse sets:</p><pre><code class="language-julia hljs">julia&gt; cmi.conley
7-element Vector{Vector{Int64}}:
 [1, 0, 0, 0]
 [1, 0, 0, 0]
 [0, 1, 0, 0]
 [0, 1, 0, 0]
 [0, 0, 1, 0]
 [0, 0, 1, 0]
 [0, 0, 0, 1]</code></pre><p>Clearly, these are the correct indices based on our numerical information  concerning the stationary states of the system. The connection matrix  is given by:</p><pre><code class="language-julia hljs">julia&gt; full_from_sparse(cmi.matrix)
7×7 Matrix{Int64}:
 0  0  1  1  0  0  0
 0  0  1  1  0  0  0
 0  0  0  0  1  1  0
 0  0  0  0  1  1  0
 0  0  0  0  0  0  1
 0  0  0  0  0  0  1
 0  0  0  0  0  0  0</code></pre><p>Thus, there are a total of ten connecting orbits that are induced through algebraic topology. The index 3 equilibrium at the origin has connections to each of the index 2 solutions, which lie above and below the origin in the direction of the <span>$x_3$</span>-axis. Each of the latter two stationary states has connections to both index 1 equilibria. Finally, each of these is connected to both stable states.</p><p><img src="../img/allencahn3d_3_25.png" alt="The dynamics of an Allen-Cahn model"/></p><p>The location of the computed Morse sets is illustrated in the accompanying figure, which uses <span>$x$</span>, <span>$y$</span>, and <span>$z$</span> instead of the variable names <span>$x_1$</span>, <span>$x_2$</span>, and <span>$x_3$</span>, respectively. Notice that while the stationary states of index 0, 2, and 3 are all well-localized, this cannot be said about the two equilibria of index 1. The computed enclosures for the latter two are elongated cubical sets which are shown along the upper left and lower right of the figure. This overestimation is a result of the use of a strict cubical grid, combined with the small discretization size <code>N = 25</code>. Nevertheless, the above simple code does reproduce the overall global dynamical behavior of the ordinary differential equation correctly.</p><p>One can also compute over Morse intervals, rather than the complete Morse decomposition. The final two images show two views of the  Morse interval which corresponds to one of the index 1 equilibria, and the two stable stationary states. These computations were  performed with the finer resolution <code>N = 51</code>.</p><p><img src="../img/acinterval3d_3_51a.png" alt="Allen-Cahn Morse interval, View 1"/></p><p><img src="../img/acinterval3d_3_51b.png" alt="Allen-Cahn Morse interval, View 2"/></p><h2 id="refconley"><a class="docs-heading-anchor" href="#refconley">References</a><a id="refconley-1"></a><a class="docs-heading-anchor-permalink" href="#refconley" title="Permalink"></a></h2><p>See the <a href="../references/#References">full bibliography</a> for a complete list of references cited throughout this documentation. This section cites the following references:</p><div class="citation noncanonical"><dl><dt>[DLMS24]</dt><dd><div>T. K. Dey, M. Lipiński, M. Mrozek and R. Slechta. <em>Computing connection matrices via persistence-like reductions</em>. <a href="https://doi.org/10.1137/23M1562469">SIAM Journal on Applied Dynamical Systems <strong>23</strong>, 81–97</a> (2024).</div></dd><dt>[KMW16]</dt><dd><div>T. Kaczynski, M. Mrozek and T. Wanner. <em>Towards a formal tie between combinatorial and classical             vector field dynamics</em>. <a href="https://doi.org/10.3934/jcd.2016002">Journal of Computational Dynamics <strong>3</strong>, 17–50</a> (2016).</div></dd><dt>[MSTW22]</dt><dd><div>M. Mrozek, R. Srzednicki, J. Thorpe and T. Wanner. <em>Combinatorial vs. classical dynamics: Recurrence</em>. <a href="https://doi.org/10.1016/j.cnsns.2021.106226">Communications in Nonlinear Science and Numerical Simulation <strong>108</strong>, Paper No. 106226, 30 pages</a> (2022).</div></dd><dt>[MW21]</dt><dd><div>M. Mrozek and T. Wanner. <em>Creating semiflows on simplicial complexes from combinatorial vector fields</em>. <a href="https://doi.org/10.1016/j.jde.2021.10.001">Journal of Differential Equations <strong>304</strong>, 375–434</a> (2021).</div></dd><dt>[SW24]</dt><dd><div>E. Sander and T. Wanner. <em>Theory and Numerics of Partial Differential Equations</em> (SIAM, Philadelphia, 2024). In preparation, 1007 pages.</div></dd><dt>[SW14a]</dt><dd><div>T. Stephens and T. Wanner. <em>Isolating block validation in Matlab</em>, https://github.com/almost6heads/isoblockval (2014).</div></dd><dt>[SW14b]</dt><dd><div>T. Stephens and T. Wanner. <em>Rigorous validation of isolating blocks for flows and               their Conley indices</em>. <a href="https://doi.org/10.1137/140971075">SIAM Journal on Applied Dynamical Systems <strong>13</strong>, 1847–1878</a> (2014).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../homology/">« Homology</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 4 September 2024 20:07">Wednesday 4 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
