<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conley Theory · ConleyDynamics.jl</title><meta name="title" content="Conley Theory · ConleyDynamics.jl"/><meta property="og:title" content="Conley Theory · ConleyDynamics.jl"/><meta property="twitter:title" content="Conley Theory · ConleyDynamics.jl"/><meta name="description" content="Documentation for ConleyDynamics.jl."/><meta property="og:description" content="Documentation for ConleyDynamics.jl."/><meta property="twitter:description" content="Documentation for ConleyDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ConleyDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ConleyDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../lefschetz/">Lefschetz Complexes</a></li><li><a class="tocitem" href="../homology/">Homology</a></li><li class="is-active"><a class="tocitem" href>Conley Theory</a><ul class="internal"><li><a class="tocitem" href="#Multivector-Fields"><span>Multivector Fields</span></a></li><li><a class="tocitem" href="#Invariance-and-Conley-Index"><span>Invariance and Conley Index</span></a></li><li><a class="tocitem" href="#Morse-Decompositions"><span>Morse Decompositions</span></a></li><li><a class="tocitem" href="#Connection-Matrices"><span>Connection Matrices</span></a></li><li><a class="tocitem" href="#Extracting-Subsystems"><span>Extracting Subsystems</span></a></li><li><a class="tocitem" href="#Analysis-of-a-Planar-System"><span>Analysis of a Planar System</span></a></li><li><a class="tocitem" href="#Analysis-of-a-Spatial-System"><span>Analysis of a Spatial System</span></a></li><li><a class="tocitem" href="#Forman&#39;s-Morse-Complex"><span>Forman&#39;s Morse Complex</span></a></li><li><a class="tocitem" href="#refconley"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../sparse/">Sparse Matrices</a></li><li><a class="tocitem" href="../references/">References</a></li></ul></li><li><span class="tocitem">Core API</span><ul><li><a class="tocitem" href="../../apicore/datastruct/">Composite Data Structures</a></li><li><a class="tocitem" href="../../apicore/lefschetz/">Lefschetz Complex Functions</a></li><li><a class="tocitem" href="../../apicore/homology/">Homology Functions</a></li><li><a class="tocitem" href="../../apicore/conley/">Conley Theory Functions</a></li><li><a class="tocitem" href="../../apicore/examples/">Example Functions</a></li><li><a class="tocitem" href="../../apicore/plots/">Plotting Functions</a></li><li><a class="tocitem" href="../../apicore/sparse/">Sparse Matrix Functions</a></li><li><a class="tocitem" href="../../apicore/apiindex/">Complete API Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Conley Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Conley Theory</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/main/docs/src/man/conley.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Conley-Theory"><a class="docs-heading-anchor" href="#Conley-Theory">Conley Theory</a><a id="Conley-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Conley-Theory" title="Permalink"></a></h1><p>The main motivation for <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> is the development of an accessible tool for studying the global dynamics of multivector fields on Lefschetz complexes. Having already discussed the latter, we now turn our attention to multivector fields and their global dynamics. This involves a detailed discussion of multivector fields, isolated invariant sets, their Conley index, as well as Morse decompositions and connection matrices. We also describe how a variety of isolated invariant sets can be constructed using Morse decomposition intervals, and apply these tools to the analysis of simple planar and three-dimensional ordinary differential equations.</p><h2 id="Multivector-Fields"><a class="docs-heading-anchor" href="#Multivector-Fields">Multivector Fields</a><a id="Multivector-Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Multivector-Fields" title="Permalink"></a></h2><p>Suppose that <span>$X$</span> is a Lefschetz complex as described in <a href="../lefschetz/#Lefschetz-Complexes">Lefschetz Complexes</a>, see in particular the definition in <a href="../lefschetz/#Basic-Lefschetz-Terminology">Basic Lefschetz Terminology</a>. Assume further that the Lefschetz complex is defined over a field <span>$F$</span>, which is either the rational numbers <span>$\mathbb{Q}$</span> or a finite field of prime order. Then a <em>multivector field</em> on <span>$X$</span> is defined as follows.</p><div class="admonition is-success" id="Definition:-Multivector-field-dd0dd67d3d55c2b6"><header class="admonition-header">Definition: Multivector field<a class="admonition-anchor" href="#Definition:-Multivector-field-dd0dd67d3d55c2b6" title="Permalink"></a></header><div class="admonition-body"><p>A <em>multivector field</em> <span>$\mathcal{V}$</span> on a Lefschetz complex <span>$X$</span> is a partition of <span>$X$</span> into locally closed sets.</p></div></div><p>Recall from our detailed discussion in <a href="../lefschetz/#Basic-Lefschetz-Terminology">Basic Lefschetz Terminology</a> that a set <span>$V \subset X$</span> is called locally closed if its mouth <span>$\mathrm{mo}\, V = \mathrm{cl}\, V \setminus V$</span> is closed, where closedness in turn is defined via the face relation in a Lefschetz complex. This implies that for each multivector <span>$V \in \mathcal{V}$</span> the relative homology <span>$H_*(\mathrm{cl}\, V, \mathrm{mo}\, V)$</span> is well-defined, and it allows for the following classification of multivectors:</p><ul><li>A <em>critical multivector</em> is a multivector for which <span>$H_*(\mathrm{cl}\, V, \mathrm{mo}\, V) \neq 0$</span>.</li><li>A <em>regular multivector</em> is a multivector for which <span>$H_*(\mathrm{cl}\, V, \mathrm{mo}\, V) = 0$</span>.</li></ul><p>Since a multivector is locally closed, it is a Lefschetz subcomplex of <span>$X$</span> as well, and we have already seen that its Lefschetz homology satisfies <span>$H_*(V) \cong H_*(\mathrm{cl}\, V, \mathrm{mo}\, V)$</span>. For more details, see <a href="../homology/#Relative-Homology">Relative Homology</a>.</p><p>The above classification of multivectors is motivated by the case of classical <em>Forman vector fields</em>. These are a special  case of multivector fields, in that they also form a partition of the underlying Lefschetz complex. This time, however, there  are only two types of multivectors:</p><ul><li>A <em>critical cell</em> is a multivector consisting of exactly one cell of the Lefschetz complex. One can easily see that in this case the <span>$k$</span>-th homology group is isomorphic to <span>$F$</span>, as long as the cell has dimension <span>$k$</span>. All other homology groups vanish. Thus, every critical cell  is a critical multivector.</li><li>A <em>Forman arrow</em> is a multivector consisting of two cells <span>$\sigma^-$</span> and <span>$\sigma^+$</span>, where <span>$\sigma^-$</span> is a facet of <span>$\sigma^+$</span>. In other words, one has to have <span>$\kappa(\sigma^+, \sigma^-) \neq 0$</span>, which also implies that <span>$1 + \dim\sigma^- = \dim\sigma^+$</span>. One can show that all homology groups of a Forman arrow are zero, and therefore it is a regular multivector.</li></ul><p>In <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a>, multivector fields can be created in two different ways. The direct method is to specify all multivectors of length larger than one in an array of type <code>Vector{Vector{Int}}</code> or <code>Vector{Vector{String}}</code>, depending on whether the involved cells are referenced via their indices or labels. Recall that it is easy to convert between these two forms using the command <a href="../../apicore/lefschetz/#ConleyDynamics.convert_cellsubsets"><code>convert_cellsubsets</code></a>. The subsets specified by the vector entries have to be disjoint. They do not, however, have to exhaust  the underlying Lefschetz complex <span>$X$</span>. Any cells that are not part of a specified multivector will be considered as one-element critical cells. This reduces the size of the representation in many situations.</p><p>For large Lefschetz complexes, the above method becomes quickly  impractical. In such a case it is easier to determine a multivector field indirectly, through a mechanism involving <em>dynamical  transitions</em>. This is based on the following result.</p><div class="admonition is-danger" id="Theorem:-Multivector-fields-via-dynamical-transitions-438accf1c1e88e03"><header class="admonition-header">Theorem: Multivector fields via dynamical transitions<a class="admonition-anchor" href="#Theorem:-Multivector-fields-via-dynamical-transitions-438accf1c1e88e03" title="Permalink"></a></header><div class="admonition-body"><p>Let <span>$X$</span> be a Lefschetz complex and let <span>$\mathcal{D}$</span> denote an arbitrary collection of subsets of <span>$X$</span>. Then there exists a uniquely determined minimal multivector field <span>$\mathcal{V}$</span> which satisfies the following:</p><ul><li>For every <span>$D \in \mathcal{D}$</span> there exists a <span>$V \in \mathcal{V}$</span> such that <span>$D \subset V$</span>.</li></ul><p>Note that the sets in <span>$\mathcal{D}$</span> do not have to be disjoint, and their union does not have to exhaust <span>$X$</span>. One can think of the sets in <span>$\mathcal{D}$</span> as all allowable dynamical transitions.</p></div></div><p>The above result shows that as long as one has an idea about the  transitions that a system has to be allowed to do, one can always find a smallest multivector field which realizes them. Needless to say, if too many transitions are specified, then it is possible that the result leads to the trivial multivector field <span>$\mathcal{V} = \{ X \}$</span>. In most cases, however, the resulting multivector field is more useful. See also the examples later in this section of the manual.</p><p>The package <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> provides a number of functions for creating and manipulating multivector fields on Lefschetz complexes:</p><ul><li>The function <a href="../../apicore/conley/#ConleyDynamics.create_mvf_hull"><code>create_mvf_hull</code></a> implements the above theorem on dynamical transitions. It expects two input arguments: A Lefschetz complex <code>lc</code>, as well as a vector <code>mvfbase</code> that defines the dynamical transitions in <span>$\mathcal{D}$</span>. The latter has to have type <code>Vector{Vector{Int}}</code> or <code>Vector{Vector{String}}</code>.</li><li>The function <a href="../../apicore/conley/#ConleyDynamics.mvf_information"><code>mvf_information</code></a> displays basic information about a given multivector field. It expects both a Lefschetz complex and a multivector field as arguments, and returns a <code>Dict{String,Any}</code> with the information. The <code>keys</code> of this dictionary are as follows:<ul><li><code>&quot;N mv&quot;</code>: Number of multivectors</li><li><code>&quot;N critical&quot;</code>: Number of critcal multivectors</li><li><code>&quot;N regular&quot;</code>: Number of regular multivectors</li><li><code>&quot;Lengths critical&quot;</code>: Length distribution of critical multivectors</li><li><code>&quot;Lengths regular&quot;</code>: Length distribution of regular multivectors</li></ul>In the last two cases, the dictionary entries are vectors of pairs <code>(length,frequency)</code>, where each pair indicates that there are <code>frequency</code> multivectors of length <code>length</code>.</li><li>The function <a href="../../apicore/conley/#ConleyDynamics.extract_multivectors"><code>extract_multivectors</code></a> expects as input arguments a Lefschetz complex and a multivector field, as well as a list of cells specified as a <code>Vector{Int}</code> or a <code>Vector{String}</code>. It returns a list of all multivectors that contain the specified cells.</li><li>The function <a href="../../apicore/conley/#ConleyDynamics.create_planar_mvf"><code>create_planar_mvf</code></a> creates a multivector field which approximates the dynamics of a given planar vector field. It expects as arguments a two-dimensional Lefschetz complex, a vector of planar coordinates for the vertices of the complex, as well as a function which implements the vector field. It returns a multivector field based on the dynamical transitions induced by the vector field directions on the vertices and edges of the Lefschetz complex. While the complex does not have to be a triangulation, it is  expected that the one-dimensional cells are straight line segments between the two boundary vertices.</li><li>The utility function <a href="../../apicore/conley/#ConleyDynamics.planar_nontransverse_edges"><code>planar_nontransverse_edges</code></a> expects the same arguments as the previous one, and returns a list of nontransverse edges as <code>Vector{Int}</code>, which contains the corresponding edge indices. The optional parameter <code>npts</code> determines how many points along an edge are evaluated for the transversality check.</li><li>The function <a href="../../apicore/conley/#ConleyDynamics.create_spatial_mvf"><code>create_spatial_mvf</code></a> creates a multivector field which approximates the dynamics of a given spatial vector field. While it expects the same arguments as its planar counterpart, the Lefschetz complex has to be of one of the following two types:<ul><li>The Lefschetz complex is a <em>tetrahedral mesh</em> of a region in three dimensions, i.e., it is a simplicial complex.</li><li>The Lefschetz complex is a three-dimensional <em>cubical complex</em>, i.e., it is the closure of a collection of three-dimensional cubes in space.</li></ul>In the second case, the vertex coordinates can be slightly perturbed from the original position in the cubical lattice, as long as the overall structure of the complex stays intact. In that case, the faces are interpreted as Bezier surfaces with straight edges.</li></ul><p>All of these functions will be illustrated in more detail in the examples which are presented later in this section. See also the <a href="../tutorial/#Tutorial">Tutorial</a> for another planar vector field analysis.</p><h2 id="Invariance-and-Conley-Index"><a class="docs-heading-anchor" href="#Invariance-and-Conley-Index">Invariance and Conley Index</a><a id="Invariance-and-Conley-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Invariance-and-Conley-Index" title="Permalink"></a></h2><p>A multivector field induces dynamics on the underlying Lefschetz complex through the iteration of a multivalued map. This <em>flow map</em> is given by</p><p class="math-container">\[   \Pi_{\mathcal V}(x) = \mathrm{cl}\, x \cup [x]_{\mathcal V}
   \qquad\text{ for all }\qquad
   x \in X\]</p><p>where <span>$[x]_{\mathcal V}$</span> denotes the unique multivector in <span>${\mathcal V}$</span> which contains <span>$x$</span>. The definition of the flow map shows that the induced dynamics combines two types of behavior:</p><ul><li>From a cell <span>$x$</span>, it is always possible to flow towards the boundary of the cell, i.e., to any one of its faces.</li><li>In addition, it is always possible to move freely within a multivector.</li></ul><p>The multivalued map <span>$\Pi_{\mathcal V} : X \multimap X$</span> naturally leads to a solution concept for multivector fields. A <em>path</em> is a sequence <span>$x_0, x_1, \ldots, x_n \in X$</span> such that <span>$x_k \in \Pi_{\mathcal{V}}(x_{k-1})$</span> for all indices <span>$k = 1,\ldots,n$</span>. Paths of bi-infinite length are called solutions. More precisely, a <em>solution</em> of the combinatorial dynamical system induced by the multivector field is then a map <span>$\rho : \mathbb{Z} \to X$</span> which satisfies <span>$\rho(k+1) \in \Pi_{\mathcal V}(\rho(k))$</span> for all <span>$k \in \mathbb{Z}$</span>. We say that this solution <em>passes through the cell</em> <span>$x \in X$</span> if in addition one has <span>$\rho(0) = x$</span>. It is clear from the definition of the flow map that every constant map is a solution, since we have the inclusion <span>$x \in \Pi_{\mathcal V}(x)$</span>. Thus, rather than considering solutions in the above (classical) sense, we focus on a more restrictive notion.</p><div class="admonition is-success" id="Definition:-Essential-solution-551467a9f2524fd3"><header class="admonition-header">Definition: Essential solution<a class="admonition-anchor" href="#Definition:-Essential-solution-551467a9f2524fd3" title="Permalink"></a></header><div class="admonition-body"><p>Let <span>$\rho : \mathbb{Z} \to X$</span> be a solution for the multivector field <span>$\mathcal{V}$</span>. Then <span>$\rho$</span> is an <em>essential solution</em>, if the following holds:</p><ul><li>If for <span>$k \in \mathbb{Z}$</span> the cell <span>$\rho(k)$</span> lies in a regular multivector <span>$V \in \mathcal{V}$</span>, then there exist integers <span>$\ell_1 &lt; k &lt; \ell_2$</span> for which we have <span>$\rho(\ell_i) \not\in V$</span> for <span>$i = 1,2$</span>.</li></ul><p>In other words, an essential solution has to leave a regular multivector both in forward and in backward time. It can, however, stay in a critical multivector for as long as it wants.</p></div></div><p>The notion of essential solution has its origin in the distinction between critical and regular multivectors. In Forman&#39;s theory,  which is based on classical Morse theory, critical cells correspond to stationary solutions or equilibria of the underlying flow. Thus, it has to be possible to stay in a critical multivector for all times, whether in forward or backward time, or even for all times. On the other hand, a Forman arrow indicates prescribed non-negotiable motion, and therefore a regular multivector corresponds to motion which goes from the multivector to its mouth.</p><p>The multivector field from the package logo, which is shown in the accompanying image, consists of three critical cells, two Forman arrows, as well as one multivector which consists of four cells. Beyond the constant essenetial solutions in each of the three critical cells, another essential solution is the <em>periodic orbit</em></p><p class="math-container">\[   \rho_P \;\text{ given by }\;
   \ldots \to \mathbf{A} \to \mathbf{AB} \to \mathbf{B}
     \to \mathbf{BCD} \to \mathbf{C} \to \mathbf{AC}
     \to \mathbf{A} \to \ldots\]</p><p>Notice that this is just one of many realizations of this particular periodic motion, since an essential solution can take many different paths through a multivector.</p><p><img src="../img/multivectorex.png" alt="The logo multivector field"/></p><p>Using the concept of essential solutions we can now introduce the notion of <em>invariance</em>. Informally, we say that a subset of a Lefschetz complex is invariant if through every cell in the set there exists an essential solution which stays in the set. In other words, we have the choice of staying in the set, even though there might be other solutions that do leave. More generally, for every subset <span>$A \subset X$</span> one can ask whether there are elements <span>$x \in A$</span> for which there exists an essential solution which passes through <span>$x$</span> and stays in <span>$A$</span> for all times. This leads to the definition of the <em>invariant part of <span>$A$</span></em> as</p><p class="math-container">\[   \mathrm{Inv}_{\mathcal{V}}(A) =
   \left\{ x \in A \, : \,
      \text{there exists an essential solution }
      \rho : \mathbb{Z} \to A \text{ through } x
      \right\}\]</p><p>It is certainly possible that the invariant part of a set is  empty. If, however, the invariant part of <span>$A$</span> is all of <span>$A$</span>, i.e., if we have <span>$\mathrm{Inv}_{\mathcal{V}}(A) = A$</span>, then the set <span>$A$</span> is called <em>invariant</em>. In the context of our above logo example, the image of the essential solution <span>$\rho_P$</span> is clearly an invariant set.</p><p>Invariant sets are the fundamental building blocks for the global dynamics of a dynamical system. Yet, in general they are difficult to study. Conley realized in [<a href="../references/#conley_78a">Con78</a>] that if one  restricts the attention to a more specialized notion of invariance, then topological methods can be used to formulate a coherent  general theory. For this, we need to introduce the notion of  <em>isolated invariant set</em>:</p><div class="admonition is-success" id="Definition:-Isolated-invariant-set-68aa76eaf9d7e016"><header class="admonition-header">Definition: Isolated invariant set<a class="admonition-anchor" href="#Definition:-Isolated-invariant-set-68aa76eaf9d7e016" title="Permalink"></a></header><div class="admonition-body"><p>A closed set <span>$N \subset X$</span> <em>isolates</em> an invariant set <span>$S \subset N$</span>, if the following two conditions are satisfied:</p><ul><li>Every path in <span>$N$</span> with endpoints in <span>$S$</span> is a path in <span>$S$</span>.</li><li>We have <span>$\Pi_{\mathcal{V}}(S) \subset N$</span>.</li></ul><p>An invariant set <span>$S$</span> is an <em>isolated invariant set</em>, if there exists a closed set <span>$N$</span> which isolates <span>$S$</span>.</p></div></div><p>It is clear that the whole Lefschetz complex <span>$X$</span> isolates its invariant part. Therefore, the set <span>$\mathrm{Inv}_{\mathcal{V}}(X)$</span> is an isolated invariant set. Moreover, one can readily show that if <span>$N$</span> is an isolating set for an isolated invariant set <span>$S$</span>, then any closed set <span>$S \subset M \subset N$</span> also isolates <span>$S$</span>. Thus, the closure <span>$\mathrm{cl}\, S$</span> is the smallest isolating set for <span>$S$</span>. With these observations in mind, one obtains the following result from [<a href="../references/#lipinski_etal_23a">LKMW23</a>]:</p><div class="admonition is-danger" id="Theorem:-Characterization-of-isolated-invariant-sets-9b841672dbd5fec0"><header class="admonition-header">Theorem: Characterization of isolated invariant sets<a class="admonition-anchor" href="#Theorem:-Characterization-of-isolated-invariant-sets-9b841672dbd5fec0" title="Permalink"></a></header><div class="admonition-body"><p>An invariant set <span>$S \subset X$</span> is an isolated invariant set, if and only if the following two conditions hold:</p><ul><li><span>$S$</span> is <em><span>$\mathcal{V}$</span>-compatible</em>, i.e., it is the union of multivectors.</li><li><span>$S$</span> is locally closed.</li></ul><p>In this case, the isolated invariant set <span>$S$</span> is isolated by its closure <span>$\mathrm{cl}\, S$</span>.</p></div></div><p>Returning to our earlier logo example, notice that the cells visited by the periodic essential solution <span>$\rho_P$</span> do not form an isolated invariant set, but rather just an invariant set. However, if we consider the larger set <span>$S_P$</span> which consists of all cells except for the cells <span>$\mathbf{ABC}$</span> and <span>$\mathbf{D}$</span>, then we do obtain an isolated invariant set which contains the periodic orbit <span>$\rho_P$</span>.</p><p>With this characterization at hand, identifying isolated invariant sets becomes straightforward. In addition, since isolated invariant sets are locally closed, we can now also define their <em>Conley index</em>:</p><div class="admonition is-success" id="Definition:-Conley-index-86156a20fe922ae7"><header class="admonition-header">Definition: Conley index<a class="admonition-anchor" href="#Definition:-Conley-index-86156a20fe922ae7" title="Permalink"></a></header><div class="admonition-body"><p>Let <span>$S \subset X$</span> be an isolated invariant set the multivalued flow map <span>$\Pi_{\mathcal{V}}$</span>. Then the <em>Conley index of <span>$S$</span></em> is the relative (or Lefschetz) homology</p><p class="math-container">\[   CH_*(S) = H_*( \mathrm{cl}\, S, \mathrm{mo}\, S)
           \cong H_*(S)\]</p><p>In addition, the <em>Poincare polynomial of <span>$S$</span></em> is defined as</p><p class="math-container">\[   p_{S}(t) = \sum_{k=0}^\infty \beta_k(S) t^k \, ,
   \quad\text{where}\quad
   \beta_k(S) = \dim CH_k(S) \; .\]</p><p>The Poincare polynomial is a concise way to encode the homology information.</p></div></div><p>Since the Conley index is nothing more than the relative homology of the closure-mouth-pair associated with a locally closed set, one could easily use the homology functions described in <a href="../homology/#Homology">Homology</a> for its computation. However, we have included a wrapper function to keep the notation uniform. In addition, <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> contains a function which provides basic information about an isolated invariant set. These two functions can be described as follows:</p><ul><li>The function <a href="../../apicore/conley/#ConleyDynamics.conley_index"><code>conley_index</code></a> determines the Conley index of an isolated invariant set. It expects a Lefschetz complex as its first argument, while the second one has to be a list of cells which specifies the isolated invariant  set, and which is either of type <code>Vector{Vector{Int}}</code> or <code>Vector{Vector{String}}</code>. An error is raised if the second argument does not specify a locally closed set.</li><li>The function <a href="../../apicore/conley/#ConleyDynamics.isoinvset_information"><code>isoinvset_information</code></a> expects a Lefschetz complex <code>lc::LefschetzComplex</code>, a multivector field <code>mvf::CellSubsets</code>, as well as an isolated invariant set <code>iis::Cells</code> as its three arguments. Itreturns a <code>Dict{String,Any}</code> with the information. The <code>keys</code> of this dictionary are as follows:<ul><li><code>&quot;Conley index&quot;</code> contains the Conley index of the  isolated invariant set.</li><li><code>&quot;N multivectors&quot;</code> contains the number of multivectors in the isolated invariant set.</li></ul></li></ul><h2 id="Morse-Decompositions"><a class="docs-heading-anchor" href="#Morse-Decompositions">Morse Decompositions</a><a id="Morse-Decompositions-1"></a><a class="docs-heading-anchor-permalink" href="#Morse-Decompositions" title="Permalink"></a></h2><p>We now turn our attention to the global dynamics of a combinatorial dynamical system. This is accomplished through the notion of <em>Morse decomposition</em>, and it requires some auxilliary definitions:</p><ul><li>Suppose we are given a solution <span>$\varphi : \mathbb{Z} \to X$</span> for the multivector field <span>$\mathcal{V}$</span>. Then the long-term limiting behavior of <span>$\varphi$</span> can be described using the <em>ultimate backward and forward images</em><p class="math-container">\[   \mathrm{uim}^- \varphi =
   \bigcap_{t \in \mathbb{Z}^-} \varphi\left( (-\infty,t] \right)
   \qquad\text{and}\qquad
   \mathrm{uim}^+ \varphi =
   \bigcap_{t \in \mathbb{Z}^+} \varphi\left( [t,+\infty) \right) .\]</p>Notice that since <span>$X$</span> is finite, there has to exist a <span>$k \in \mathbb{N}$</span> such that<p class="math-container">\[   \mathrm{uim}^- \varphi =
   \varphi\left( (-\infty,-k] \right) \neq \emptyset
   \qquad\text{and}\qquad
   \mathrm{uim}^+ \varphi =
   \varphi\left( [k,+\infty) \right) \neq \emptyset .\]</p></li><li>The <em><span>$\mathcal{V}$</span>-hull</em> of a set <span>$A \subset X$</span> is the intersection of all <span>$\mathcal{V}$</span>-compatible and locally closed sets containing <span>$A$</span>. It is denoted by <span>$\langle A \rangle_{\mathcal{V}}$</span>, and is the smallest  candidate for an isolated invariant set which contains <span>$A$</span>.</li><li>The <span>$\alpha$</span>- and <span>$\omega$</span>-limit sets of <span>$\varphi$</span> are then defined as<p class="math-container">\[   \alpha(\varphi) =
   \left\langle \mathrm{uim}^- \varphi \right\rangle_{\mathcal{V}}
   \qquad\text{and}\qquad
   \omega(\varphi) =
   \left\langle \mathrm{uim}^+ \varphi \right\rangle_{\mathcal{V}}.\]</p></li></ul><p>While in general the <span>$\mathcal{V}$</span>-hull of a set does not have to be invariant, the following result shows that for every  essential solution both of its limit sets are in fact isolated invariant sets.</p><div class="admonition is-danger" id="Theorem:-Limit-sets-are-nontrivial-60f3a29f9a08e66a"><header class="admonition-header">Theorem: Limit sets are nontrivial<a class="admonition-anchor" href="#Theorem:-Limit-sets-are-nontrivial-60f3a29f9a08e66a" title="Permalink"></a></header><div class="admonition-body"><p>Let <span>$\varphi$</span> be an essential solution in <span>$X$</span>. Then both limit sets <span>$\alpha(\varphi)$</span> and <span>$\omega(\varphi)$</span> are nonempty isolated invariant sets.</p></div></div><p>We briefly pause to illustrate these concepts in the context of the above logo example. For the periodic essential solution <span>$\rho_P$</span>, both its ultimate backward and forward images  are precisely the cells visited by the solution. The <span>$\mathcal{V}$</span>-hull of <span>$\mathrm{im}\, \rho_P$</span> is the set <span>$S_P$</span> which consists of all cells except the index 0 and 2 critical cells. It was already mentioned earlier that this indeed defines an isolated invariant set.</p><p>The above notions allow us to decompose the global dynamics of a multivector field. Loosely speaking, this is accomplished by separating the dynamics into a recurrent part given by an indexed collection of isolated invariant sets, and the gradient dynamics between them. This can be abstracted through the concept of a <em>Morse decomposition</em>.</p><div class="admonition is-success" id="Definition:-Morse-decomposition-f0300445e3e09c0b"><header class="admonition-header">Definition: Morse decomposition<a class="admonition-anchor" href="#Definition:-Morse-decomposition-f0300445e3e09c0b" title="Permalink"></a></header><div class="admonition-body"><p>Assume that <span>$X$</span> is an invariant set for the multivector field <span>$\mathcal{V}$</span> and that <span>$(\mathbb{P},\leq)$</span> is a finite poset. Then an indexed collection <span>$\mathcal{M} = \left\{ M_p \, : \, p \in \mathbb{P} \right\}$</span> is called a <em>Morse decomposition</em> of <span>$X$</span> if the following conditions are satisfied:</p><ul><li>The indexed family <span>$\mathcal{M}$</span> is a family of mutually disjoint, isolated invariant subsets of <span>$X$</span>.</li><li>For every essential solution <span>$\varphi$</span> in <span>$X$</span> either one has <span>$\mathrm{im} \, \varphi \subset M_r$</span> for an <span>$r \in \mathbb{P}$</span> or there exist two poset elements <span>$p,q \in \mathbb{P}$</span> such that <span>$q &gt; p$</span> and<p class="math-container">\[   \alpha(\varphi) \subset M_q
   \qquad\text{and}\qquad
   \omega(\varphi) \subset M_p .\]</p>The elements of <span>$\mathcal{M}$</span> are called <em>Morse sets</em>. We would like to point out that some of the Morse sets could be empty.</li></ul></div></div><p>Given a combinatorial multivector field <span>$\mathcal{V}$</span> on an arbitrary Lefschetz complex <span>$X$</span>, there always exists a finest Morse decomposition <span>$\mathcal{M}$</span>. It can be found by determining those strongly connected components of the digraph associated with the multivalued flow map <span>$\Pi_{\mathcal{V}} : X \multimap X$</span> which contain essential solutions. The associated <em>Conley-Morse graph</em> is the partial order induced on <span>$\mathcal{M}$</span> by the existence of connections, and represented as a directed graph labelled with the Conley indices of the isolated invariant sets in <span>$\mathcal{M}$</span> in terms of their Poincare polynomials.</p><p>In order to capture the dynamics between two subsets <span>$A,B \subset X$</span> one can define the <em>connection set</em> from <span>$A$</span> to <span>$B$</span> as the cell collection</p><p class="math-container">\[   \mathcal{C}(A,B) =
   \left\{ x \in X \, : \,
     \exists \, \text{ essential solution }
     \varphi \text{ through } x \text{ with }
     \alpha(\varphi) \subset A \text{ and }
     \omega(\varphi) \subset B \right\} .\]</p><p>Then <span>$\mathcal{C}(A,B)$</span> is an isolated invariant set. We would  like to point out, however, that the connection set can be, and in fact will be, empty in many cases.</p><p>While the Morse sets of a Morse decomposition are the fundamental building blocks for the global dynamics, there usually are many additional isolated invariant sets for the multivector field <span>$\mathcal{V}$</span>. Of particular interest are <em>Morse intervals</em>. To define them, let <span>$I \subset \mathbb{P}$</span> denote an interval in the index poset. Then</p><p class="math-container">\[   M_I \; = \; \bigcup_{p \in I} M_p \; \cup \;
               \bigcup_{p,q \in I} \mathcal{C}( M_q, M_p )\]</p><p>is always an isolated invariant set. Nevertheless, not every isolated invariant set is of this form. For example, the figure contains the multivector field which was discussed in [<a href="../references/#batko_etal_20a">BKMW20</a>, Figure 3]. While the underlying simplicial complex and the Forman vector field are depicted in the left panel, the associated Conley-Morse graph is shown on the right. For this combinatorial dynamical system, there exists an isolated invariant set which contains only the four Morse sets within the gray region under the graph. More details can be found in <a href="../examples/#A-Planar-Forman-Vector-Field">A Planar Forman Vector Field</a>.</p><p><img src="../img/examplebkmw3c.png" alt="Morse decomposition of the planar flow"/></p><p>Morse decompositions and intervals can be easily computed  and manipulated in <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> using the following commands:</p><ul><li>The function <a href="../../apicore/conley/#ConleyDynamics.morse_sets"><code>morse_sets</code></a> expects a Lefschetz complex and a multivector field as arguments, and returns the Morse sets of the finest Morse decomposition as a <code>Vector{Vector{Int}}</code> or <code>Vector{Vector{String}}</code>, matching the format used for the multivector field. If the optional argument <code>poset=true</code> is added, then the function also returns a matrix which encodes the Hasse diagram of the poset <span>$\mathbb{P}$</span>. Note that this is the transitive reduction of the full poset,  i.e., it only contains necessary relations.</li><li>The function <a href="../../apicore/conley/#ConleyDynamics.morse_interval"><code>morse_interval</code></a> computes the isolated invariant set for a Morse set interval. The three input arguments are the underlying Lefschetz complex, a multivector field, and a collection of Morse sets. The latter should be determined using the function <a href="../../apicore/conley/#ConleyDynamics.morse_sets"><code>morse_sets</code></a>. The function returns the smallest isolated invariant set which contains the Morse sets and their connections as a <code>Vector{Int}</code>. The result can be converted to label form using <a href="../../apicore/lefschetz/#ConleyDynamics.convert_cells"><code>convert_cells</code></a>.</li><li>The function <a href="../../apicore/conley/#ConleyDynamics.restrict_dynamics"><code>restrict_dynamics</code></a> restricts a multivector field to a Lefschetz subcomplex. The function expects three arguments: A Lefschetz complex <code>lc</code>, a multivector field <code>mvf</code>, and a subcomplex of the Lefschetz complex which is given by the locally closed set represented by <code>lcsub</code>. It returns the associated Lefschetz subcomplex <code>lcreduced</code> and the induced multivector field <code>mvfreduced</code> on the subcomplex. The multivectors of the new multivector field are the intersections of the original multivectors and the subcomplex.</li><li>Finally, the function <a href="../../apicore/conley/#ConleyDynamics.remove_exit_set"><code>remove_exit_set</code></a> removes the exit set for a multivector field on a Lefschetz subcomplex. It is assumed that the Lefschetz complex <code>lc</code> is a topological manifold and that <code>mvf</code> contains a multivector field that is created via either <a href="../../apicore/conley/#ConleyDynamics.create_planar_mvf"><code>create_planar_mvf</code></a> or <a href="../../apicore/conley/#ConleyDynamics.create_spatial_mvf"><code>create_spatial_mvf</code></a>. The function identifies cells on the boundary at which the flows exits the region covered by the Lefschetz complex. If this exit set is closed, one has found an isolated invariant set and the function returns a Lefschetz complex <code>lcr</code> restricted to it, as well as the restricted multivector field <code>mvfr</code>. If the exit set is not closed, a warning is displayed and the function returns the restricted Lefschetz complex and multivector field obtained by removing the closure of the exit set. <em>In the latter case, unexpected results might be obtained.</em></li></ul><p>The first two of these functions rely heavily on the Julia package <a href="http://juliagraphs.org/Graphs.jl/stable/">Graphs.jl</a>.</p><h2 id="Connection-Matrices"><a class="docs-heading-anchor" href="#Connection-Matrices">Connection Matrices</a><a id="Connection-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Connection-Matrices" title="Permalink"></a></h2><p>While a Morse decomposition represents the basic structure of the global dynamics of a combinatorial dynamical system, it does not directly provide more detailed information about the dynamics between them – except for the poset order on the Morse sets. But which of the associated connecting sets actually have to be nonempty? The algebra behind this question is captured by the <em>connection matrix</em>. The precise notion of connection matrix was introduced in [<a href="../references/#franzosa_89a">Fra89</a>], see also [<a href="../references/#harker_etal_21a">HMS21</a>], as well as the book [<a href="../references/#mrozek_wanner_25a">MW25</a>] which treats connection matrices specifically in the setting of multivector fields and provides a precise definition of connection matrix equivalence, even  across varying posets.</p><p>Since the precise definition of a connection matrix is  beyond the scope of this manual, we only state what it is as an object, what its main properties are, and how it can be computed in <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a>. Assume therefore that we are given a Morse decomposition <span>$\mathcal{M}$</span> of an isolated invariant set <span>$S$</span>. Then the <em>connection matrix</em> is a linear map</p><p class="math-container">\[   \Delta \; : \; \bigoplus_{q \in \mathbb{P}} CH_*(M_q)
   \to \bigoplus_{p \in \mathbb{P}} CH_*(M_p) ,\]</p><p>i.e., it is a linear map which is defined on the direct sum of all Conley indices of the Morse sets in the Morse decomposition. One usually writes the connection matrix <span>$\Delta$</span> as a matrix in the form <span>$\Delta = (\Delta(p,q))_{p,q \in \mathbb{P}}$</span>, which is indexed by the poset <span>$\mathbb{P}$</span>, and where the entries <span>$\Delta(p,q) : CH_*(M_q) \to CH_*(M_p)$</span> are linear maps between homological Conley indices. If <span>$I$</span> denotes an interval in the poset <span>$\mathbb{P}$</span>, then one further defines the restricted connection matrix</p><p class="math-container">\[   \Delta(I) \; = \; \left( \Delta(p,q) \right)_{p,q \in I}
     \; : \; \bigoplus_{p \in I} CH_*(M_p) \to
     \bigoplus_{p \in I} CH_*(M_p) .\]</p><p>Any connection matrix <span>$\Delta$</span> has the following fundamental properties:</p><ul><li>The matrix <span>$\Delta$</span> is <em>strictly upper triangular</em>, i.e., if <span>$\Delta(p,q) \not= 0$</span> then <span>$p &lt; q$</span>.</li><li>The matrix <span>$\Delta$</span> is a <em>boundary operator</em>, i.e., we have <span>$\Delta \circ \Delta = 0$</span>, and <span>$\Delta$</span> maps <span>$k$</span>-th level homology to <span>$(k-1)$</span>-st level homology for all <span>$k \in \mathbb{Z}$</span>.</li><li>For every interval <span>$I$</span> in <span>$\mathbb{P}$</span> we have<p class="math-container">\[   H_*\Delta(I) \; = \;
   \mathrm{ker}\, \Delta(I) / \mathrm{im}\, \Delta(I)
   \; \cong \; CH_*(M_I) .\]</p>In other words, the <em>Conley index of a Morse interval</em> can be determined via the <em>homology</em> of the associated <em>connection matrix minor</em> <span>$\Delta(I)$</span>.</li><li>If <span>$\{ p, q \}$</span> is an interval in <span>$\mathbb{P}$</span> and <span>$\Delta(p,q) \neq 0$</span>, then the <em>connection set <span>$\mathcal{C}(M_q,M_p)$</span> is not empty</em>.</li></ul><p>We would like to point out that these properties do not characterize connection matrices. In practice, a given multivector field can have several different connection matrices. These in some sense encode different types of dynamical behavior that can occur in the system. Nonuniqueness, however, cannot be observed if the underlying system is a <em>gradient combinatorial Forman vector field</em> on a Lefschetz complex. These are multivector fields in which every multivector is either a singleton, and therefore a critical cell, or a two-element Forman arrow. In addition, a gradient combinatorial Forman vector field cannot have any nontrivial periodic solutions, i.e.,  periodic solutions which are not constant and therefore critical cells. For such combinatorial vector fields, the following result was shown in [<a href="../references/#mrozek_wanner_25a">MW25</a>].</p><div class="admonition is-danger" id="Theorem:-Uniqueness-of-connection-matrices-a8f595d8228eb80b"><header class="admonition-header">Theorem: Uniqueness of connection matrices<a class="admonition-anchor" href="#Theorem:-Uniqueness-of-connection-matrices-a8f595d8228eb80b" title="Permalink"></a></header><div class="admonition-body"><p>If <span>$\mathcal{V}$</span> is a gradient combinatorial Forman vector field and <span>$\mathcal{M}$</span> its finest Morse decomposition, then the connection matrix is uniquely determined.</p></div></div><p>In <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> connection matrices can be computed over arbitrary finite fields or the rationals, using the persistence-like algorithm introduced in [<a href="../references/#dey_etal_24a">DLMS24</a>]:</p><ul><li>The function <a href="../../apicore/conley/#ConleyDynamics.connection_matrix"><code>connection_matrix</code></a> computes a connection matrix for the multivector field <code>mvf</code> on the Lefschetz complex <code>lc</code> over the field associated with the Lefschetz complex boundary matrix. The function returns an object of type <a href="../../apicore/datastruct/#ConleyDynamics.ConleyMorseCM"><code>ConleyMorseCM</code></a>, which is further described below. If the optional argument <code>returnbasis=true</code> is given, then the function also returns a dictionary which gives the basis for the connection matrix columns in terms of the original cell labels.</li></ul><p>The connection matrix is returned in an object with the composite data type <a href="../../apicore/datastruct/#ConleyDynamics.ConleyMorseCM"><code>ConleyMorseCM</code></a>. Its docstring is as follows:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.ConleyMorseCM-man-conley" href="#ConleyDynamics.ConleyMorseCM-man-conley"><code>ConleyDynamics.ConleyMorseCM</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConleyMorseCM{T}</code></pre><p>Collect the connection matrix information in a struct.</p><p>The struct has the following fields:</p><ul><li><code>matrix::SparseMatrix{T}</code>: Connection matrix</li><li><code>columns::Vector{Int}</code>: Corresponding columns in the boundary matrix</li><li><code>poset::Vector{Int}</code>: Poset indices for the connection matrix columns</li><li><code>labels::Vector{String}</code>: Labels for the connection matrix columns</li><li><code>morse::Vector{Vector{String}}</code>: Vector of Morse sets in original complex</li><li><code>conley::Vector{Vector{Int}}</code>: Vector of Conley indices for the Morse sets</li><li><code>complex::LefschetzComplex</code>: The Conley complex as a Lefschetz complex</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/f25232feb0215478bc85a4a2f312fd9fd1be47d9/src/conley/composite_types.jl#L79-L92">source</a></section></article><p>To illustrate these fields further, we briefly illustrate them for the example associated with the last figure, see again <a href="../examples/#A-Planar-Forman-Vector-Field">A Planar Forman Vector Field</a>. For reference, the  underlying simplicial complex and Forman vector field are shown in the next figure.</p><p><img src="../img/examplebkmw3a.png" alt="A planar simplicial complex flow"/></p><p>The underlying Lefschetz complex, multivector field, and connection matrix can be computed over the field <span>$GF(2)$</span> as follows:</p><pre><code class="language-julia hljs">lc, mvf, coords = example_forman2d()
cm = connection_matrix(lc, mvf)
sparse_show(cm.matrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[0   0   0   0   1   0   1   0   0]
[0   0   0   0   0   1   0   0   0]
[0   0   0   0   1   1   1   0   0]
[0   0   0   0   0   0   0   0   1]
[0   0   0   0   0   0   0   1   0]
[0   0   0   0   0   0   0   0   0]
[0   0   0   0   0   0   0   1   0]
[0   0   0   0   0   0   0   0   0]
[0   0   0   0   0   0   0   0   0]</code></pre><p>The field <code>cm.poset</code> indicates which Morse set each column belongs to, while the field <code>cm.labels</code> shows which cell label the column corresponds to. For the example one obtains:</p><pre><code class="language-julia hljs">print(cm.poset)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[1, 2, 3, 3, 4, 5, 6, 7, 8]</code></pre><pre><code class="language-julia hljs">print(cm.labels)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[&quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;GJ&quot;, &quot;BF&quot;, &quot;EF&quot;, &quot;HI&quot;, &quot;ADE&quot;, &quot;FGJ&quot;]</code></pre><p>Note that except for the third and fourth column, all columns belong to unique Morse sets whose Conley index is a one-dimensional vector space. The third and fourth column correspond to the  periodic orbit, whose Conley index is a two-dimensional vector  space. The Conley indices for all eight Morse sets can be seen in the field <code>cm.conley</code>:</p><pre><code class="language-julia hljs">cm.conley</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{Vector{Int64}}:
 [1, 0, 0]
 [1, 0, 0]
 [1, 1, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 0, 1]
 [0, 0, 1]</code></pre><p>The full associated Morse sets are list in <code>cm.morse</code>:</p><pre><code class="language-julia hljs">cm.morse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{Vector{String}}:
 [&quot;D&quot;]
 [&quot;E&quot;]
 [&quot;F&quot;, &quot;G&quot;, &quot;I&quot;, &quot;J&quot;, &quot;FG&quot;, &quot;FI&quot;, &quot;GJ&quot;, &quot;IJ&quot;]
 [&quot;BF&quot;]
 [&quot;EF&quot;]
 [&quot;HI&quot;]
 [&quot;ADE&quot;]
 [&quot;FGJ&quot;]</code></pre><p>As the final struct field, the entry <code>cm.complex</code> returns the connection matrix as a Lefschetz complex in its own right. This is useful for determining the Conley indices of Morse intervals. In our example, the cells of the new Lefschetz complex are given by</p><pre><code class="language-julia hljs">cm.complex.labels</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{String}:
 &quot;D&quot;
 &quot;E&quot;
 &quot;F&quot;
 &quot;GJ&quot;
 &quot;BF&quot;
 &quot;EF&quot;
 &quot;HI&quot;
 &quot;ADE&quot;
 &quot;FGJ&quot;</code></pre><p>The Morse interval consisting of the two index 2 critical cells <span>$\mathbf{ADE}$</span> and <span>$\mathbf{FGJ}$</span> should have as Conley index the sum of the two individual indices, and the following computation demonstrates this:</p><pre><code class="language-julia hljs">conley_index(cm.complex, [&quot;ADE&quot;, &quot;FGJ&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 0
 0
 2</code></pre><p>In contrast, since there is exactly one connecting orbit between <span>$\mathbf{ADE}$</span> and <span>$\mathbf{BF}$</span>, the Conley index of this interval should be trivial:</p><pre><code class="language-julia hljs">conley_index(cm.complex, [&quot;ADE&quot;, &quot;BF&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 0
 0
 0</code></pre><p>Finally, there are exactly two connecting orbits between the Morse sets <span>$\mathbf{ADE}$</span> and <span>$\mathbf{EF}$</span>, and therefore the Conley index of this last interval is again the sum of the separate indices:</p><pre><code class="language-julia hljs">conley_index(cm.complex, [&quot;ADE&quot;, &quot;EF&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 0
 1
 1</code></pre><h2 id="Extracting-Subsystems"><a class="docs-heading-anchor" href="#Extracting-Subsystems">Extracting Subsystems</a><a id="Extracting-Subsystems-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-Subsystems" title="Permalink"></a></h2><p>We briefly return to one of the examples in the tutorial. More precisely, we consider the planar ordinary differential equation given by</p><p class="math-container">\[   \begin{array}{rcl}
     \dot{x}_1 &amp; = &amp; x_1 \left( 1 - x_1^2 - 3 x_2^2 \right) \\[1ex]
     \dot{x}_2 &amp; = &amp; x_2 \left( 1 - 3 x_1^2 - x_2^2 \right)
   \end{array}\]</p><p>The dynamics of this system is characterized by the existence of a global attractor in the shape of a closed disk. Inside the attractor, there are nine different Morse sets:</p><ul><li>The origin is an equilibrium of index 2, i.e., it is an unstable stationary state with a two-dimensional unstable manifold.</li><li>The four points <span>$(\pm 1/2, \pm 1/2)$</span> are unstable equilibria of index 1, i.e., with a one-dimensional unstable manifold.</li><li>Finally, the four points <span>$(\pm 1, 0)$</span> and <span>$(0, \pm 1)$</span> are asymptotically stable stationary states.</li></ul><p>We saw in the tutorial that the Morse decomposition of this system can easily be found using <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a>, as well as the associated connection matrix. Yet, in certain situations one might only be interested in part of the dynamics on the attractor. Moreover, while the Morse sets describe the recurrent part of the dynamics, they do not provide information on the geometry of the connecting sets between the Morse sets. In the following, we illustrate how this can be analyzed further.</p><p>The right-hand side of the above vector field can be implemented using the Julia function</p><pre><code class="language-julia hljs">function planarvf(x::Vector{Float64})
    #
    # Sample planar vector field with nontrivial Morse decomposition
    #
    x1, x2 = x
    y1 = x1 * (1.0 - x1*x1 - 3.0*x2*x2)
    y2 = x2 * (1.0 - 3.0*x1*x1 - x2*x2)
    return [y1, y2]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">planarvf (generic function with 1 method)</code></pre><p>To analyze the resulting global dynamical behavior, we first create a simplicial mesh covering the square <span>$[-6/5, 6/5]^2$</span> using the commands</p><pre><code class="language-julia hljs">lc, coords = create_simplicial_delaunay(300, 300, 5, 50);
coordsN = convert_planar_coordinates(coords,[-1.2,-1.2], [1.2,1.2]);
lc.ncells</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">14395</code></pre><p>The integer in the output gives the number of cells in the created Lefschetz complex <span>$X$</span>. Note that we are using a Delaunay triangulation over an initial box of size <span>$300 \times 300$</span>, where the target triangle size is about 5. This box is then rescaled to cover the above square. We can then create a  multivector field on the simplicial complex <code>lc</code> and find its Morse decomposition using the commands</p><pre><code class="language-julia hljs">mvf = create_planar_mvf(lc, coordsN, planarvf);
morsedecomp = morse_sets(lc, mvf);
length(morsedecomp)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9</code></pre><p>As expected, <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> finds exactly nine Morse sets. Their Conley indices can be computed and stored in a <code>Vector{Vector{Int}}</code> using the command</p><pre><code class="language-julia hljs">conleyindices = [conley_index(lc, mset) for mset in morsedecomp]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Vector{Int64}}:
 [1, 0, 0]
 [1, 0, 0]
 [0, 1, 0]
 [1, 0, 0]
 [0, 1, 0]
 [1, 0, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 0, 1]</code></pre><p>These Conley indices correspond to the dynamical behavior near the equilibrium solutions described above.</p><p>Suppose now that rather than finding the connection matrix for the complete Morse decomposition, we would only like to consider a  part of it. This can be done as long as we restrict our attention to an <em>interval in the Morse decomposition</em>. Such an interval <span>$\mathcal{I}$</span> can be created from a selection <span>$\mathcal{S}$</span> of the Morse sets in the following way:</p><ul><li>In addition to the Morse sets in <span>$\mathcal{S}$</span>, the interval <span>$\mathcal{I}$</span> contains all Morse sets that lie between two Morse sets in <span>$\mathcal{S}$</span> with respect to the poset order underlying the Morse decomposition. Recall that this poset order can be computed via <a href="../../apicore/conley/#ConleyDynamics.morse_sets"><code>morse_sets</code></a> by activating the extra return object <code>hasse</code>, which describes the Hasse diagram of the poset.</li></ul><p>With every interval <span>$\mathcal{I}$</span> of the Morse decomposition one can assign a smallest isolated invariant set <span>$X_{\mathcal{I}} \subset X$</span> which describes the complete dynamics within and between the Morse sets in <span>$\mathcal{I}$</span>. In fact, in can be characterized as follows:</p><ul><li>The set <span>$X_{\mathcal{I}}$</span> consists of all cells in the  underlying Lefschetz complex <span>$X$</span> through which one can find a solution which originates in one Morse set of <span>$\mathcal{I}$</span> and ends in another Morse set of <span>$\mathcal{I}$</span>, where the two involved Morse sets can be the same. In other words, one needs to combine the interval Morse sets with all <em>connecting orbits</em> between them.</li></ul><p>The two above steps can be performed in <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> using the function <a href="../../apicore/conley/#ConleyDynamics.morse_interval"><code>morse_interval</code></a>.</p><p>In our example, we consider two intervals. The first interval consists of the five Morse sets corresponding to all unstable equilibrium solutions, while the second one considers the four index 1 and the four stable stationary states. The associated isolated invariant sets for these two intervals can be computed as follows:</p><pre><code class="language-julia hljs">subset1 = findall(x -&gt; x[2]+x[3]&gt;0, conleyindices);
subset2 = findall(x -&gt; x[1]+x[2]&gt;0, conleyindices);
lcsub1 = morse_interval(lc, mvf, morsedecomp[subset1]);
lcsub2 = morse_interval(lc, mvf, morsedecomp[subset2]);
[length(subset1), length(subset2), length(lcsub1), length(lcsub2)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Int64}:
    5
    8
 1201
 2256</code></pre><p>The output shows that we have in fact extracted five and eight Morse sets, respectively. It also shows that the Lefschetz complexes corresponding to these two isolated invariant sets are much smaller than <span>$X$</span>.</p><p>So far, we have just determined the collections of cells that  correspond to the two isolated invariant sets for these intervals. We can now restrict the combinatorial dynamics to these subsets.  Note that since they are both isolated invariant sets, they are locally closed in <span>$X$</span>, and therefore the restrictions provide us with two new Lefschetz complexes <code>lcr1</code> and <code>lcr2</code>, along with induced multivector fields <code>mvfr1</code> and <code>mvfr2</code>, respectively. In <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a>, this is achieved using the commands</p><pre><code class="language-julia hljs">lcr1, mvfr1 = restrict_dynamics(lc, mvf, lcsub1);
lcr2, mvfr2 = restrict_dynamics(lc, mvf, lcsub2);
[lcr1.ncells, lcr2.ncells]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Int64}:
 1201
 2256</code></pre><p>It is now easy to find the connection matrices for these two intervals. The first connection matrix is given by</p><pre><code class="language-julia hljs">cmr1 = connection_matrix(lcr1, mvfr1);
cmr1.conley</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Vector{Int64}}:
 [0, 1, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 0, 1]</code></pre><pre><code class="language-julia hljs">full_from_sparse(cmr1.matrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5×5 Matrix{Int64}:
 0  0  0  0  1
 0  0  0  0  1
 0  0  0  0  1
 0  0  0  0  1
 0  0  0  0  0</code></pre><p>It clearly shows that the unstable index 2 Morse set has connecting orbits to every one of the four index 1  equilibria. Similarly, the second connection matrix can be determined as</p><pre><code class="language-julia hljs">cmr2 = connection_matrix(lcr2, mvfr2);
cmr2.conley</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{Vector{Int64}}:
 [1, 0, 0]
 [1, 0, 0]
 [1, 0, 0]
 [1, 0, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 1, 0]</code></pre><pre><code class="language-julia hljs">full_from_sparse(cmr2.matrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8×8 Matrix{Int64}:
 0  0  0  0  0  1  1  0
 0  0  0  0  0  0  1  1
 0  0  0  0  1  1  0  0
 0  0  0  0  1  0  0  1
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0</code></pre><p>In this case, every index 1 equilibrium is connected  two its two neighboring stable stationary states via heteroclinics that are detected by the connection matrix.</p><p>The Lefschetz complexes associated with the two Morse decomposition intervals can also be visualized in <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a>. For this, recall that the function <a href="../../apicore/plots/#ConleyDynamics.plot_planar_simplicial_morse"><code>plot_planar_simplicial_morse</code></a> can plot an underlying simplicial complex together with any collection of cell subsets. For our purposes, we use the following commands:</p><pre><code class="language-julia hljs">show1 = [[lcr1.labels]; cmr1.morse];
show2 = [[lcr2.labels]; cmr2.morse];
fname1 = &quot;/Users/wanner/Desktop/invariantinterval2d1.png&quot;
fname2 = &quot;/Users/wanner/Desktop/invariantinterval2d2.png&quot;
plot_planar_simplicial_morse(lc, coordsN, fname1, show1, vfac=1.1, hfac=2.0)
plot_planar_simplicial_morse(lc, coordsN, fname2, show2, vfac=1.1, hfac=2.0)</code></pre><p>The variable <code>show1</code> collects not only the Morse sets that are part of the first connection matrix <code>cmr1</code>, but also the support of the Lefschetz complex <code>lcr1</code>. This support is accessed via <code>[lcr1.labels]</code>, and we add it as a first vector of cells in <code>show1</code>. Similarly, we determine the support of the second  isolated invariant set, together with the Morse sets of <code>cmr2</code>. The remaining four commands create two images.</p><p><img src="../img/invariantinterval2d1.png" alt="Interval support for the first interval"/></p><p>The first image shows the five Morse sets surrounding the stationary states at the origin and at <span>$(\pm 1/2, \pm 1/2)$</span>. In addition, it highlights the support of the isolated invariant set associated with this Morse decomposition interval. One can clearly see rough outer approximations for the four heteroclinics which start at the origin and end at the index 1 equilibria. These approximations are necessarily coarse, since we are not working with a very fine triangulation.</p><p><img src="../img/invariantinterval2d2.png" alt="Interval support for the second interval"/></p><p>Finally, the second image depicts the eight Morse sets enclosing the index 1 and the stable stationary states. It also shows the support of the Lefschetz complex <code>lcr2</code> which is associated with this Morse decomposition interval. In this case, it covers eight different heteroclinic orbits, which are in fact better approximated than the four in the previous image.</p><h2 id="Analysis-of-a-Planar-System"><a class="docs-heading-anchor" href="#Analysis-of-a-Planar-System">Analysis of a Planar System</a><a id="Analysis-of-a-Planar-System-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-of-a-Planar-System" title="Permalink"></a></h2><p>Our next example illustrates how <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> can be used to analyze the global dynamics of a planar ordinary differential equations. For this, consider the planar system</p><p class="math-container">\[   \begin{array}{rcl}
     \dot{x}_1 &amp; = &amp;  x_2 - x_1 \left( x_1^2 + x_2^2 - 4 \right)
       \left( x_1^2 + x_2^2 - 1 \right) \\[1ex]
     \dot{x}_2 &amp; = &amp; -x_1 - x_2 \left( x_1^2 + x_2^2 - 4 \right)
       \left( x_1^2 + x_2^2 - 1 \right)
   \end{array}\]</p><p>This system has already been considered in [<a href="../references/#mrozek_etal_22a">MSTW22</a>]. The right-hand side of this vector field can be implemented using the Julia function</p><pre><code class="language-julia hljs">function circlevf(x::Vector{Float64})
    #
    # Sample vector field with nontrivial Morse decomposition
    #
    x1, x2 = x
    c0 = x1*x1 + x2*x2
    c1 = (c0 - 4.0) * (c0 - 1.0)
    y1 =  x2 - x1 * c1
    y2 = -x1 - x2 * c1
    return [y1, y2]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">circlevf (generic function with 1 method)</code></pre><p>To analyze the global dynamics of this vector field, we first create a cubical complex covering the square <span>$[-3, 3]^2$</span> using the commands</p><pre><code class="language-julia hljs">n = 51
lc, coords = create_cubical_rectangle(n,n,p=2);
coordsN = convert_planar_coordinates(coords,[-3.0,-3.0],[3.0,3.0]);
lc.ncells</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10609</code></pre><p>As the last result shows, this gives a Lefschetz complex with 10609 cells. The multivector field can be generated using</p><pre><code class="language-julia hljs">mvf = create_planar_mvf(lc, coordsN, circlevf);
length(mvf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2449</code></pre><p>This multivector field consists of 2437 multivectors. Finally, the  connection matrix can be determined using the command</p><pre><code class="language-julia hljs">cm = connection_matrix(lc, mvf);
cm.conley</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Vector{Int64}}:
 [1, 1, 0]
 [1, 0, 0]
 [0, 1, 1]</code></pre><p>Therefore, the above planar system has three isolated invariant sets. One has the Conley index of a stable equilibrium, while the other two have that of a stable and an unstable periodic orbit. The columns of the connection matrix correspond to these invariant sets as follows</p><pre><code class="language-julia hljs">cm.poset</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Int64}:
 1
 1
 2
 3
 3</code></pre><p>The connection matrix itself is given by</p><pre><code class="language-julia hljs">full_from_sparse(cm.matrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5×5 Matrix{Int64}:
 0  0  0  1  0
 0  0  0  0  1
 0  0  0  1  0
 0  0  0  0  0
 0  0  0  0  0</code></pre><p>This implies that there are connecting orbits from the unstable  periodic orbit to both the stable equilibrium, and the stable periodic orbit. To visualize these Morse sets, we employ the  commands</p><pre><code class="language-julia hljs">fname = &quot;cubicalcircles.pdf&quot;
plot_planar_cubical_morse(lc, fname, cm.morse, pv=true)</code></pre><p><img src="../img/cubicalcircles.png" alt="Morse sets of the planar circles vector field"/></p><p>In the above example we used the original fixed cubical grid, which is just a scaled version of the grid on the integer lattice. It is also possible to work with a <em>randomized grid</em>, in which the coordinates of the vertices are randomly perturbed. This can be achieved with the following commands:</p><pre><code class="language-julia hljs">nR = 75
lcR, coordsR = create_cubical_rectangle(nR,nR,p=2,randomize=0.33);
coordsRN = convert_planar_coordinates(coordsR,[-3.0,-3.0],[3.0,3.0]);
mvfR = create_planar_mvf(lcR, coordsRN, circlevf);
cmR = connection_matrix(lcR, mvfR);
fnameR = &quot;cubicalcirclesR.pdf&quot;
plot_planar_cubical_morse(lcR, coordsRN, fnameR, cmR.morse, pv=true, vfac=1.1, hfac=2.0)</code></pre><p><img src="../img/cubicalcirclesR.png" alt="Morse sets of the planar circles vector field via randomized cubes"/></p><p>To constrast the above example with the use of a Delaunay triangulation, we reanalyze the vector field in the following way:</p><pre><code class="language-julia hljs">lc2, coords2 = create_simplicial_delaunay(400, 400, 10, 30, p=2)
coords2N = convert_planar_coordinates(coords2,[-3.0,-3.0], [3.0,3.0])
mvf2 = create_planar_mvf(lc2, coords2N, circlevf)
cm2 = connection_matrix(lc2, mvf2)

fname2 = &quot;cubicalcircles2.pdf&quot;
plot_planar_simplicial_morse(lc2, coords2N, fname2, cm2.morse, pv=true)</code></pre><p>In this case, the Morse sets can be visualized as in the figure.</p><p><img src="../img/cubicalcircles2.png" alt="Morse sets of the planar circles vector field via Delaunay"/></p><p>Notice that we can also show the individual multivectors in more detail. For the above example, we can plot all multivectors of the multivector field <code>mvf2</code> which consist of at least 10 cells using the commands</p><pre><code class="language-julia hljs">mv_indices = findall(x -&gt; (length(x)&gt;9), mvf2)
large_mv = mvf2[mv_indices]

fname3 = &quot;cubicalcircles3.pdf&quot;
plot_planar_simplicial_morse(lc2, coords2N, fname3, large_mv, pv=true)</code></pre><p><img src="../img/cubicalcircles3.png" alt="Large multivectors in the Delaunay multivector field"/></p><p>Note that in this example, there are only 20 large multivectors.</p><h2 id="Analysis-of-a-Spatial-System"><a class="docs-heading-anchor" href="#Analysis-of-a-Spatial-System">Analysis of a Spatial System</a><a id="Analysis-of-a-Spatial-System-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-of-a-Spatial-System" title="Permalink"></a></h2><p>It is also possible to analyze simple three-dimensional ordinary differential equations in <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a>. To provide one such example, consider the system</p><p class="math-container">\[   \begin{array}{rcl}
     \dot{x}_1 &amp; = &amp; (\lambda-1) x_1 - \frac{3\lambda}{2\pi}
       \left( (x_1^3 - x_1^2 x_3 + x_2^2 x_3 + 2 x_1
       \left( x_2^2 + x_3^2 \right) \right) \\[1ex]
     \dot{x}_2 &amp; = &amp; (\lambda-4) x_2 - \frac{3\lambda}{2\pi} \;
       x_2 \left( 2 x_1^2 + x_2^2 + 2 x_1 x_3 + 2 x_3^2 \right) \\[1ex]
     \dot{x}_3 &amp; = &amp; (\lambda-9) x_3 + \frac{\lambda}{2\pi}
       \left( x_1 \left( x_1^2 - 3 x_2^2 \right) - 3 x_3
       \left( 2 x_1^2 + 2 x_2^2 + x_3^2 \right) \right)
   \end{array}\]</p><p>This system arises in the study of the so-called <em>Allen-Cahn equation</em>, which is the parabolic partial differential equation given by</p><p class="math-container">\[   u_t = \Delta u + \lambda \left( u - u^3 \right)
   \;\;\;\text{ in }\;\;\; \Omega = (0,\pi)
   \quad\text{ with }\quad
   u = 0 \;\;\;\text{ on }\;\;\; \partial\Omega \; .\]</p><p>This partial differential equation can be interpreted as an infinite-dimensional system of ordinary differential equations, see for example [<a href="../references/#sander_wanner_pdebook">SW24</a>, Section 6.1]. For this, one has to expand the unknown function <span>$u(t,\cdot)$</span> as a generalized Fourier series with respect to the basis functions</p><p class="math-container">\[   \varphi_k(x) = \sqrt{\frac{2}{\pi}} \, \sin(k \pi x)
   \quad\text{ for }\quad
   k \in \mathbb{N} \; .\]</p><p>If one truncates this series representation after three terms, and projects the right-hand side of the partial differential equation onto the linear space spanned by the first three basis functions, then the three coefficients of the approximating sum satisfy the above three-dimensional ordinary differential equation. Thus, this system provides a model for the dynamics of the partial differential equation, at least for sufficiently small values of the parameter <span>$\lambda$</span>. It can be implemented in Julia using the following commands:</p><pre><code class="language-julia hljs">function allencahn3d(x::Vector{Float64})
    #
    # Allen-Cahn projection
    #
    lambda = 3.0 * pi
    c      = lambda / pi
    x1, x2, x3 = x
    y1 = (lambda-1)*x1 - 1.5*c * (x1*x1*x1-x1*x1*x3+x2*x2*x3+2*x1*(x2*x2+x3*x3))
    y2 = (lambda-4)*x2 - 1.5*c * x2 * (2*x1*x1+x2*x2+2*x1*x3+2*x3*x3)
    y3 = (lambda-9)*x3 + 0.5*c * (x1*(x1*x1-3*x2*x2)-3*x3*(2*x1*x1+2*x2*x2+x3*x3))
    return [y1, y2, y3]
end</code></pre><p>Notice that for our example we use the parameter value <span>$\lambda = 3\pi$</span>. In this particular case, one can show numerically that the system has seven equilibrium solutions. These are approximately given as follows:</p><ul><li>Two equilibria <span>$\pm(1.45165, \; 0, \; 0.24396)$</span> of index 0.</li><li>Two equilibria <span>$\pm(0, \; 1.09796, \; 0)$</span> of index 1.</li><li>Two equilibria <span>$\pm(0, \; 0, \; 0.307238)$</span> of index 2.</li><li>One equilibrium <span>$(0, \; 0, \; 0)$</span> of index 3.</li></ul><p>In order to find the associated Morse decomposition, one can use the commands</p><pre><code class="language-julia hljs">N = 25
bmax = [1.8, 1.5, 1.0]
lc, coordsI = create_cubical_box(N,N,N);
coordsN = convert_spatial_coordinates(coordsI, -bmax, bmax);
mvf = create_spatial_mvf(lc, coordsN, allencahn3d);</code></pre><p>These commands create a cubical box of size <span>$25 \times 25 \times 25$</span> which covers the region <span>$[-1.8,1.8] \times [-1.5,1.5] \times [-1.0,1.0]$</span>. In addition, we construct a multivector field <code>mvf</code> which encapsulates the possible dynamics of the system. After these preparations, the Morse decomposition can be computed via</p><pre><code class="language-julia hljs">morsedecomp = morse_sets(lc, mvf);
morseinterval = morse_interval(lc, mvf, morsedecomp);
lci, mvfi = restrict_dynamics(lc, mvf, morseinterval);
cmi = connection_matrix(lci, mvfi);</code></pre><p>While the first command finds the actual Morse decomposition, the second one restricts the Lefschetz complex and the multivector field to the smallest isolated invariant set which contains all Morse sets and  connecting orbits between them. The last command finds the connection matrix.</p><p>To see whether the above commands did indeed find the correct dynamical behavior, we first inspect the computed Conley indices of the Morse sets:</p><pre><code class="language-julia hljs">julia&gt; cmi.conley
7-element Vector{Vector{Int64}}:
 [1, 0, 0, 0]
 [1, 0, 0, 0]
 [0, 1, 0, 0]
 [0, 1, 0, 0]
 [0, 0, 1, 0]
 [0, 0, 1, 0]
 [0, 0, 0, 1]</code></pre><p>Clearly, these are the correct indices based on our numerical information  concerning the stationary states of the system. The connection matrix  is given by:</p><pre><code class="language-julia hljs">julia&gt; full_from_sparse(cmi.matrix)
7×7 Matrix{Int64}:
 0  0  1  1  0  0  0
 0  0  1  1  0  0  0
 0  0  0  0  1  1  0
 0  0  0  0  1  1  0
 0  0  0  0  0  0  1
 0  0  0  0  0  0  1
 0  0  0  0  0  0  0</code></pre><p>Thus, there are a total of ten connecting orbits that are induced through algebraic topology. The index 3 equilibrium at the origin has connections to each of the index 2 solutions, which lie above and below the origin in the direction of the <span>$x_3$</span>-axis. Each of the latter two stationary states has connections to both index 1 equilibria. Finally, each of these is connected to both stable states.</p><p><img src="../img/allencahn3d_3_25.png" alt="The dynamics of an Allen-Cahn model"/></p><p>The location of the computed Morse sets is illustrated in the accompanying figure, which uses <span>$x$</span>, <span>$y$</span>, and <span>$z$</span> instead of the variable names <span>$x_1$</span>, <span>$x_2$</span>, and <span>$x_3$</span>, respectively. Notice that while the stationary states of index 0, 2, and 3 are all well-localized, this cannot be said about the two equilibria of index 1. The computed enclosures for the latter two are elongated cubical sets which are shown along the upper left and lower right of the figure. This overestimation is a result of the use of a strict cubical grid, combined with the small discretization size <code>N = 25</code>. Nevertheless, the above simple code does reproduce the overall global dynamical behavior of the ordinary differential equation correctly.</p><p>One can also compute over Morse intervals, rather than the complete Morse decomposition. The final two images show two views of the  Morse interval which corresponds to one of the index 1 equilibria, and the two stable stationary states. These computations were  performed with the finer resolution <code>N = 51</code>.</p><p><img src="../img/acinterval3d_3_51a.png" alt="Allen-Cahn Morse interval, View 1"/></p><p><img src="../img/acinterval3d_3_51b.png" alt="Allen-Cahn Morse interval, View 2"/></p><p>We would like to emphasize that there are many techniques in the literature that can be used to identify isolated invariant sets and their Conley indices. Rather than giving a detailed list, we refer to [<a href="../references/#stephens_wanner_14a">SW14b</a>] and the references  therein. For example, in [<a href="../references/#stephens_wanner_14a">SW14b</a>] ideas from computational topology were used to rigorously establish candidate sets in three dimensions as an isolating block. The associated Matlab code can be found at [<a href="../references/#isoblockval_website">SW14a</a>].</p><h2 id="Forman&#39;s-Morse-Complex"><a class="docs-heading-anchor" href="#Forman&#39;s-Morse-Complex">Forman&#39;s Morse Complex</a><a id="Forman&#39;s-Morse-Complex-1"></a><a class="docs-heading-anchor-permalink" href="#Forman&#39;s-Morse-Complex" title="Permalink"></a></h2><p>The package <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> also provides some support for studying Forman gradient vector fields directly, using the notions introduced in [<a href="../references/#forman_98b">For98b</a>]. In this paper, Forman used the concept of a <em>combinatorial flow</em> <span>$\Phi$</span> to study the forward orbits generated by the Forman vector field. The map <span>$\Phi$</span> is a chain map which is chain homotopic to the identity, and it therefore mimics the concept of a time-1-map associated with a dynamical system. Forman shows that upon iteration this map stabilizes as a map <span>$\Phi^\infty$</span>, which encodes the connecting orbits in the associated combinatorial dynamical system. This <em>stabilized combinatorial flow</em> can then be used to find the connection matrix in this case. For more details, we refer to [<a href="../references/#mrozek_wanner_25a">MW25</a>, Chapter 8]. The combinatorial flow and its stabilized version can be computed using the following two functions.</p><ul><li><a href="../../apicore/conley/#ConleyDynamics.forman_comb_flow"><code>forman_comb_flow</code></a> expects a Lefschetz complex and a Forman vector field as input arguments. It returns matrix representations of Forman&#39;s combinatorial flow <span>$\Phi$</span>, as well as of the associated chain homotopy <span>$\Gamma$</span> between the flow chain map and the identity.</li><li><a href="../../apicore/conley/#ConleyDynamics.forman_stab_flow"><code>forman_stab_flow</code></a> also requires both a Lefschetz complex and a Forman vector field as arguments. It then returns matrix representations of Forman&#39;s stabilized combinatorial flow <span>$\Phi^\infty$</span>, and of the associated chain homotopy <span>$\Gamma^\infty$</span>. This time, there is a third return argument <code>stabilized</code>. This boolean flag indicates whether or not the combinatorial flow stabilized. If it did not, then the returned chain map is the last computed iterate, together with the corresponding chain homotopy. There are two possible reasons for failing stabilization: Either the underlying Forman vector field is not gradient (note that this is not checked!), or the maximal number of iterations has been reached. In the latter case, one just has to pass the optional paramter <code>maxit</code> with a larger number of allowed iterations.</li></ul><p>For analyzing or applying Forman&#39;s combinatorial flow, one needs to work with sparse vector representations of chains. These are elements of the chain groups of the underlying Lefschetz complex, which are then represented as sparse matrices consisting of exactly one column. In this form, they can be multiplied by the matrix of the combinatorial flow, which in turn determines the image of the chain under the flow. In general, these vectors are extremely sparse, and only contain a handfull of nonzero entries. <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> therefore provides the following two functions for the creation and analysis of sparse chain vectors:</p><ul><li><a href="../../apicore/conley/#ConleyDynamics.chain_vector"><code>chain_vector</code></a> is a function that simplifies the creation of a sparse vector representation of a chain. The chain can be specified by simply listing the cells in the support of the chain. If no coefficients are specified, then the chain is just the sum of these cells, each with coefficient <code>1</code>. The function has several associated methods: The coefficients of the chain can be omitted or specified, and the cells can be listed in index or label form. More details can be found in the description of each method.</li><li><a href="../../apicore/conley/#ConleyDynamics.chain_support"><code>chain_support</code></a> extracts the support of a chain given as a sparse vector. In its simplest form, the function returns a <code>Vector{String}</code> which contains the labels of all the cells which have nonzero coefficients in the chain. If one passes the optional parameter <code>coeff=true</code>, then the function returns two arguments: In addition to the vector of labels as above, it also returns the vector of associated coefficients.</li></ul><h2 id="refconley"><a class="docs-heading-anchor" href="#refconley">References</a><a id="refconley-1"></a><a class="docs-heading-anchor-permalink" href="#refconley" title="Permalink"></a></h2><p>See the <a href="../references/#References">full bibliography</a> for a complete list of references cited throughout this documentation. This section cites the following references:</p><div class="citation noncanonical"><dl><dt>[BKMW20]</dt><dd><div>B. Batko, T. Kaczynski, M. Mrozek and T. Wanner. <em>Linking combinatorial and classical dynamics: Conley             index and Morse decompositions</em>. <a href="https://doi.org/10.1007/s10208-020-09444-1">Foundations of Computational Mathematics <strong>20</strong>, 967–1012</a> (2020).</div></dd><dt>[Con78]</dt><dd><div>C. Conley. <em>Isolated Invariant Sets and the Morse Index</em> (American Mathematical Society, Providence, R.I., 1978).</div></dd><dt>[DLMS24]</dt><dd><div>T. K. Dey, M. Lipiński, M. Mrozek and R. Slechta. <em>Computing connection matrices via persistence-like reductions</em>. <a href="https://doi.org/10.1137/23M1562469">SIAM Journal on Applied Dynamical Systems <strong>23</strong>, 81–97</a> (2024).</div></dd><dt>[For98b]</dt><dd><div>R. Forman. <em>Morse theory for cell complexes</em>. <a href="https://doi.org/10.1006/aima.1997.1650">Advances in Mathematics <strong>134</strong>, 90–145</a> (1998).</div></dd><dt>[Fra89]</dt><dd><div>R. Franzosa. <em>The connection matrix theory for Morse decompositions</em>. Transactions of the American Mathematical Society <strong>311</strong>, 561–592 (1989).</div></dd><dt>[HMS21]</dt><dd><div>S. Harker, K. Mischaikow and K. Spendlove. <em>A computational framework for connection matrix theory</em>. <a href="https://doi.org/10.1007/s41468-021-00073-3">Journal of Applied and Computational Topology <strong>5</strong>, 459–529</a> (2021).</div></dd><dt>[LKMW23]</dt><dd><div>M. Lipinski, J. Kubica, M. Mrozek and T. Wanner. <em>Conley-Morse-Forman theory for generalized combinatorial             multivector fields on finite topological spaces</em>. <a href="https://doi.org/10.1007/s41468-022-00102-9">Journal of Applied and Computational Topology <strong>7</strong>, 139–184</a> (2023).</div></dd><dt>[MSTW22]</dt><dd><div>M. Mrozek, R. Srzednicki, J. Thorpe and T. Wanner. <em>Combinatorial vs. classical dynamics: Recurrence</em>. <a href="https://doi.org/10.1016/j.cnsns.2021.106226">Communications in Nonlinear Science and Numerical Simulation <strong>108</strong>, Paper No. 106226, 30 pages</a> (2022).</div></dd><dt>[MW25]</dt><dd><div>M. Mrozek and T. Wanner. <a href="https://doi.org/10.1007/978-3-031-87600-4"><em>Connection Matrices in Combinatorial Topological Dynamics</em></a>. <em>SpringerBriefs in Mathematics</em> (Springer-Verlag, Cham, 2025).</div></dd><dt>[SW24]</dt><dd><div>E. Sander and T. Wanner. <em>Theory and Numerics of Partial Differential Equations</em> (SIAM, Philadelphia, 2024). In preparation, 1007 pages.</div></dd><dt>[SW14a]</dt><dd><div>T. Stephens and T. Wanner. <em>Isolating block validation in Matlab</em>, https://github.com/almost6heads/isoblockval (2014).</div></dd><dt>[SW14b]</dt><dd><div>T. Stephens and T. Wanner. <em>Rigorous validation of isolating blocks for flows and               their Conley indices</em>. <a href="https://doi.org/10.1137/140971075">SIAM Journal on Applied Dynamical Systems <strong>13</strong>, 1847–1878</a> (2014).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../homology/">« Homology</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 18 September 2025 16:19">Thursday 18 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
