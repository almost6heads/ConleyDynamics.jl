<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · ConleyDynamics.jl</title><meta name="title" content="Tutorial · ConleyDynamics.jl"/><meta property="og:title" content="Tutorial · ConleyDynamics.jl"/><meta property="twitter:title" content="Tutorial · ConleyDynamics.jl"/><meta name="description" content="Documentation for ConleyDynamics.jl."/><meta property="og:description" content="Documentation for ConleyDynamics.jl."/><meta property="twitter:description" content="Documentation for ConleyDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ConleyDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ConleyDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Creating-Simplicial-Complexes"><span>Creating Simplicial Complexes</span></a></li><li><a class="tocitem" href="#Computing-Homology-and-Persistence"><span>Computing Homology and Persistence</span></a></li><li><a class="tocitem" href="#Forman-Vector-Fields"><span>Forman Vector Fields</span></a></li><li><a class="tocitem" href="#Isolated-Invariant-Sets"><span>Isolated Invariant Sets</span></a></li><li><a class="tocitem" href="#Connection-Matrices"><span>Connection Matrices</span></a></li><li><a class="tocitem" href="#Multivector-Fields"><span>Multivector Fields</span></a></li><li><a class="tocitem" href="#Analyzing-Planar-Vector-Fields"><span>Analyzing Planar Vector Fields</span></a></li><li><a class="tocitem" href="#Tutorial-References"><span>Tutorial References</span></a></li></ul></li><li><a class="tocitem" href="../lefschetz/">Lefschetz Complexes</a></li><li><a class="tocitem" href="../homology/">Homology</a></li><li><a class="tocitem" href="../conley/">Conley Theory</a></li><li><a class="tocitem" href="../sparse/">Sparse Matrices</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../references/">References</a></li></ul></li><li><span class="tocitem">Core API</span><ul><li><a class="tocitem" href="../../apicore/datastruct/">Composite Data Structures</a></li><li><a class="tocitem" href="../../apicore/utils/">Utility Functions</a></li><li><a class="tocitem" href="../../apicore/plots/">Plotting Functions</a></li><li><a class="tocitem" href="../../apicore/conley/">Conley Theory Functions</a></li><li><a class="tocitem" href="../../apicore/homology/">Homology Functions</a></li><li><a class="tocitem" href="../../apicore/sparse/">Sparse Matrix Functions</a></li><li><a class="tocitem" href="../../apicore/apiindex/">Complete API Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/main/docs/src/man/tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>This tutorial explains the basic usage of the main components of <code>ConleyDynamics.jl</code>.  It is not meant to be exhaustive, and more details will be provided in the more indiviualized sections. Also, precise mathematical definitions will be delayed until then. The presented examples are taken from the papers [<a href="../references/#batko:etal:20a">BKMW20</a>] and [<a href="../references/#mrozek:wanner:p21a">MW23</a>], with minor modifications.</p><h2 id="Creating-Simplicial-Complexes"><a class="docs-heading-anchor" href="#Creating-Simplicial-Complexes">Creating Simplicial Complexes</a><a id="Creating-Simplicial-Complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Simplicial-Complexes" title="Permalink"></a></h2><p>The fundamental mathematical object for <code>ConleyDynamics.jl</code> is a Lefschetz complex [<a href="../references/#lefschetz:42a">Lef42</a>]. For now we note that both simplicial complexes and cubical complexes are special cases, and <code>ConleyDynamics.jl</code> provides convenient interfaces for generating them.</p><p>For the sake of simplicity, this tutorial only considers the case of a simplicial complex. Recall that an <em>abstract simplicial complex</em> <span>$K$</span> is just a collection of finite sets, called <em>simplices</em>, which is closed under taking subsets. In other words, every subset of a simplex is again a simplex. Each simplex <span>$\sigma$</span> has an associated <em>dimension</em> <span>$\dim\sigma$</span>, which is one less than the number of its elements. One usually calls simplices of dimension 0 <em>vertices</em>, <em>edges</em> have dimension 1, and simplices of dimension 2 are <em>triangles</em>. It follows easily from these definitions that every simplex is the union of its vertices.  The following notions associated with simplicial complexes are important for this introduction:</p><ul><li>A <em>face</em> of a simplex is any of its subsets. Notice that every simplex is a face of itself, and it is the only face that has the same dimension as the simplex. Faces whose dimension is strictly smaller are referrred to as <em>proper faces</em>.</li><li>The <em>boundary</em> of a simplex <span>$\sigma$</span> is the collection of all proper faces of <span>$\sigma$</span>. For a triangle, this amounts to all three edges and all three vertices which are part of it.</li><li>A <em>facet</em> of a simplex <span>$\sigma$</span> is any face <span>$\tau$</span> with dimension <span>$\dim\tau = \dim\sigma - 1$</span>. Notice that the facets of a simplex are the faces in its boundary of maximal dimension.</li><li>The <em>closure</em> of a subset <span>$K_0$</span> of a simplicial complex <span>$K$</span> consists of the collection of all faces of simplices in <span>$K_0$</span>, and we denote the closure by <span>$\mathrm{cl}\, K_0$</span>.</li><li>A subset <span>$K_0$</span> of a simplicial complex <span>$K$</span> is called <em>closed</em>, if it equals its closure. In other words, <span>$K_0$</span> is closed if and only if for every simplex <span>$\sigma$</span> in <span>$K_0$</span> all of its boundary simplices are part of <span>$K_0$</span> as well. Thus, a closed subset of a simplicial complex is a simplicial complex in its own right.</li></ul><p>In <code>ConleyDynamics.jl</code> it is easy to generate a simplicial complex. This requires two objects:</p><ul><li>The vertices are described by a vector <code>labels</code> of string labels for the vertices of the simplicial complex. Thus, the length of the vector equals the number of vertices, and the k-th entry is the label for the k-th vertex.</li><li>In addition, a second vector <code>simplices</code> has to describe enough simplices so that the simplicial complex is determined. This object is a vector of vectors, and the vector <code>simplices[k]</code> describes the index values of all the vertices in the k-th simplex. These indices are precisely the corresponding locations of the vertices in <code>labels</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Simplices via labels</header><div class="admonition-body"><p>It is also possible to specify the list of simplices using a <code>Vector{Vector{String}}</code>, i.e., as a vector of string vectors. In this case, the entry <code>simplices[k]</code> is a list of the labels of the vertices.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Watch the label length</header><div class="admonition-body"><p>It is expected that the labels in <code>labels</code> all have the same number of characters. This is due to the fact that when creating the simplicial complex, <code>ConleyDynamics.jl</code> automatically creates  labels for each of the simplices in <span>$K$</span>, by concatenating the vertex labels. Not using a fixed label size could lead to  ambiguities, and will therefore raise an error message.</p></div></div><p><img src="../img/tutorialsimplex.png" alt="A first simplicial complex"/></p><p>The following first example creates a simple simplicial complex.  The complex is shown in the above figure, and it has six vertices which we label by the first six letters.</p><pre><code class="language-julia hljs">labels = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;]
simplices = [[&quot;A&quot;,&quot;B&quot;],[&quot;A&quot;,&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;B&quot;,&quot;D&quot;],[&quot;D&quot;,&quot;E&quot;,&quot;F&quot;]]
sc = create_simplicial_complex(labels,simplices)
fieldnames(typeof(sc))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:ncells, :dim, :boundary, :labels, :indices, :dimensions)</code></pre><p>Based on the simplex specifications, the generated simplicial complex <span>$K$</span> consists of three edges connecting each of the vertices <code>A</code>, <code>B</code>, and <code>C</code>, a two-dimensional triangle <code>DEF</code>, as well as the edge <code>BD</code> which connects the triangle boundary and the filled triangle. The created struct <code>sc</code> is of type <code>LefschetzComplex</code>, with fieldnames as indicated in the above output. The number of cells in the complex can be seen as follows:</p><pre><code class="language-julia hljs">println(sc.ncells)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">14</code></pre><p>Note that the final simplicial complex has a total of seven edges, since also the edges of <code>DEF</code> are part of the simplicial complex. They are automatically generated by <code>create_simplicial_complex</code>. The dimension of <span>$K$</span> is the largest simplex dimensions, and can be recalled via</p><pre><code class="language-julia hljs">println(sc.dim)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><p>The <code>sc</code> struct contains a vector of labels, which in this case takes the form</p><pre><code class="language-julia hljs">println(sc.labels)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;, &quot;BD&quot;, &quot;DE&quot;, &quot;DF&quot;, &quot;EF&quot;, &quot;DEF&quot;]</code></pre><p>Finally, the Lefschetz complex data structure for our simplicial complex <span>$K$</span> includes the dimensions for the corresponding cells in the integer vector <code>sc.dimensions</code>, a dictionary <code>sc.indices</code> which associates each simplex label with its integer index, and the boundary map <code>sc.boundary</code> which will be described in more detail in <a href="../lefschetz/#Lefschetz-Complexes">Lefschetz Complexes</a>. The latter map is internally stored as a sparse matrix over either a finite field or over the rationals. See also the discussion of <a href="../sparse/#Sparse-Matrices">Sparse Matrices</a>.</p><h2 id="Computing-Homology-and-Persistence"><a class="docs-heading-anchor" href="#Computing-Homology-and-Persistence">Computing Homology and Persistence</a><a id="Computing-Homology-and-Persistence-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Homology-and-Persistence" title="Permalink"></a></h2><p>Any simplicial complex, and in fact any Lefschetz complex, has an associated <em>homology</em>. Informally, homology describes the connectivity structure of the simplicial complex. More precisely, the homology consists of a sequence of integers, called the <em>Betti numbers</em>, which are indexed by dimension. There are Betti numbers <span>$\beta_k(K)$</span> for every <span>$k = 0,\ldots,\dim K$</span>. The zero-dimensional Betti number <span>$\beta_0(K)$</span> gives the number of connected components of <span>$K$</span>, while <span>$\beta_1(K)$</span> counts the number of independent loops that can be found in <span>$K$</span>. Finally, <span>$\beta_2(K)$</span> equals the number of cavities. In our case, we have</p><pre><code class="language-julia hljs">homology(sc)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 1
 1
 0</code></pre><p>This means that the simplicial complex <span>$K$</span> has one component, as well as one loop, and no cavities. The function <code>homology</code> returns a vector of integers, whose k-th entry is <span>$\beta_{k-1}(K)$</span>. We would like to point out that in <code>ConleyDynamics.jl</code> all homology computations are performed over fields, and  therefore homology is completely described by the Betti numbers. Two types of fields are supported, and they are selected by the characteristic <code>p</code> in the sparse boundary matrix:</p><ul><li>If <code>p=0</code>, then the homology computation uses the field of rational numbers.</li><li>For any prime number <code>p</code>, homology is determined over the finite field <span>$GF(p)$</span> with <code>p</code> elements. </li></ul><p><code>ConleyDynamics.jl</code> also allows for the computation of <em>relative homology</em>. In the case of relative homology, together with the simplicial complex <span>$K$</span> one has to specify a closed subcomplex <span>$K_0$</span>. Intuitively, the relative homology <span>$H_*(K,K_0)$</span> is the homology of a new space, which is obtained from <span>$K$</span> by identifying <span>$K_0$</span> to a single point, and then decreasing the zero-dimensional Betti number by 1. Consider for example the following command:</p><pre><code class="language-julia hljs">relative_homology(sc, [1,6])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 0
 2
 0</code></pre><p>In this case, the subcomplex <span>$K_0$</span> consists of the two vertices <code>A</code> and <code>F</code>, which are therefore glued together. This leads to zero Betti numbers in dimension 0 and 2 (remember that the zero-dimensional Betti number is decreased by 1!), and a one-dimensional Betti number of 2. The latter is increased by one since we obtain a second loop by moving from <code>A</code> to <code>F = A</code> along the edges <code>AB</code>, <code>BD</code>, and <code>DF</code>.  Another example is the following:</p><pre><code class="language-julia hljs">relative_homology(sc, [&quot;DE&quot;,&quot;DF&quot;,&quot;EF&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 0
 1
 1</code></pre><p>Now the subcomplex <span>$K_0$</span> consists of the edges <code>DE</code>, <code>DF</code>, and <code>EF</code> – together with the three vertices <code>D</code>, <code>E</code>, and <code>F</code> which are automatically added by <code>relative_homology</code>. Identifying them all to one point creates a hollow two-dimensional sphere, and the relative Betti numbers reflect that fact.</p><p>As the above two examples demonstrate, the subcomplex can be specified either as a list of simplex indices, or through the simplex labels.  Moreover, the specfied subspace simplex list is automatically extended by <code>relative_homology</code> to include all simplex faces, i.e., it computes the simplicial closure to arrive at a closed subcomplex. Finally, note that the subcomplex can be empty:</p><pre><code class="language-julia hljs">relative_homology(sc, [])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 1
 1
 0</code></pre><p>As expected, in this case one obtains the standard homology of <code>sc</code>.</p><p>In addition to regular and relative homology, <code>ConleyDynamics.jl</code> can also compute <em>persistent homology</em>. For this, one has to specify a <em>filtration</em> of closed Lefschetz complexes</p><p class="math-container">\[  K_1 \subset K_2 \subset \ldots \subset K_m .\]</p><p>Persistent homology tracks the appearance and disappearance (also often called the <em>birth</em> and <em>death</em>) of topological features as one moves through the complexes in the filtration. In <code>ConleyDynamics.jl</code>, one can specify a Lefschetz complex filtration by assigning the integer <span>$k$</span> to each simplex that first appears in <span>$K_k$</span>. Moreover, it is expected that <span>$K_m = K$</span>. Then the persistent homology is computed via the following command:</p><pre><code class="language-julia hljs">filtration = [1,1,1,2,2,2,1,1,1,3,2,2,2,4]
phsingles, phpairs = persistent_homology(sc, filtration)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([[1], [1], Int64[]], [[(2, 3)], [(2, 4)], Tuple{Int64, Int64}[]])</code></pre><p>The function returns the <em>persistence intervals</em>, which give the birth and death indices of each topological feature in each dimension. There are two types of intervals:</p><ul><li>Intervals of the form <span>$[a,\infty)$</span> correspond to topological features that first appear in <span>$K_a$</span> and are still present in the final complex. The starting indices of such features in dimension <code>k</code> are contained in the list <code>phsingles[k+1]</code>.</li><li>Intervals of the form <span>$[a,b)$</span> correspond to topological features that first appear in <span>$K_a$</span> and first disappear in <span>$K_b$</span>. The corresponding pairs <code>(a,b)</code> in dimension <code>k</code> are contained in the list <code>phpairs[k+1]</code>.</li></ul><p>In our above example, one observes intervals <span>$[1,\infty)$</span> in dimensions zero and one – and these correspond to a connected component and the loop generated by the edges <code>AB</code>, <code>AC</code>, and <code>BC</code>. These appear first in <span>$K_1$</span> and are still present in <span>$K_4$</span>. The interval <span>$[2,3)$</span> in dimension zero represents the new component created by <span>$K_2$</span>, and it disappears through merging with the older component from <span>$K_1$</span> when the edge <code>BD</code> is introduced with <span>$K_3$</span>. Similarly, the interval <span>$[2,4)$</span> in dimension one is the loop created by the triangle <code>DE</code>, <code>DF</code>, and <code>EF</code> in <span>$K_2$</span>, which disappears with the introduction of the triangle <code>DEF</code> in <span>$K_4$</span>. Note that the interval death times respect the <em>elder rule</em>: When for example a component disappears through merging, the younger interval gets killed, and the older one continues to live. Similarly in higher dimensions.</p><h2 id="Forman-Vector-Fields"><a class="docs-heading-anchor" href="#Forman-Vector-Fields">Forman Vector Fields</a><a id="Forman-Vector-Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Forman-Vector-Fields" title="Permalink"></a></h2><p>The main focus of <code>ConleyDynamics.jl</code> is on the study of <em>combinatorial topological dynamics</em> on Lefschetz complexes. While the phase space as Lefschetz complex has been discussed above, albeit only for the special case of a simplicial complex, the dynamics part can be given in the simplest form by a <em>combinatorial vector field</em>, also called a <em>Forman vector field</em> [<a href="../references/#forman:98a">For98a</a>, <a href="../references/#forman:98b">For98b</a>]. We will soon see that such vector fields are a more restrictive version of <em>multivector fields</em>, but they are easier to start with.  The following command defines a simple Forman vector field on our sample simplicial complex <span>$K$</span> from above:</p><pre><code class="language-julia hljs">formanvf = [[&quot;A&quot;,&quot;AC&quot;],[&quot;B&quot;,&quot;AB&quot;],[&quot;C&quot;,&quot;BC&quot;],[&quot;D&quot;,&quot;BD&quot;],[&quot;E&quot;,&quot;DE&quot;]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Vector{String}}:
 [&quot;A&quot;, &quot;AC&quot;]
 [&quot;B&quot;, &quot;AB&quot;]
 [&quot;C&quot;, &quot;BC&quot;]
 [&quot;D&quot;, &quot;BD&quot;]
 [&quot;E&quot;, &quot;DE&quot;]</code></pre><p>The Forman vector field <code>formanvf</code> is viualized in the accompanying figure.</p><p><img src="../img/tutorialforman.png" alt="A first Forman vector field"/></p><p>According to the figure, a Forman vector field is comprised of <em>arrows</em>, as well as <em>critical cells</em> which are indicated by red dots. Every simplex of the underlying simplicial complex is either critical, or it is contained in a unique arrow. In other words, the collection of critical cells and arrows forms a partition of the simplicial complex <span>$K$</span>. Arrows always have to consist of precisely two simplices: The source of the arrow is a simplex <span>$\sigma^-$</span>, while its target is a second simplex <span>$\sigma^+$</span>. These two simplices have to be related in the sense that <span>$\sigma^-$</span> is a facet of <span>$\sigma^+$</span>.</p><p>As the above Julia code shows, a forman vector field is described by a vector of string vectors, where each of the latter contains the labels of the two simplices making up an arrow. Note that the critical cells are not explicitly listed, as any simplex of <span>$K$</span> that is not part of a vector is automatically assumed to be critical. Alternatively, one could define the Forman vector field as a <code>Vector{Vector{Int}}</code>, if the labels are replaced by the corresponding indices in <code>sc.indices</code>.</p><p>Intuitively, the visualization of our sample Forman vector field <code>formanvf</code> induces the following <em>dynamical behavior</em> on the simplicial complex <code>sc</code>:</p><ul><li><strong>Critical cells</strong> can be though of as <em>equilibrium states</em> for the dynamics, i.e., they contain a stationary solution. However, depending on their dimension they can also exhibit nonconstant dynamics – which in backward time converges to the equilibrium, and in forward time flows towards the boundary of the simplex.</li><li><strong>Arrow sources</strong> always lead to flow into the interior of their target simplex <span>$\sigma^+$</span>.</li><li><strong>Arrow targets</strong> create flow towards the boundary of <span>$\sigma^+$</span>, except towards the source facet <span>$\sigma^-$</span>.</li></ul><p>In the above figure, for example, the simplex <code>EF</code> is a critical cell, so it contains an equilibrium. At the same time, it also allows for flow towards the boundary, which consists of the vertices <code>E</code> and <code>F</code>.  A solution flowing to the former then has to enter <code>DE</code>, flow through <code>D</code> to <code>BD</code>, before entering the periodic orbit given by</p><p class="math-container">\[   B \to AB \to A \to AC \to C \to BC \to B \to AB \to \ldots\]</p><p>This heuristic description can be made precise. It was shown in [<a href="../references/#mrozek:wanner:21a">MW21</a>] that for every Forman vector field on a simplicial complex there exists a classical dynamical system which exhibits dynamics consistent with the above interpretation.</p><h2 id="Isolated-Invariant-Sets"><a class="docs-heading-anchor" href="#Isolated-Invariant-Sets">Isolated Invariant Sets</a><a id="Isolated-Invariant-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Isolated-Invariant-Sets" title="Permalink"></a></h2><p>The global dynamical behavior of a Forman vector field on a simplicial complex can be described by first decomposing it into smaller building blocks. An <em>invariant set</em> is a subset <span>$S \subset K$</span> of the simplicial complex such that for every simplex <span>$\sigma \in S$</span> there exists a solution through <span>$\sigma$</span> which is contained in <span>$S$</span> and which exists for all forward and backward time. In our example the following are sample invariant sets:</p><ul><li>Every critical cell <span>$\sigma$</span> by itself is an invariant set, since we can choose the constant solution <span>$\sigma$</span> in the above definition. Thus, also every union of critical cells is invariant.</li><li>The periodic orbit <span>$S_P = \{ A, B, C, AB, AC, BC \}$</span> is an invariant set, since the periodic orbit mentioned earlier exists for all forward and backward time in <span>$S_P$</span> and passes through every simplex of the orbit.</li></ul><p>While it is tempting to try to decompose the dynamics into invariant sets and &quot;everything else&quot;, Conley realized that a better theory can be built around invariant sets which are isolated [<a href="../references/#conley:78a">Con78</a>]. In our combinatorial setting, an <em>isolated invariant set</em> is an invariant set <span>$S \subset K$</span> with the following two additional properties:</p><ul><li>The set <span>$S$</span> is <em>locally closed</em>, i.e., the associated set <span>$\mathrm{mo}\, S = \mathrm{cl}\, S \setminus S$</span> is closed in the simplicial complex. Recall that the closure <span>$\mathrm{cl}\, A$</span> of a set <span>$A \subset K$</span> consists of all simplices which are subsets of simplices in <span>$A$</span>, and a set is closed if it equals its closure. The set <span>$\mathrm{mo}\, S$</span> is called the <em>mouth</em> of <span>$S$</span>.</li><li>The set <span>$S$</span> is <em>compatible</em> with the Forman vector field, i.e., the set is the union of critical cells and arrows. In other words, if one of the  arrow ends is contained in <span>$S$</span>, then so is the other.</li></ul><p>One can easily see that the periodic orbit <span>$S_P$</span> is an isolated invariant set, since it is compatible and closed – and therefore <span>$\mathrm{mo}\, S_P = \emptyset$</span> is closed. Similarly, the single critical simplex <span>$S_1 = \{ DEF \}$</span> is an isolated invariant set, since in this case the set <span>$\mathrm{mo}\, S_1 = \{ D, E, F, DE, DF, EF \}$</span> is closed, and <span>$S_1$</span> is compatible. On the other hand, the invariant set <span>$S_2 = \{ DEF, F \}$</span> is not an isolated invariant set, since the mouth <span>$\mathrm{mo}\, S_2 = \{ D, E, DE, DF, EF \}$</span> is not closed – despite the fact that <span>$S_2$</span> is compatible.  For an example of an invariant set which has a closed mouth but is not compatible, see [<a href="../references/#kaczynski:etal:16a">KMW16</a>, Figure 5].</p><p>It follows from the definition of isolation that for every isolated invariant set <span>$S \subset K$</span> the two sets <span>$\mathrm{cl}\, S$</span> and <span>$\mathrm{mo}\, S$</span> are closed, and that the latter is a (possibly empty) subset of the former. Thus, the relative homology of this pair is defined and we let</p><p class="math-container">\[  CH_*(S) = H_*(\mathrm{cl}\, S, \mathrm{mo}\, S)\]</p><p>denote the <em>Conley index</em> of the isolated invariant set. The Conley index can be computed using the command <code>conley_index</code>. For the three critical cells <code>F</code>, <code>DF</code>, and <code>DEF</code> one obtains the following Conley indices:</p><pre><code class="language-julia hljs">println(conley_index(sc, [&quot;F&quot;]))
println(conley_index(sc, [&quot;DF&quot;]))
println(conley_index(sc, [&quot;DEF&quot;]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[1, 0, 0]
[0, 1, 0]
[0, 0, 1]</code></pre><p>In other words, the Conley index of a critical cell of dimension <span>$k$</span> has Betti number <span>$\beta_k = 1$</span>, while the remaining Betti numbers vanish. This is precisely the relative homology of a <span>$k$</span>-dimensional sphere with respect to a point on the sphere. On the other hand, for the Conley index of the periodic orbit <span>$S_P$</span> one obtains:</p><pre><code class="language-julia hljs">conley_index(sc, [&quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 1
 1
 0</code></pre><p>This Conley index is nontrivial in dimensions <span>$0$</span> and <span>$1$</span>. This is exactly the Conley index of an attracting periodic orbit in classical dynamics.</p><h2 id="Connection-Matrices"><a class="docs-heading-anchor" href="#Connection-Matrices">Connection Matrices</a><a id="Connection-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Connection-Matrices" title="Permalink"></a></h2><p>One of the main features of <code>ConleyDynamics.jl</code> is its capability to take a given combinatorial vector or multivector field on an arbitrary Lefschetz complex and determine its global dynamical behavior. This is done by computing the connection matrix, which in our setting is discussed in detail in [<a href="../references/#mrozek:wanner:p21a">MW23</a>].  For the sample simplicial complex <code>sc</code> and the Forman vector field <code>formanvf</code> the connection matrix information can be determined as follows:</p><pre><code class="language-julia hljs">cm = connection_matrix(sc, formanvf)
fieldnames(typeof(cm))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:matrix, :columns, :poset, :labels, :morse, :conley, :complex)</code></pre><p>This command calculates the connection matrix over the finite field <span>$GF(2) = {\mathbb Z}_2$</span>. The base field for this computation is determined by the data type of the boundary matrix in the underlying simplicial complex <code>sc</code>. By default, if one uses the function <a href="../../apicore/utils/#ConleyDynamics.create_simplicial_complex"><code>create_simplicial_complex</code></a> without specifying the field characteristic <code>p</code>, the simplicial complex is created over the finite field <span>$\mathbb{Z}_2$</span>, i.e., with <code>p=2</code>.</p><p>The <code>connection_matrix</code> function returns a struct which contains the following information regarding the global dynamics of the combinatorial dynamical system:</p><ul><li>The field <code>cm.morse</code> contains the <em>Morse decomposition</em> of the Forman vector field. This is a collection of isolated invariant sets which capture all recurrent behavior. Outside of these sets, the dynamics is gradient-like, i.e., it moves from one Morse set to another.</li><li>Since each of the Morse sets is an isolated invariant set, they all have an associated Conley index. These are contained in the field <code>cm.conley</code>.</li><li>In addition, the struct <code>cm</code> contains information on the actual <em>connection matrix</em> in the field <code>cm.matrix</code>. While the field contains the matrix, the rows and columns of the connection matrix correspond to the simplices in the underlying simplicial complex <code>sc</code> listed in <code>cm.labels</code>. These simplices represent the basis for the homology groups of all the Morse sets. Moreover, a nonzero entry in the connection matrix indicates that there has to be a connecting orbit between the Morse set containing the column label and the Morse set containing the row label.</li></ul><p>The remaining field names of the struct <code>cm</code> are described in the section on <a href="../conley/#Conley-Theory">Conley Theory</a>.</p><p>For our example system, the Morse sets are given by</p><pre><code class="language-julia hljs">cm.morse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Vector{String}}:
 [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;]
 [&quot;F&quot;]
 [&quot;DF&quot;]
 [&quot;EF&quot;]
 [&quot;DEF&quot;]</code></pre><p>There are five of them: The stable periodic orbit <span>$S_P$</span> mentioned earlier, the stable critical state <code>F</code>, the unstable equilibria <code>DF</code> and <code>EF</code>, as well as the two-dimensional unstable critical cell <code>DEF</code>.  The associated Conley indices are</p><pre><code class="language-julia hljs">cm.conley</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Vector{Int64}}:
 [1, 1, 0]
 [1, 0, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 0, 1]</code></pre><p>Clearly these indices are exactly as described in the homology section, since the underlying field is still <span>$\mathbb{Z}_2$</span>, as determined by <code>sc</code>. For an example which involves computations over different fields, which also lead to different Conley indices, we refer to the function <a href="../examples/#ConleyDynamics.example_moebius-Tuple{Int64}"><code>example_moebius</code></a>.</p><p>Finally, the connection matrix itself is contained in <code>cm.matrix</code>. Since internally the connection matrix is stored in a sparse format, we display it after conversion to a full matrix:</p><pre><code class="language-julia hljs">full_from_sparse(cm.matrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6×6 Matrix{Int64}:
 0  0  0  1  1  0
 0  0  0  0  0  0
 0  0  0  1  1  0
 0  0  0  0  0  1
 0  0  0  0  0  1
 0  0  0  0  0  0</code></pre><p>In order to see which simplices represent the columns of the matrix, we use the command</p><pre><code class="language-julia hljs">println(cm.labels)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[&quot;A&quot;, &quot;AC&quot;, &quot;F&quot;, &quot;DF&quot;, &quot;EF&quot;, &quot;DEF&quot;]</code></pre><p>The right-most column contains two nonzero entries, and they imply that there are connecting orbits between the critical cell <code>DEF</code> and the two critical cells <code>DF</code> and <code>EF</code>, respectively. The second-to-last column establishes connecting orbits originating from <code>EF</code>. One of these ends at the critical vertex <code>F</code>, while the other one leads to <code>A</code>. Notice, however, that since <code>A</code> is part of the Morse set <span>$S_P$</span>, i.e., the periodic orbit, this second nonzero entry in the column implies the existence of a heteroclinic orbit between the equilibrium and the complete periodic solution. Similarly, there are connections between <code>DF</code> and both <code>F</code> and the periodic orbit, in view of the fourth column of the connection matrix.</p><p>A description of the remaining fields of <code>cm</code> can also be found in the API entry for <a href="../../apicore/conley/#ConleyDynamics.connection_matrix"><code>connection_matrix</code></a>. We would like to emphasize again that internally, all computations necessary for finding the connection matrix are performed automatically over the rationals or over the finite field <span>$GF(p)$</span>. The choice depends on the data type of the boundary matrix for the underlying Lefschetz complex, in this case the simplicial complex <code>sc</code>. </p><h2 id="Multivector-Fields"><a class="docs-heading-anchor" href="#Multivector-Fields">Multivector Fields</a><a id="Multivector-Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Multivector-Fields" title="Permalink"></a></h2><p>As second example of this tutorial we turn our attention to the logo of <code>ConleyDynamics.jl</code>. It shows a simple multivector field on a simplicial complex, and both the simplicial complex <code>sclogo</code> and the multivector field <code>mvflogo</code> can be defined using the commands</p><pre><code class="language-julia hljs">labels = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;]
simplices = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;,&quot;D&quot;]]
sclogo = create_simplicial_complex(labels,simplices)
mvflogo = [[&quot;A&quot;,&quot;AB&quot;],[&quot;C&quot;,&quot;AC&quot;],[&quot;B&quot;,&quot;BC&quot;,&quot;BD&quot;,&quot;BCD&quot;]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Vector{String}}:
 [&quot;A&quot;, &quot;AB&quot;]
 [&quot;C&quot;, &quot;AC&quot;]
 [&quot;B&quot;, &quot;BC&quot;, &quot;BD&quot;, &quot;BCD&quot;]</code></pre><p>This example is taken from [<a href="../references/#mrozek:wanner:p21a">MW23</a>, Figure 1], and is visualized in the accompanying figure.</p><p><img src="../img/multivectorex.png" alt="The logo multivector field"/></p><p>The multivector field <code>mvflogo</code> clearly has a different structure from the earlier Forman vector field. While the latter consists exclusively of arrows and critical cells, the former is made up of <em>multivectors</em>. In this context a <em>multivector</em> is a collection of simplices which form a locally closed set, as defined earlier in the tutorial. One can show that in the case of a simplicial complex, this is equivalent to requiring that if <span>$\sigma_1 \subset \sigma_2$</span> are two simplices in the multivector, then so are all simplices <span>$\tau$</span> with <span>$\sigma_1 \subset \tau \subset \sigma_2$</span>.  In other words, multivectors are convex with respect to simplex inclusion,  i.e., with respect to the face relation.  A <em>multivector field</em> is then a partition of the simplicial complex into multivectors. See [<a href="../references/#lipinski:etal:23a">LKMW23</a>] for more details.</p><p>It is not difficult to see that every Forman vector field is a multivector field. Every critical cell consists of just one simplex, so it trivially satisfies the above convexity condition. In addition, the two simplices contained in an arrow do not allow for any simplex <span>$\sigma^- \subset \tau \subset \sigma^+$</span> apart from <span>$\tau = \sigma^\pm$</span>.  As in the case of Forman vector fields, multivector fields in <code>ConleyDynamics.jl</code> only need to list multivectors containing at least two simplices. Any simplex not contained on the list automatically gives rise to a one-element multivector.</p><p>One important difference between Forman vector fields and multivector fields is the definition of criticality. In the multivector field case, the types of multivectors are distinguished as follows:</p><ul><li>A multivector <span>$V$</span> is called <em>critical</em>, if the relative homology <span>$H_*(\mathrm{cl}\, V, \mathrm{mo}\, V)$</span> is not trivial, i.e., at least one Betti number is nonzero.</li><li>A multivector <span>$V$</span> is called <em>regular</em>, if the relative homology <span>$H_*(\mathrm{cl}\, V, \mathrm{mo}\, V)$</span> is trivial, i.e., it vanishes in all dimensions.</li></ul><p>One can show that in the case of a Forman vector field, critical cells are always critical in the above sense, while arrows are always regular. In our above example <code>mvflogo</code>, all three multivectors which are not singletons are regular. For example, the following computation shows that the cell <code>ABC</code> is a critical cell:</p><pre><code class="language-julia hljs">cl1, mo1 = lefschetz_clomo_pair(sclogo, [&quot;ABC&quot;])
relative_homology(sclogo, cl1, mo1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 0
 0
 1</code></pre><p>The first command creates the closure-mouth pair associated with the cell <code>ABC</code>, i.e., the variable <code>cl1</code> is the closed triangle, while <code>mo1</code> is the closed boundary of the triangle. The next  command determines the relative homology. Notice that this employs another method under the name <a href="../../apicore/homology/#ConleyDynamics.relative_homology"><code>relative_homology</code></a>, in contrast to the one used earlier in this tutorial. For more details, see <a href="../../apicore/homology/#Homology-Functions">Homology Functions</a>.</p><p>Alternatively, since every multivector is locally closed, one can also use the function <a href="../../apicore/conley/#ConleyDynamics.conley_index"><code>conley_index</code></a> for the same computation:</p><pre><code class="language-julia hljs">conley_index(sclogo, [&quot;ABC&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 0
 0
 1</code></pre><p>Similarly, the next sequence of commands verifies that the third nontrivial multivector <code>mvflogo[3]</code> is indeed a regular multivector:</p><pre><code class="language-julia hljs">cl2, mo2 = lefschetz_clomo_pair(sclogo, mvflogo[3])
relative_homology(sclogo, cl2, mo2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 0
 0
 0</code></pre><p>The global dynamics can again be determined using the function <a href="../../apicore/conley/#ConleyDynamics.connection_matrix"><code>connection_matrix</code></a>:</p><pre><code class="language-julia hljs">cmlogo = connection_matrix(sclogo, mvflogo)
cmlogo.morse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Vector{String}}:
 [&quot;D&quot;]
 [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;, &quot;BD&quot;, &quot;CD&quot;, &quot;BCD&quot;]
 [&quot;ABC&quot;]</code></pre><p>As it turns out, our logo gives rise to three Morse sets, which in fact partition the simplicial complex. Their Conley indices are given by</p><pre><code class="language-julia hljs">cmlogo.conley</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Vector{Int64}}:
 [1, 0, 0]
 [0, 1, 0]
 [0, 0, 1]</code></pre><p>Finally, the connection matrix has the form</p><pre><code class="language-julia hljs">full_from_sparse(cmlogo.matrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 Matrix{Int64}:
 0  0  0
 0  0  1
 0  0  0</code></pre><p>Notice that in this example, only the connection between the Morse set <code>ABC</code> and the large index 1 Morse set comprising almost all  of the simplicial complex can be detected algebraically. In fact, there are two connections between the large Morse set and the stable equilibrium <code>D</code>, and they cancel algebraically.</p><h2 id="Analyzing-Planar-Vector-Fields"><a class="docs-heading-anchor" href="#Analyzing-Planar-Vector-Fields">Analyzing Planar Vector Fields</a><a id="Analyzing-Planar-Vector-Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-Planar-Vector-Fields" title="Permalink"></a></h2><p>Our third and last example of the tutorial briefly indicates how <code>ConleyDynamics.jl</code> can be used to analyze the global dynamics of certain planar ordinary differential equations. For this, consider the planar system given by</p><p class="math-container">\[   \begin{array}{rcl}
     \dot{x}_1 &amp; = &amp; x_1 \left( 1 - x_1^2 - 3 x_2^2 \right) \\[1ex]
     \dot{x}_2 &amp; = &amp; x_2 \left( 1 - 3 x_1^2 - x_2^2 \right)
   \end{array}\]</p><p>The right-hand side of this vector field can be implemented using the Julia function</p><pre><code class="language-julia hljs">function planarvf(x::Vector{Float64})
    #
    # Sample planar vector field with nontrivial Morse decomposition
    #
    x1, x2 = x
    y1 = x1 * (1.0 - x1*x1 - 3.0*x2*x2)
    y2 = x2 * (1.0 - 3.0*x1*x1 - x2*x2)
    return [y1, y2]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">planarvf (generic function with 1 method)</code></pre><p>To analyze the global dynamics of this vector field, we first create a Delaunay triangulation of the square <span>$[-3/2, 3/2]^2$</span> using the commands</p><pre><code class="language-julia hljs">lc, coords = create_simplicial_delaunay(300, 300, 10, 30);
coordsN = convert_planar_coordinates(coords,[-1.5,-1.5], [1.5,1.5]);
cx = [c[1] for c in coordsN];
(minimum(cx), maximum(cx))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(-1.5, 1.5)</code></pre><p>The first command generates the triangulation in a square box with  side length 300, while trying to keep a minimum distance of about 10 between vertices. Once this has been accomplished, the second  command transforms the coordinates to the desired square domain. As the last two commands show, the resulting x-coordinates do indeed lie between -3/2 and 3/2.</p><p>Next we can create a multivector field which describes the flow behavior through the edges of the triangulation. Basically, for each edge which is traversed in only one direction, the corresponding multivector respects this unidirectionality, while non-transverse edges lead to multivectors which allow for flow in both directions between the adjacent triangles. This is achieved with the commands</p><pre><code class="language-julia hljs">mvf = create_planar_mvf(lc, coordsN, planarvf);
mvf[1:3]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Vector{Int64}}:
 [1, 595, 598, 2328]
 [2, 600, 603, 2333]
 [3, 607, 609, 2339]</code></pre><p>The first command generates the multivector field, while the second one merely displays the first three resulting multivectors. Note that if the discretization is too coarse, this might lead to large multivectors that cannot resolve the underlying dynamics. In our case, we can analyze the global dynamics of the created multivector field using the commands</p><pre><code class="language-julia hljs">cm = connection_matrix(lc, mvf);
cm.conley</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Vector{Int64}}:
 [1, 0, 0]
 [1, 0, 0]
 [0, 1, 0]
 [1, 0, 0]
 [1, 0, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 1, 0]
 [0, 0, 1]</code></pre><p>As the output shows, this planar system has nine isolated invariant sets:</p><ul><li>One unstable equilibrium of index 2,</li><li>four unstable equilibria of index 1,</li><li>and four stable equilibria.</li></ul><p>More precisely, this computation does not in fact establish the existence of these equilibria, but of corresponding isolated invariant sets which have the respective Conley indices. The connection matrix is given by</p><pre><code class="language-julia hljs">full_from_sparse(cm.matrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9×9 Matrix{Int64}:
 0  0  1  0  0  0  1  0  0
 0  0  1  0  0  0  0  1  0
 0  0  0  0  0  0  0  0  1
 0  0  0  0  0  1  0  1  0
 0  0  0  0  0  1  1  0  0
 0  0  0  0  0  0  0  0  1
 0  0  0  0  0  0  0  0  1
 0  0  0  0  0  0  0  0  1
 0  0  0  0  0  0  0  0  0</code></pre><p>It shows that there are twelve connecting orbits that are forced by the algebraic topology. Finally, we can visualize the Morse sets using the command</p><pre><code class="language-julia hljs">fname = &quot;tutorialplanar.pdf&quot;
plot_planar_simplicial_morse(lc, coordsN, fname, cm.morse, pv=true)</code></pre><p><img src="../img/tutorialplanar.png" alt="Morse sets of a planar vector field"/></p><h2 id="Tutorial-References"><a class="docs-heading-anchor" href="#Tutorial-References">Tutorial References</a><a id="Tutorial-References-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-References" title="Permalink"></a></h2><p>See the <a href="../references/#References">full bibliography</a> for a complete list of references cited throughout this documentation. This section cites the following references:</p><div class="citation noncanonical"><dl><dt>[BKMW20]</dt><dd><div>B. Batko, T. Kaczynski, M. Mrozek and T. Wanner. <em>Linking combinatorial and classical dynamics: Conley             index and Morse decompositions</em>. <a href="https://doi.org/10.1007/s10208-020-09444-1">Foundations of Computational Mathematics <strong>20</strong>, 967–1012</a> (2020).</div></dd><dt>[Con78]</dt><dd><div>C. Conley. <em>Isolated Invariant Sets and the Morse Index</em> (American Mathematical Society, Providence, R.I., 1978).</div></dd><dt>[For98a]</dt><dd><div>R. Forman. <em>Combinatorial vector fields and dynamical systems</em>. <a href="https://doi.org/10.1007/PL00004638">Mathematische Zeitschrift <strong>228</strong>, 629–681</a> (1998).</div></dd><dt>[For98b]</dt><dd><div>R. Forman. <em>Morse theory for cell complexes</em>. <a href="https://doi.org/10.1006/aima.1997.1650">Advances in Mathematics <strong>134</strong>, 90–145</a> (1998).</div></dd><dt>[KMW16]</dt><dd><div>T. Kaczynski, M. Mrozek and T. Wanner. <em>Towards a formal tie between combinatorial and classical             vector field dynamics</em>. <a href="https://doi.org/10.3934/jcd.2016002">Journal of Computational Dynamics <strong>3</strong>, 17–50</a> (2016).</div></dd><dt>[Lef42]</dt><dd><div>S. Lefschetz. <em>Algebraic Topology</em>. Vol. 27 of <em>American Mathematical Society Colloquium Publications</em> (American Mathematical Society, New York, 1942).</div></dd><dt>[LKMW23]</dt><dd><div>M. Lipinski, J. Kubica, M. Mrozek and T. Wanner. <em>Conley-Morse-Forman theory for generalized combinatorial             multivector fields on finite topological spaces</em>. <a href="https://doi.org/10.1007/s41468-022-00102-9">Journal of Applied and Computational Topology <strong>7</strong>, 139–184</a> (2023).</div></dd><dt>[MW21]</dt><dd><div>M. Mrozek and T. Wanner. <em>Creating semiflows on simplicial complexes from combinatorial vector fields</em>. <a href="https://doi.org/10.1016/j.jde.2021.10.001">Journal of Differential Equations <strong>304</strong>, 375–434</a> (2021).</div></dd><dt>[MW23]</dt><dd><div>M. Mrozek and T. Wanner. <em>Connection matrices in combinatorial topological dynamics</em>, <a href="https://doi.org/10.48550/arXiv.2103.04269">arXiv:2103.04269</a> (2023).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Overview</a><a class="docs-footer-nextpage" href="../lefschetz/">Lefschetz Complexes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Wednesday 24 July 2024 19:53">Wednesday 24 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
