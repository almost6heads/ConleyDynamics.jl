<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lefschetz Complexes · ConleyDynamics.jl</title><meta name="title" content="Lefschetz Complexes · ConleyDynamics.jl"/><meta property="og:title" content="Lefschetz Complexes · ConleyDynamics.jl"/><meta property="twitter:title" content="Lefschetz Complexes · ConleyDynamics.jl"/><meta name="description" content="Documentation for ConleyDynamics.jl."/><meta property="og:description" content="Documentation for ConleyDynamics.jl."/><meta property="twitter:description" content="Documentation for ConleyDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ConleyDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ConleyDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Lefschetz Complexes</a><ul class="internal"><li><a class="tocitem" href="#Basic-Lefschetz-Terminology"><span>Basic Lefschetz Terminology</span></a></li><li><a class="tocitem" href="#Lefschetz-Complex-Data-Structure"><span>Lefschetz Complex Data Structure</span></a></li><li><a class="tocitem" href="#Simplicial-Complexes"><span>Simplicial Complexes</span></a></li><li><a class="tocitem" href="#Cubical-Complexes"><span>Cubical Complexes</span></a></li><li><a class="tocitem" href="#Lefschetz-Complex-Operations"><span>Lefschetz Complex Operations</span></a></li><li><a class="tocitem" href="#reflefschetz"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../homology/">Homology</a></li><li><a class="tocitem" href="../conley/">Conley Theory</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../sparse/">Sparse Matrices</a></li><li><a class="tocitem" href="../references/">References</a></li></ul></li><li><span class="tocitem">Core API</span><ul><li><a class="tocitem" href="../../apicore/datastruct/">Composite Data Structures</a></li><li><a class="tocitem" href="../../apicore/lefschetz/">Lefschetz Complex Functions</a></li><li><a class="tocitem" href="../../apicore/homology/">Homology Functions</a></li><li><a class="tocitem" href="../../apicore/conley/">Conley Theory Functions</a></li><li><a class="tocitem" href="../../apicore/examples/">Example Functions</a></li><li><a class="tocitem" href="../../apicore/plots/">Plotting Functions</a></li><li><a class="tocitem" href="../../apicore/sparse/">Sparse Matrix Functions</a></li><li><a class="tocitem" href="../../apicore/apiindex/">Complete API Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Lefschetz Complexes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lefschetz Complexes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/main/docs/src/man/lefschetz.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lefschetz-Complexes"><a class="docs-heading-anchor" href="#Lefschetz-Complexes">Lefschetz Complexes</a><a id="Lefschetz-Complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Lefschetz-Complexes" title="Permalink"></a></h1><p>The fundamental structure underlying the functionality of <code>ConleyDynamics.jl</code> is a <em>Lefschetz complex</em>. It provides us with the basic model of phase space for combinatorial topological dynamics. In view of the combinatorial, and therefore discrete, character of the dynamical behavior, a Lefschetz complex is not a typical phase space in the sense of classical dynamics. While the latter one is usually a Euclidean space, a Lefschetz complex is basically a combinatorial model of it. In the following, we provide its precise mathematical definition, and explain how it can be created and modified within the package. We also discuss two important special cases, namely <em>simplicial complexes</em> and <em>cubical complexes</em>.</p><h2 id="Basic-Lefschetz-Terminology"><a class="docs-heading-anchor" href="#Basic-Lefschetz-Terminology">Basic Lefschetz Terminology</a><a id="Basic-Lefschetz-Terminology-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Lefschetz-Terminology" title="Permalink"></a></h2><p>The original definition of a Lefschetz complex can be found in [<a href="../references/#lefschetz:42a">Lef42</a>], where it was simply referred to as a <em>complex</em>.</p><div class="admonition is-success"><header class="admonition-header">Definition: Lefschetz complex</header><div class="admonition-body"><p>Let <span>$F$</span> denote an arbitrary field. Then a pair <span>$(X,\kappa)$</span> is called a <em>Lefschetz complex</em> over <span>$F$</span> if <span>$X = (X_k)_{k \in \mathbb{N}_0}$</span> is a finite set with <span>$\mathbb{N}_0$</span>-gradation, and <span>$\kappa : X \times X \to F$</span> is a mapping such that</p><p class="math-container">\[   \kappa(x,y) \neq 0
   \quad\mathrm{ implies }\quad
   x \in X_k
   \quad\mathrm{ and }\quad y \in X_{k-1},\]</p><p>and such that for any <span>$x,z \in X$</span> one has</p><p class="math-container">\[   \sum_{y \in X} \kappa(x,y) \kappa(y,z) = 0 \; .\]</p><p>The elements of <span>$X$</span> are referred to as <em>cells</em>, the value <span>$\kappa(x,y) \in F$</span> is called the <em>incidence coefficient</em> of the cells <span>$x$</span> and <span>$y$</span>, and the map <span>$\kappa$</span> is the <em>incidence coefficient map</em>. In addition, one defines the <em>dimension</em> of a cell <span>$x\in X_k$</span> as the integer <span>$k$</span>, and denotes it by <span>$k = \dim x$</span>. Whenever the incidence coefficient map is clear from context, we often just refer to <span>$X$</span> as the <em>Lefschetz complex</em>.</p></div></div><p>At first glance the above definition can seem daunting. However, it is based on a straightforward geometric idea. A Lefschetz  complex is a structure that is built from elementary building blocks called <em>cells</em>. Each cell has a dimension associated with it, and it is topologically an open ball of this dimension. Thus, cells of dimension zero are points, also called <em>vertices</em>. Cells of dimension one are open curve segments, which we call <em>edges</em>, and two-dimensional cells are called <em>faces</em> and take the form of open two-dimensional membranes.</p><p>The incidence coefficient map encodes how these cells are glued together to form the Lefschetz complex <span>$X$</span>. In order to shed more light on this, consider the <em>boundary map</em> <span>$\partial$</span> which is defined on cells via</p><p class="math-container">\[   \partial x = \sum_{y \in X} \kappa(x,y) y \; .\]</p><p>This map sends a cell <span>$x$</span> of dimension <span>$k$</span> to a specific  linear combination of cells of dimension <span>$k-1$</span>, called the <em>boundary</em> of <span>$x$</span>. By using ideas from linear algebra, the boundary map can be extended to map a general linear combination of <span>$k$</span>-dimensional cells to the corresponding linear combination of the separate boundaries. For example, if one chooses the field <span>$F = \mathbb{Q}$</span> of rationals, one has <span>$\partial  (x_1 - 2x_2) = \partial x_1 - 2 \partial x_2$</span>. Notice that using this extended definition of the boundary map, one can rewrite the summation condition in the definition of a Lefschetz complex in the equivalent form</p><p class="math-container">\[   \partial( \partial x) = 0
   \quad\text{ for all cells }\quad
   x \in X \; .\]</p><p>In other words, the boundary of any cell is itself boundaryless.</p><p>With the help of the boundary map, one can often infer the overall geometric structure of a Lefschetz complex <span>$X$</span>. For this, think of a Lefschetz complex as being build <em>from the ground up</em> in the following way. First, start by putting down all vertices of <span>$X$</span> at different locations in some ambient space. Since the boundary of each one-dimensional cell is made up of a linear combination of vertices, one can then add a curve segment for each one-dimensional cell, which connects the vertices in its boundary. Note that in the general version of a Lefschetz complex it is possible that an edge has only one vertex in its boundary, or maybe even none, and in these cases the edge is either only connected to the one boundary vertex, or it is an open curve segment connected to no vertex at all, respectively. Continue in this fashion to add two-dimensional faces to fill in the space between the edges in its boundary, and so on for higher dimensions. Needless to say, in the case of a general complicated Lefschetz complex this procedure is of limited use, since the boundary of a cell can be an arbitrary linear combination of cells, with coefficients that can be any nonzero numbers in the field <span>$F$</span>. Yet, in many simple cases the above intuition is sufficient.</p><p>In addition to the Lefschetz complex definition, there are a handful of other concepts which will be important for our discussion of Lefschetz complexes. Specifically, the following notions are important:</p><ul><li>A <em>facet</em> of a cell <span>$x \in X$</span> is any cell <span>$y$</span> which satisfies <span>$\kappa(x,y) \neq 0$</span>.</li><li>One can define a partial order on the cells of <span>$X$</span> by letting <span>$x \le y$</span> if and only if for some integer <span>$n \in \mathbb{N}$</span> there exist cells <span>$x = x_1, \ldots, x_n = y$</span> such that <span>$x_k$</span> is a facet of <span>$x_{k+1}$</span> for all <span>$k = 1, \ldots, n-1$</span>. It is not difficult to show that this defines a partial order on <span>$X$</span>, i.e., this relation is reflexive, antisymmetric, and transitive. We call this partial order the <em>face relation</em>.  Moreover, if <span>$x \le y$</span> then <span>$x$</span> is called a <em>face</em> of <span>$y$</span>.</li><li>A subset <span>$C \subset X$</span> of a Lefschetz complex is called <em>closed</em>, if for every <span>$x \in C$</span> all the faces of the cell <span>$x$</span> are also contained in the subset <span>$C$</span>.</li><li>The <em>closure</em> of a subset <span>$C \subset X$</span> is the collection of all faces of all cells in <span>$C$</span>, and it is denoted by <span>$\mathrm{cl}\, C$</span>. Thus, a subset of a Lefschetz complex is closed if and only if it equals its closure.</li><li>A subset <span>$S \subset X$</span> is called <em>locally closed</em>, if its <em>mouth</em> <span>$\mathrm{mo}\, S = \mathrm{cl}\, S \setminus S$</span> is closed. Note that every closed set is automatically locally closed, but the reverse implication is usually false.</li></ul><p>While the first two points merely introduce notation for describing the combinatorial boundary of cells, the remaining three points establish important <em>topological concepts</em>. In fact, the above definition of closedness defines a topology on the Lefschetz complex <span>$X$</span>, which is the so-called <em>Alexandrov topology</em> from [<a href="../references/#alexandrov:37a">Ale37</a>]. As usual in the field of topology, a subset of a Lefschetz complex will be called <em>open</em>, if and only if its complement is closed.</p><p>We would like to point out that while the concept of local closedness is rarely considered in standard topology courses, it is of utmost important for the study of combinatorial topological dynamics. For the moment, we just mention the following result:</p><div class="admonition is-danger"><header class="admonition-header">Theorem: Lefschetz subcomplexes</header><div class="admonition-body"><p>Let <span>$X$</span> be a Lefschetz complex over a field <span>$F$</span>, and let <span>$\kappa : X \times X \to F$</span> denote its incidence coefficient map. Then a subset <span>$S \subset X$</span> is again a Lefschetz complex, with respect to the restriction of <span>$\kappa$</span> to <span>$S \times S$</span>, if and only if the subset <span>$S$</span> is locally closed.</p></div></div><p>This result goes back to [<a href="../references/#mrozek:batko:09a">MB09</a>, Theorem 3.1], where it was shown that local closedness is sufficient. In other words, in the category of Lefschetz complexes local closedness arises naturally. Due to its importance, we also mention the following two equivalent formulations:</p><ul><li>A subset <span>$S \subset X$</span> is locally closed, if and only if it is the difference of two closed subsets of <span>$X$</span>.</li><li>A subset <span>$S \subset X$</span> is locally closed, if and only if it is an interval with respect to the face relation on <span>$X$</span>, i.e., whenever we have three cells with <span>$S \ni x \le y \le z \in S$</span>, then one has to have <span>$y \in S$</span> as well.</li></ul><p>The proof of these characterizations can be found in [<a href="../references/#mrozek:wanner:p21a">MW23</a>, Proposition 3.2] and [<a href="../references/#lipinski:etal:23a">LKMW23</a>, Proposition 3.10], respectively.</p><p>Lefschetz complexes are a very general mathematical concept, and they can be rather confusing at first sight. Nevertheless, they do encompass other complex types, which are more geometric in nature. As we already saw in the tutorial, every <em>simplicial complex</em> is automatically a Lefschetz complex, and we will further elaborate on this connection below. In addition, we will also demonstrate that <em>cubical complexes</em> are Lefschetz complexes. More general, any <em>regular CW complex</em> is  a Lefschetz complex as well. For more details on this, we refer to the definition in [<a href="../references/#massey:91a">Mas91</a>] and the discussion in [<a href="../references/#dlotko:etal:11a">DKMW11</a>].</p><h2 id="Lefschetz-Complex-Data-Structure"><a class="docs-heading-anchor" href="#Lefschetz-Complex-Data-Structure">Lefschetz Complex Data Structure</a><a id="Lefschetz-Complex-Data-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Lefschetz-Complex-Data-Structure" title="Permalink"></a></h2><p>For the efficient and easy manipulation of Lefschetz complexes in <code>ConleyDynamics.jl</code> we make use of a specific composite data type:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ConleyDynamics.LefschetzComplex-man-lefschetz" href="#ConleyDynamics.LefschetzComplex-man-lefschetz"><code>ConleyDynamics.LefschetzComplex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LefschetzComplex</code></pre><p>Collect the Lefschetz complex information in a struct.</p><p>The struct has the following fields:</p><ul><li><code>ncells::Int</code>: Number of cells</li><li><code>dim::Int</code>: Dimension of the complex</li><li><code>boundary::SparseMatrix</code>: Boundary matrix, columns give the cell boundaries</li><li><code>labels::Vector{String}</code>: Vector of labels associated with cell indices</li><li><code>indices::Dict{String,Int}</code>: Dictionary for finding cell index from label</li><li><code>dimensions::Vector{Int}</code>: Vector cell dimensions</li></ul><p>The coefficient field is specified by the boundary matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/fe2a9b575305a85a99bd5c365f411d3eccf97e7f/src/conley/composite_types.jl#L3-L16">source</a></section></article><p>The fields of this struct relate to the mathematical definition of a Lefschetz complex <span>$X$</span> in the following way:</p><ul><li>The integer <code>ncells</code> gives the total number of cells in <span>$X$</span>. Internally, these cells are numbered by integers ranging from <code>1</code> to <code>ncells</code>.</li><li>The vector <code>dimensions</code> is a <code>Vector{Int}</code> and collects the  dimensions of the cells. In other words, the cell which is indexed by the integer <code>k</code> has dimension <code>dimensions[k]</code>.</li><li>The integer <code>dim</code> describes the overall dimension of the Lefschetz complex, which is the largest dimension of a cell.</li><li>The incidence coefficient map <span>$\kappa$</span> is encoded in the sparse matrix <code>boundary</code>. This matrix is a square matrix with <code>ncells</code>  rows and columns. The <span>$k$</span>-th column contains the incidence coefficients <span>$\kappa(k,\cdot)$</span> in the sense that the entry in row <span>$m$</span> and column <span>$k$</span> equals the value <span>$\kappa(k,m)$</span>. Since for most Lefschetz complexes the majority of the incidence coefficients is zero, the matrix is represented using the sparse format <a href="../../apicore/sparse/#ConleyDynamics.SparseMatrix"><code>SparseMatrix</code></a>, which is described in more detail in <a href="../sparse/#Sparse-Matrices">Sparse Matrices</a>.</li><li>While the internal representation of cells as integers is  computationally convenient, it does make interpreting the results more difficult. Each Lefschetz complex therefore has to have string labels assigned to each cell as well. These are contained in <code>labels::Vector{String}</code>, where <code>labels[k]</code> gives the label of cell <code>k</code>.</li><li>In order to easily determine the integer index for a cell with a specific label, the field <code>indices</code> contains a dictionary of type <code>Dict{String,Int}</code> which maps labels to indices. For  example, if a cell has the label <code>&quot;124.010&quot;</code>, then the associated integer index is given by <code>indices[&quot;124.010&quot;]</code>.</li></ul><p>An object of type <code>LefschetzComplex</code> is created by passing the field items in the order given in <a href="../../apicore/datastruct/#ConleyDynamics.LefschetzComplex"><code>LefschetzComplex</code></a>. Consider for example the Lefschetz complex from Figure 4 in [<a href="../references/#mrozek:wanner:p21a">MW23</a>], see also the left complex in the next image. This complex consists of six cells with labels <code>A</code>,  <code>B</code>, <code>a</code>, <code>b</code>, <code>c</code>, and <code>alpha</code>, and we initialize the vector of labels, the cell index dictionary, and the cell dimensions via the commands</p><pre><code class="language-julia hljs">ncL = 6
labelsL  = Vector{String}([&quot;A&quot;,&quot;B&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;alpha&quot;])
indicesL = Dict{String,Int}([(labelsL[k],k) for k in 1:length(labelsL)])
cdimsL   = [0, 0, 1, 1, 1, 2]</code></pre><p>The boundary matrix can then be defined using</p><pre><code class="language-julia hljs">bndmatrixL = zeros(Int, ncL, ncL)
bndmatrixL[[1,2],3] = [1; 1]     # a
bndmatrixL[[1,2],4] = [1; 1]     # b
bndmatrixL[[1,2],5] = [1; 1]     # c
bndmatrixL[[3,4],6] = [1; 1]     # alpha
bndsparseL = sparse_from_full(bndmatrixL, p=2)</code></pre><p>Notice that we first create the matrix as a regular integer  matrix, and then use the function <a href="../../apicore/sparse/#ConleyDynamics.sparse_from_full"><code>sparse_from_full</code></a>  to turn it into sparse format over the field <span>$GF(2)$</span> with characteristic <code>p = 2</code>. This is the most convenient method for small boundary matrices, yet for larger ones it is better to use the function <a href="../../apicore/sparse/#ConleyDynamics.sparse_from_lists"><code>sparse_from_lists</code></a>. Finally, the Lefschetz complex is created using</p><pre><code class="language-julia hljs">lcL = LefschetzComplex(ncL, 2, bndsparseL, labelsL, indicesL, cdimsL)</code></pre><p><img src="../img/lefschetzex1.png" alt="Two sample Lefschetz complexes"/></p><p>Lefschetz complexes do not always have to contain cells of all dimensions. For example, the Lefschetz complex shown on the right side of the figure has no vertices, and it can be created using the commands</p><pre><code class="language-julia hljs">ncR = 4
labelsR  = Vector{String}([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;alpha&quot;])
indicesR = Dict{String,Int}([(labelsR[k],k) for k in 1:length(labelsR)])
cdimsR   = [1, 1, 1, 2]
bndmatrixR = zeros(Int, ncR, ncR)
bndmatrixR[[1,2,3],4] = [1; 1; 1]     # alpha
bndsparseR = sparse_from_full(bndmatrixR, p=2)
lcR = LefschetzComplex(ncR, 2, bndsparseR, labelsR, indicesR, cdimsR)</code></pre><p>While Lefschetz complexes can always be created in <code>ConleyDynamics.jl</code> in this direct way, it is often more convenient to make use of special types, such as simplicial and cubical complexes, and then restrict the complex to a locally closed set using the function <a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_subcomplex"><code>lefschetz_subcomplex</code></a>.</p><h2 id="Simplicial-Complexes"><a class="docs-heading-anchor" href="#Simplicial-Complexes">Simplicial Complexes</a><a id="Simplicial-Complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Simplicial-Complexes" title="Permalink"></a></h2><p>One of the earliest types of complexes that have been studied in  topology are <em>simplicial complexes</em>. As already mentioned in the tutorial, an <em>abstract simplicial complex</em> <span>$X$</span> is a finite collection of finite sets, called <em>simplices</em>, which is closed under taking subsets. Each simplex <span>$\sigma$</span> has a <em>dimension</em> <span>$\dim\sigma$</span>, which is one less than the number of its elements.</p><p>In order to see why every simplicial complex is automatically a  Lefschetz complex, we need to be able to define the incidence  coefficient map <span>$\kappa$</span>. For this, we make use of some notions from [<a href="../references/#munkres:84a">Mun84</a>]. Let <span>$X_0$</span> denote the collection of all vertices of the simplicial complex <span>$X$</span>. Then we use the notation</p><p class="math-container">\[   \sigma = \left[ v_0, v_1, \ldots, v_d \right]
   \quad\text{ with }\quad
   v_k \in X_0\]</p><p>to describe a <span>$d$</span>-dimensional simplex. Note that even though every simplex in <span>$X$</span> is just the set of its vertices, in the above  representation we pick an order of the vertices, called an <em>orientation</em> of the simplex. This orientation can be chosen arbitrarily, and there are two equivalence classes of orientations. To get from one orientation to the other, one just has to exchange two vertices, and we write</p><p class="math-container">\[   \left[ \ldots, v_i, \ldots, v_j, \ldots \right] \; = \;
   -\left[ \ldots, v_j, \ldots, v_i, \ldots \right] \; .\]</p><p>For more complicated reorderings, one has to represent the corresponding vertex permutation as a sequence of such exchanges. Using these oriented simplices we can define the boundary operator</p><p class="math-container">\[   \partial \sigma \; = \;
   \partial \left[ v_0, \ldots, v_d \right] \; = \;
   \sum_{i=0}^d (-1)^i \left[ v_0, \ldots, \hat{v}_i,
     \ldots, v_d \right] \; ,\]</p><p>where the notation <span>$\hat{v}_i$</span> means that in the simplex behind the summation sign on the right-hand side the vertex <span>$v_i$</span> is omitted. For example, for a two-dimensional simplex one obtains</p><p class="math-container">\[   \partial \left[ v_0, v_1, v_2 \right] \; = \;
   \left[ v_1, v_2 \right] - 
   \left[ v_0, v_2 \right] + 
   \left[ v_0, v_1 \right] \; .\]</p><p>Thus, if one chooses a total order of all the vertices in the simplicial complex, and orients the individual simplices in such a way that their vertices are arranged using this overall order, then the incidence coefficient map is given by</p><p class="math-container">\[   \kappa \left( \left[ v_0, \ldots, v_i, \ldots, v_d \right], \;
     \left[ v_0, \ldots, \hat{v}_i, \ldots, v_d \right] \right)
   \; = \; (-1)^i \; .\]</p><p>If some or all of the simplices are represented by different orientations, one simply has to multiply the value <span>$(-1)^i$</span> by the sign of a suitable vertex permutation. In either case, one can show that the so-defined map <span>$\kappa$</span> does indeed satisfy the definition of a Lefschetz complex. For more details, see [<a href="../references/#munkres:84a">Mun84</a>, Lemma 5.3].</p><p>In <code>ConleyDynamics.jl</code> there are three basic commands for defining a simplicial complex:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.create_simplicial_complex"><code>create_simplicial_complex</code></a> is the most general method, and it expects two input arguments. The first is usually called <code>labels</code>, and  it has to have the data type <code>Vector{String}</code>. This vector lists the labels for each vertex. It is important that all of these labels have exactly the same number of characters. The second argument is usually called <code>simplices</code>, and it lists as many simplices as necessary for defining the underlying simplicial complex. This means that in practice one only needs to include the simplices which are not faces of higher-dimensional ones, see also the example below. The variable <code>simplices</code> can either be of type <code>Vector{Vector{String}}</code> or <code>Vector{Vector{Int}}</code>, depending on whether the vertices are identified via their labels or integer indices, respectively. Finally, the optional parameter <code>p</code> can be used to specify the underlying field for the  boundary matrix. If <code>p</code> is a prime, then <span>$F = GF(p)$</span>, while for <code>p = 0</code> the function uses <span>$F = \mathbb{Q}$</span>. If the argument <code>p</code> is ommitted, the function defaults to <code>p = 2</code>.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.create_simplicial_rectangle"><code>create_simplicial_rectangle</code></a> expects two integer arguments <code>nx</code> and <code>ny</code>, and then creates a triangulation of the square <span>$[0,nx] \times [0,ny]$</span> by subdividing every unit square into four triangles which meet at the center of the square. As before, the optional parameter <code>p</code> specifies the underlying field.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.create_simplicial_delaunay"><code>create_simplicial_delaunay</code></a> creates a planar Delaunay triangulation inside a planar rectangle. The function selects a random sample of points inside the box, while either trying to maintain a minimum distance between the points, or just using a prespecified number of points. More details on these two options can be found in the documentation for the function.</li></ul><p>To illustrate the first of these functions, consider the commands</p><pre><code class="language-julia hljs">labels = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;]
simplices = [[&quot;A&quot;,&quot;B&quot;],[&quot;A&quot;,&quot;F&quot;],[&quot;B&quot;,&quot;F&quot;],[&quot;B&quot;,&quot;C&quot;,&quot;G&quot;],[&quot;D&quot;,&quot;E&quot;,&quot;H&quot;],[&quot;C&quot;,&quot;D&quot;],[&quot;G&quot;,&quot;H&quot;]]
sc = create_simplicial_complex(labels,simplices)</code></pre><p>These create the simplicial complex <code>sc</code>, in the form of a  Lefschetz complex. Note that the above commands only specify the labels for the vertices. The labels for simplices of dimension at least one are automatically generated by concatenating the labels for their vertices, sorted in lexicographic order. This can be seen in the following Julia output:</p><pre><code class="language-julia hljs">julia&gt; sc.labels[end-4:end]
5-element Vector{String}:
 &quot;DH&quot;
 &quot;EH&quot;
 &quot;GH&quot;
 &quot;BCG&quot;
 &quot;DEH&quot;</code></pre><p>The simplicial complex <code>sc</code> can be visualized using the commands</p><pre><code class="language-julia hljs">coords = [[0,0],[2,0],[4,0],[6,0],[8,0],[1,2],[4,2],[6,2]]
ldir   = [3,3,3,3,3,1,1,1]
fname  = &quot;lefschetzex2.pdf&quot;
plot_planar_simplicial(sc,coords,fname,labeldir=ldir,labeldis=10,hfac=2,vfac=1.5,sfac=50)</code></pre><p><img src="../img/lefschetzex2.png" alt="First sample simplicial complex"/></p><p>Similarly, the commands</p><pre><code class="language-julia hljs">sc2, coords2 = create_simplicial_rectangle(5,2)
fname2 = &quot;lefschetzex3.pdf&quot;
plot_planar_simplicial(sc2,coords2,fname2,hfac=2.0,vfac=1.2,sfac=75)</code></pre><p>define and illustrate a second simplicial complex, which triangularizes a rectangle in the plane.</p><p><img src="../img/lefschetzex3.png" alt="Second sample simplicial complex"/></p><p>For a demonstration of the Delaunay triangulation approach, please see <a href="../tutorial/#Analyzing-Planar-Vector-Fields">Analyzing Planar Vector Fields</a>.</p><h2 id="Cubical-Complexes"><a class="docs-heading-anchor" href="#Cubical-Complexes">Cubical Complexes</a><a id="Cubical-Complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Cubical-Complexes" title="Permalink"></a></h2><p>The second important special case of a Lefschetz complex is called <em>cubical complex</em>, and it has been discussed in detail in [<a href="../references/#kaczynski:etal:04a">KMM04</a>]. In the following, we only present the definitions that are essential for our purposes.</p><p>Loosely speaking, a cubical complex is a collection of cubes of varying dimensions in some Euclidean space <span>$\mathbb{R}^d$</span>. More precisely, we say that an interval <span>$I \subset \mathbb{R}$</span> is an <em>elementary interval</em> if it is of the form</p><p class="math-container">\[   I = [\ell, \ell+1]
   \quad\text{ or }\quad
   I = [\ell, \ell]
   \quad\text{ for some integer }\quad
   \ell \in \mathbb{Z} \; .\]</p><p>If the elementary interval <span>$I$</span> consists of only one point, then it is called <em>degenerate</em>, and it is <em>nondegenerate</em> if it is of length one. Elementary intervals are the building blocks for the cubes in a cubical complex. For a complex in <span>$\mathbb{R}^d$</span>, an <em>elementary cube</em> <span>$Q$</span> is of the form</p><p class="math-container">\[   Q \; = \;
   I_1 \times I_2 \times \ldots \times I_d \; \subset \;
   \mathbb{R}^d \; ,\]</p><p>where <span>$I_1, \ldots, I_d$</span> are elementary intervals. The <em>dimension</em> <span>$\dim Q$</span> of an elementary cube is given by the number of nondegenerate intervals in its representation. For example, the cube <span>$Q = [0,0]  \times [1,1]$</span> is a zero-dimensional elementary cube in <span>$\mathbb{R}^2$</span> which contains only the point <span>$(0,1)$</span>, while the elementary cube <span>$R = [2,2] \times [3,4]$</span> is one-dimensional, and consists of the  closed vertical line segment between the points <span>$(2,3)$</span> and <span>$(2,4)$</span>.</p><p>After these preparations, the definition of a cubical complex is now straightforward. A <em>cubical complex</em> <span>$X$</span> in <span>$\mathbb{R}^d$</span> is a finite collection of elementary cubes in <span>$\mathbb{R}^d$</span> which is closed under the inclusion of elementary subcubes. More precisely, if <span>$Q \in X$</span> is an elementary cube in the cubical complex, and if <span>$R \subset Q$</span> is any elementary cube contained in <span>$Q$</span>, then one also has <span>$R \in X$</span>.</p><p>The definition of a cubical complex is reminiscent of that of a simplicial complex. It is therefore not surprising that also in the cubical case one can describe the incidence coefficient map <span>$\kappa$</span> explicitly, and thus recognize a cubical complex as a Lefschetz complex. For this, we need more notation.</p><p>Let <span>$Q = I_1 \times I_2 \times \ldots \times I_d$</span> denote an elementary cube, and let the nondegenerate elementary intervals in this decomposition be given by <span>$I_{i_1}, \ldots, I_{i_n}$</span>, where <span>$I_{i_j} = [k_j, k_j + 1]$</span> and <span>$j = 1,\ldots,n = \dim Q$</span>. For every index <span>$j$</span>, we further define the two <span>$(n-1)$</span>-dimensional elementary cubes</p><p class="math-container">\[   \begin{array}{ccccccc}
   Q_j^- &amp; = &amp; I_1 \times \ldots \times I_{i_j - 1} &amp; \times &amp;
           [k_j, k_j] &amp; \times &amp; I_{i_j + 1} \times \ldots
           \times I_d \; , \\[2ex]
   Q_j^+ &amp; = &amp; I_1 \times \ldots \times I_{i_j - 1} &amp; \times &amp;
           [k_j + 1, k_j + 1] &amp; \times &amp; I_{i_j + 1} \times
           \ldots \times I_d \; .
   \end{array}\]</p><p>Geometrically, the two elementary cubes <span>$Q_j^-$</span> and <span>$Q_j^+$</span> are directly opposite sides of the elementary cube <span>$Q$</span>. Using them, one can define the algebraic <em>boundary</em> of the cube as</p><p class="math-container">\[   \partial Q \; = \;
   \sum_{j=1}^n (-1)^{j-1} \left( Q_j^+ - Q_j^- \right) .\]</p><p>This formula is the cubical analogue of the boundary operator in a simplicial complex, and it allows us to define the incidence coefficient map via</p><p class="math-container">\[   \kappa\left( Q, \, Q_j^+ \right) \; = \; (-1)^{j-1}
   \quad\text{ and }\quad
   \kappa\left( Q, \, Q_j^- \right) \; = \; (-1)^j \; ,
   \quad\text{ for all }\quad
   j = 1, \ldots, n \; .\]</p><p>For all remaining pairs of elementary cubes in <span>$X$</span> we let <span>$\kappa = 0$</span>. Then it was shown in [<a href="../references/#kaczynski:etal:04a">KMM04</a>, Proposition 2.37] that the so-defined incidence coefficient map satisfies the summation condition in the definition of a Lefschetz complex, i.e., we have <span>$\partial(\partial Q) = 0$</span> for every <span>$Q \in X$</span>. This in turn implies that every cubical complex is indeed a Lefschetz complex.</p><p>Cubical complexes in <code>ConleyDynamics.jl</code> are a little more restricted. Since a cubical complex in the above sense is always finite, one can assume without loss of generality that the left endpoints of all involved elementary intervals are nonnegative. In other words, we always assume that the cubical complex only contains elementary cubes from the set <span>$(\mathbb{R}_0^+)^d$</span>. This allows for a simple encoding of elementary cubes via labels of a fixed length, and without having to worry about the sign of an integer.</p><p>To describe this, fix a dimension <span>$d$</span> of the ambient space. Then every elementary cube in <span>$(\mathbb{R}_0^+)^d$</span> has the following label, which depends on a <em>coordinate width</em> <span>$L$</span>:</p><ul><li>The first <span>$d \cdot L$</span> characters of the label encode the  starting points of the elementary intervals <span>$I_1, \ldots, I_d$</span> in the standard representation of the elementary cube. For this, the starting points, which are nonnegative integers, are concatenated without spaces, but with leading zeros. For example, with <span>$L = 2$</span> the string <code>&quot;010203&quot;</code> would correspond to the starting points <span>$1$</span>, <span>$2$</span>, and <span>$3$</span>. Note that for given coordinate width <span>$L$</span>, one can only encode starting points between <span>$0$</span> and <span>$10^L-1$</span>.</li><li>The next entry in the label string is a period <code>.</code>.</li><li>The remaining <span>$d$</span> characters of the string are integers 0 or 1, which give the interval lengths of <span>$I_1, \ldots, I_d$</span>.</li></ul><p>For example, for <span>$L = 2$</span> the string <code>&quot;030600.000&quot;</code> corresponds to the point <span>$(3,6,0)$</span> in three dimensions. Similarly, the label <code>&quot;030600.101&quot;</code> represents the two-dimensional elementary cube <span>$[3,4] \times [6,6] \times [0,1] \subset \mathbb{R}^3$</span>. Note, however, that the label representation is not unique, since it depends on the coordinate width <span>$L$</span>. Thus, with <span>$L = 1$</span> the latter cube could also be written as <code>&quot;360.101&quot;</code>, or with <span>$L = 3$</span> as <code>&quot;003006000.101&quot;</code>. As we will see in a moment, though, <strong>within a given cubical complex all labels have to use the same coordinate width</strong> <span>$L$</span>! This implies in particular that for a given coordinate width <span>$L$</span> one can only represent bounded cubical complexes which are contained in the <span>$d$</span>-dimensional box <span>$[0,10^L-1]^d$</span>.</p><p>The following three helper functions simplify the work with these types of cube labels:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.cube_field_size"><code>cube_field_size</code></a> determines the field sizes of a given cube label. The first return value gives the dimension <span>$d$</span> of the ambient space, while the second value returns the coordinate width <span>$L$</span>.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.cube_information"><code>cube_information</code></a> returns all information encoded in the cube label. The function returns an integer vector of length <span>$2d+1$</span>, where <span>$d$</span> is the dimension of the ambient space. The first <span>$d$</span> entries give the vector of elementary interval starting points, while the next <span>$d$</span> values yield the corresponding interval lengths. The last entry specifies the dimension of the cube.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.cube_label"><code>cube_label</code></a> creates a label from a cube&#39;s coordinate information. As function parameters, one has to specify <span>$d$</span> and <span>$L$</span>, and then pass an integer vector of length six which specifies the coordinates of the starting points and the interval lengths as in the previous item.</li></ul><p>In <code>ConleyDynamics.jl</code> there are four basic commands for defining a cubical complex and working with it:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.create_cubical_complex"><code>create_cubical_complex</code></a> creates a cubical complex in the Lefschetz complex data format. The complex is specified via a list of all the highest-dimensional cubes which are necessary to define the cubical complex. For this, every cube has to be given using the above-described special label format, with the same coordinate width <span>$L$</span>. In other words, all label strings have to be of the same length! If the optional parameter <code>p</code> is specified, the complex will be defined over a field with characteristic <code>p</code>, analogous to the case of a simplicial complex. If the characteristic is not specified, then the function defaults to the field <span>$GF(2)$</span>.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.get_cubical_coords"><code>get_cubical_coords</code></a> determines the coordinates of all  vertices of a given cubical complex from the cube labels. This vector can then be used for plotting purposes, see below.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.create_cubical_rectangle"><code>create_cubical_rectangle</code></a> creates a cubical complex covering a rectangle in the plane. The rectangle is given by the subset <span>$[0,nx] \times [0,ny]$</span> of the plane, where the nonnegative integers <code>nx</code> and <code>ny</code> have to be passed as arguments to the function. The function returns the cubical complex, and a vector of coordinates for the vertices. The latter can also be randomly perturbed as described in more detail in the function documentation.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.create_cubical_box"><code>create_cubical_box</code></a> creates a cubical complex covering a box in three-dimensional Euclidean space. The box is given by the subset <span>$[0,nx] \times [0,ny] \times [0,nz]$</span> of space, where the nonnegative integers <code>nx</code>, <code>ny</code>, and <code>nz</code> have to be passed as arguments to the function. The optional parameters are the same as in the planar version.</li></ul><p>To illustrate the first of these functions, consider the commands</p><pre><code class="language-julia hljs">cubes = [&quot;00.11&quot;, &quot;01.01&quot;, &quot;02.10&quot;, &quot;11.10&quot;, &quot;11.01&quot;, &quot;22.00&quot;, &quot;20.11&quot;, &quot;31.01&quot;]
cc = create_cubical_complex(cubes)</code></pre><p>These create the cubical complex <code>cc</code>, in the form of a  Lefschetz complex. It can be visualized using the commands</p><pre><code class="language-julia hljs">coords = get_cubical_coords(cc)
fname  = &quot;lefschetzex4.pdf&quot;
plot_planar_cubical(cc,coords,fname,hfac=2.2,vfac=1.1,cubefac=60)</code></pre><p><img src="../img/lefschetzex4.png" alt="First sample cubical complex"/></p><p>Similarly, the commands</p><pre><code class="language-julia hljs">cc2, coords2 = create_cubical_rectangle(5,2)
fname2 = &quot;lefschetzex5.pdf&quot;
plot_planar_cubical(cc2,coords2,fname2,hfac=1.7,vfac=1.2,cubefac=75)</code></pre><p>define and illustrate a second cubical complex.</p><p><img src="../img/lefschetzex5.png" alt="Second sample cubical complex"/></p><p>Finally, it is also possible to perturb the vertices in a cubical rectangle to obtain a Lefschetz complex consisting of quadrilaterals in the plane. This can be accomplied as follows:</p><pre><code class="language-julia hljs">cc3, coords3 = create_cubical_rectangle(5,2,randomize=0.2)
fname3 = &quot;lefschetzex6.pdf&quot;
plot_planar_cubical(cc3,coords3,fname3,hfac=1.7,vfac=1.2,cubefac=75)</code></pre><p>The resulting Lefschetz complex is visualized in the last figure of this section.</p><p><img src="../img/lefschetzex6.png" alt="A randomly perturbed cubical complex"/></p><h2 id="Lefschetz-Complex-Operations"><a class="docs-heading-anchor" href="#Lefschetz-Complex-Operations">Lefschetz Complex Operations</a><a id="Lefschetz-Complex-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Lefschetz-Complex-Operations" title="Permalink"></a></h2><p>Once a Lefschetz complex has been created, there are a number of manipulations and queries that one has to be able to perform on the complex. At the moment, <code>ConleyDynamics.jl</code> supplies a number of functions for this. The following three functions  provide <em>basic information</em>:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_field"><code>lefschetz_field</code></a> returns the field <span>$F$</span> over which the Lefschetz complex is defined as a <code>String</code>.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_is_closed"><code>lefschetz_is_closed</code></a> determines whether a given Lefschetz complex cell subset is closed or not.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_is_locally_closed"><code>lefschetz_is_locally_closed</code></a> checks whether a given Lefschetz complex cell subset is locally closed or not.</li></ul><p>The next set of functions can be used to extract certain <em>topological features</em> from a Lefschetz complex:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_boundary"><code>lefschetz_boundary</code></a> computes the support of the boundary <span>$\partial\sigma$</span> of a Lefschetz complex cell <span>$\sigma$</span>. In other words, it returns the vector of all facets of <span>$\sigma$</span>. The cell can either be specified via its index or its label, and the return format corresponds to the input format.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_coboundary"><code>lefschetz_coboundary</code></a> returns all cells which lie in the coboundary of the specified cell <span>$\sigma$</span>, i.e., it returns all cells which have <span>$\sigma$</span> as a facet.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_closure"><code>lefschetz_closure</code></a> determines the closure of a  given cell subset, i.e., the union of all faces of cells in the cell subset.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_openhull"><code>lefschetz_openhull</code></a> computes the open hull of a cell subset, i.e., the smallest open set which contains the given cell subset.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_lchull"><code>lefschetz_lchull</code></a> finds the locally closed hull of a Lefschetz complex subset. This is the smallest locally closed set which contains the given cell subset. One can show that  it is the intersection of the closure and the open hull of the cell subset.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_clomo_pair"><code>lefschetz_clomo_pair</code></a> determines the closure-mouth-pair associated with a Lefschetz complex subset.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_skeleton"><code>lefschetz_skeleton</code></a> computes the <span>$k$</span>-dimensional skeleton of a Lefschetz complex or of a given Lefschetz complex subset. While in the first case the <span>$k$</span>-skeleton of the full Lefschetz complex is returned, in the second case it returns the <span>$k$</span>-skeleton of the closure of the given subset.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.manifold_boundary"><code>manifold_boundary</code></a> returns a list of cells which form the &quot;manifold boundary&quot; of the given Lefschetz complex. More  precisely, if the complex has dimension <span>$d$</span>, then it determines all cells of dimension <span>$d-1$</span> which have at most one cell in their coboundary, as well as all cells of dimensions less than <span>$d-1$</span> which have no cell in their coboundary, and finally returns the closure of the resulting cell subset.</li></ul><p>The following functions create <em>Lefschetz subcomplexes</em> from a Lefschetz complex:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_subcomplex"><code>lefschetz_subcomplex</code></a> determines a Lefschetz subcomplex from a given Lefschetz complex. The subcomplex has to be locally closed, and it is given by a collection of cells.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_closed_subcomplex"><code>lefschetz_closed_subcomplex</code></a> extracts a closed Lefschetz subcomplex from the given Lefschetz complex. The subcomplex is the closure of the specified collection of cells.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.permute_lefschetz_complex"><code>permute_lefschetz_complex</code></a> determines a new Lefschetz complex which is obtained from the original one by a permutation of the cells.</li></ul><p>There are also two <em>helper functions</em> which can sometimes  be useful:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_gfp_conversion"><code>lefschetz_gfp_conversion</code></a> changes the base field of the given Lefschetz complex from the rationals <span>$\mathbb{Q}$</span> to a finite field <span>$GF(p)$</span>. Note that it is not possible to perform the reverse conversion.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_filtration"><code>lefschetz_filtration</code></a> computes a filtration on a Lefschetz subset. Based on integer filtration values assigned to some cells of the given Lefschetz complex, it determines the smallest closed subcomplex <code>lcsub</code> which contains all cells with nonzero filtration values, as well as filtration values <code>fvalsub</code> on this subcomplex, which give rise to a filtration of closed subcomplexes, and which can be used to compute persistent homology.</li></ul><p>In addition, <code>ConleyDynamics.jl</code> provides the following helper functions for the fundamental objects of <em>cells and cell subsets</em>, which can be represented either by integer cell indices or by cell labels:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.convert_cells"><code>convert_cells</code></a> converts a vector of cells from integer to label format, or vice versa.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.convert_cellsubsets"><code>convert_cellsubsets</code></a> converts a vector of cell subsets from integer to label format, and vice versa.</li></ul><p>Finally, there are a couple of <em>ccordinate helper functions</em> which allow for the transformation of vertex coordinates in a Lefschetz complex:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.convert_planar_coordinates"><code>convert_planar_coordinates</code></a> transforms a given collection of planar coordinates in such a way that the extreme coordinates fit precisely in a given rectangle in the plane.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.convert_spatial_coordinates"><code>convert_spatial_coordinates</code></a> transforms a given collection of spatial coordinates in such a way that the extreme coordinates fit precisely in a given rectangular box in space.</li></ul><p>For more details on the usage of any of these functions, please see their documentation in the API section of the manual. </p><h2 id="reflefschetz"><a class="docs-heading-anchor" href="#reflefschetz">References</a><a id="reflefschetz-1"></a><a class="docs-heading-anchor-permalink" href="#reflefschetz" title="Permalink"></a></h2><p>See the <a href="../references/#References">full bibliography</a> for a complete list of references cited throughout this documentation. This section cites the following references:</p><div class="citation noncanonical"><dl><dt>[Ale37]</dt><dd><div>P. Alexandrov. <em>Diskrete Räume</em>. Mathematiceskii Sbornik (N.S.) <strong>2</strong>, 501–518 (1937).</div></dd><dt>[DKMW11]</dt><dd><div>P. Dłotko, T. Kaczynski, M. Mrozek and T. Wanner. <em>Coreduction homology algorithm for regular CW-complexes</em>. <a href="https://doi.org/10.1007/s00454-010-9303-y">Discrete &amp; Computational Geometry <strong>46</strong>, 361–388</a> (2011).</div></dd><dt>[KMM04]</dt><dd><div>T. Kaczynski, K. Mischaikow and M. Mrozek. <em>Computational Homology</em>. Vol. 157 of <em>Applied Mathematical Sciences</em> (Springer-Verlag, New York, 2004).</div></dd><dt>[Lef42]</dt><dd><div>S. Lefschetz. <em>Algebraic Topology</em>. Vol. 27 of <em>American Mathematical Society Colloquium Publications</em> (American Mathematical Society, New York, 1942).</div></dd><dt>[LKMW23]</dt><dd><div>M. Lipinski, J. Kubica, M. Mrozek and T. Wanner. <em>Conley-Morse-Forman theory for generalized combinatorial             multivector fields on finite topological spaces</em>. <a href="https://doi.org/10.1007/s41468-022-00102-9">Journal of Applied and Computational Topology <strong>7</strong>, 139–184</a> (2023).</div></dd><dt>[Mas91]</dt><dd><div>W. S. Massey. <em>A Basic Course in Algebraic Topology</em>. Vol. 127 of <em>Graduate Texts in Mathematics</em> (Springer-Verlag, New York, 1991).</div></dd><dt>[MB09]</dt><dd><div>M. Mrozek and B. Batko. <em>Coreduction homology algorithm</em>. Discrete &amp; Computational Geometry <strong>41</strong>, 96–118 (2009).</div></dd><dt>[MW23]</dt><dd><div>M. Mrozek and T. Wanner. <em>Connection matrices in combinatorial topological dynamics</em>, <a href="https://doi.org/10.48550/arXiv.2103.04269">arXiv:2103.04269</a> (2023).</div></dd><dt>[Mun84]</dt><dd><div>J. R. Munkres. <a href="https://doi.org/10.48550/arXiv.2103.04269"><em>Elements of Algebraic Topology</em></a> (Addison-Wesley, Menlo Park, 1984).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../homology/">Homology »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 14 September 2024 00:47">Saturday 14 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
