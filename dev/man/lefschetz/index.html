<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lefschetz Complexes · ConleyDynamics.jl</title><meta name="title" content="Lefschetz Complexes · ConleyDynamics.jl"/><meta property="og:title" content="Lefschetz Complexes · ConleyDynamics.jl"/><meta property="twitter:title" content="Lefschetz Complexes · ConleyDynamics.jl"/><meta name="description" content="Documentation for ConleyDynamics.jl."/><meta property="og:description" content="Documentation for ConleyDynamics.jl."/><meta property="twitter:description" content="Documentation for ConleyDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ConleyDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ConleyDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Lefschetz Complexes</a><ul class="internal"><li><a class="tocitem" href="#Basic-Lefschetz-Terminology"><span>Basic Lefschetz Terminology</span></a></li><li><a class="tocitem" href="#Lefschetz-Complex-Data-Structure"><span>Lefschetz Complex Data Structure</span></a></li><li><a class="tocitem" href="#Simplicial-Complexes"><span>Simplicial Complexes</span></a></li><li><a class="tocitem" href="#Cubical-Complexes"><span>Cubical Complexes</span></a></li><li><a class="tocitem" href="#Lefschetz-Complex-Operations"><span>Lefschetz Complex Operations</span></a></li><li><a class="tocitem" href="#reflefschetz"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../homology/">Homology</a></li><li><a class="tocitem" href="../conley/">Conley Theory</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../sparse/">Sparse Matrices</a></li><li><a class="tocitem" href="../references/">References</a></li></ul></li><li><span class="tocitem">Core API</span><ul><li><a class="tocitem" href="../../apicore/datastruct/">Composite Data Structures</a></li><li><a class="tocitem" href="../../apicore/lefschetz/">Lefschetz Complex Functions</a></li><li><a class="tocitem" href="../../apicore/homology/">Homology Functions</a></li><li><a class="tocitem" href="../../apicore/conley/">Conley Theory Functions</a></li><li><a class="tocitem" href="../../apicore/examples/">Example Functions</a></li><li><a class="tocitem" href="../../apicore/plots/">Plotting Functions</a></li><li><a class="tocitem" href="../../apicore/sparse/">Sparse Matrix Functions</a></li><li><a class="tocitem" href="../../apicore/apiindex/">Complete API Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Lefschetz Complexes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lefschetz Complexes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/main/docs/src/man/lefschetz.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lefschetz-Complexes"><a class="docs-heading-anchor" href="#Lefschetz-Complexes">Lefschetz Complexes</a><a id="Lefschetz-Complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Lefschetz-Complexes" title="Permalink"></a></h1><p>The fundamental structure underlying the functionality of <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> is a <em>Lefschetz complex</em>. It provides us with the basic model of phase space for combinatorial topological dynamics. In view of the combinatorial, and therefore discrete, character of the dynamical behavior, a Lefschetz complex is not a typical phase space in the sense of classical dynamics. While the latter one is usually a Euclidean space, a Lefschetz complex is basically a combinatorial model of it. In the following, we provide its precise mathematical definition, and explain how it can be created and modified within the package. We also discuss two important special cases, namely <em>simplicial complexes</em> and <em>cubical complexes</em>.</p><h2 id="Basic-Lefschetz-Terminology"><a class="docs-heading-anchor" href="#Basic-Lefschetz-Terminology">Basic Lefschetz Terminology</a><a id="Basic-Lefschetz-Terminology-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Lefschetz-Terminology" title="Permalink"></a></h2><p>The original definition of a Lefschetz complex can be found in [<a href="../references/#lefschetz_42a">Lef42</a>], where it was simply referred to as a <em>complex</em>.</p><div class="admonition is-success" id="Definition:-Lefschetz-complex-3447887c9cda79f3"><header class="admonition-header">Definition: Lefschetz complex<a class="admonition-anchor" href="#Definition:-Lefschetz-complex-3447887c9cda79f3" title="Permalink"></a></header><div class="admonition-body"><p>Let <span>$F$</span> denote an arbitrary field. Then a pair <span>$(X,\kappa)$</span> is called a <em>Lefschetz complex</em> over <span>$F$</span> if <span>$X = (X_k)_{k \in \mathbb{N}_0}$</span> is a finite set with <span>$\mathbb{N}_0$</span>-gradation, and <span>$\kappa : X \times X \to F$</span> is a mapping such that</p><p class="math-container">\[   \kappa(x,y) \neq 0
   \quad\mathrm{ implies }\quad
   x \in X_k
   \quad\mathrm{ and }\quad y \in X_{k-1},\]</p><p>and such that for any <span>$x,z \in X$</span> one has</p><p class="math-container">\[   \sum_{y \in X} \kappa(x,y) \kappa(y,z) = 0 \; .\]</p><p>The elements of <span>$X$</span> are referred to as <em>cells</em>, the value <span>$\kappa(x,y) \in F$</span> is called the <em>incidence coefficient</em> of the cells <span>$x$</span> and <span>$y$</span>, and the map <span>$\kappa$</span> is the <em>incidence coefficient map</em>. In addition, one defines the <em>dimension</em> of a cell <span>$x\in X_k$</span> as the integer <span>$k$</span>, and denotes it by <span>$k = \dim x$</span>. Whenever the incidence coefficient map is clear from context, we often just refer to <span>$X$</span> as the <em>Lefschetz complex</em>.</p></div></div><p>At first glance the above definition can seem daunting. However, it is based on a straightforward geometric idea. A Lefschetz  complex is a structure that is built from elementary building blocks called <em>cells</em>. Each cell has a dimension associated with it, and it is topologically an open ball of this dimension. Thus, cells of dimension zero are points, also called <em>vertices</em>. Cells of dimension one are open curve segments, which we call <em>edges</em>, and two-dimensional cells are called <em>faces</em> and take the form of open two-dimensional membranes.</p><p>The incidence coefficient map encodes how these cells are glued together to form the Lefschetz complex <span>$X$</span>. In order to shed more light on this, consider the <em>boundary map</em> <span>$\partial$</span> which is defined on cells via</p><p class="math-container">\[   \partial x = \sum_{y \in X} \kappa(x,y) y \; .\]</p><p>This map sends a cell <span>$x$</span> of dimension <span>$k$</span> to a specific  linear combination of cells of dimension <span>$k-1$</span>, called the <em>boundary</em> of <span>$x$</span>. By using ideas from linear algebra, the boundary map can be extended to map a general linear combination of <span>$k$</span>-dimensional cells to the corresponding linear combination of the separate boundaries. For example, if one chooses the field <span>$F = \mathbb{Q}$</span> of rationals, one has <span>$\partial  (x_1 - 2x_2) = \partial x_1 - 2 \partial x_2$</span>. Notice that using this extended definition of the boundary map, one can rewrite the summation condition in the definition of a Lefschetz complex in the equivalent form</p><p class="math-container">\[   \partial( \partial x) = 0
   \quad\text{ for all cells }\quad
   x \in X \; .\]</p><p>In other words, the boundary of any cell is itself boundaryless.</p><p>With the help of the boundary map, one can often infer the overall geometric structure of a Lefschetz complex <span>$X$</span>. For this, think of a Lefschetz complex as being build <em>from the ground up</em> in the following way. First, start by putting down all vertices of <span>$X$</span> at different locations in some ambient space. Since the boundary of each one-dimensional cell is made up of a linear combination of vertices, one can then add a curve segment for each one-dimensional cell, which connects the vertices in its boundary. Note that in the general version of a Lefschetz complex it is possible that an edge has only one vertex in its boundary, or maybe even none, and in these cases the edge is either only connected to the one boundary vertex, or it is an open curve segment connected to no vertex at all, respectively. Continue in this fashion to add two-dimensional faces to fill in the space between the edges in its boundary, and so on for higher dimensions. Needless to say, in the case of a general complicated Lefschetz complex this procedure is of limited use, since the boundary of a cell can be an arbitrary linear combination of cells, with coefficients that can be any nonzero numbers in the field <span>$F$</span>. Yet, in many simple cases the above intuition is sufficient.</p><p>In addition to the Lefschetz complex definition, there are a handful of other concepts which will be important for our discussion of Lefschetz complexes. Specifically, the following notions are important:</p><ul><li>A <em>facet</em> of a cell <span>$x \in X$</span> is any cell <span>$y$</span> which satisfies <span>$\kappa(x,y) \neq 0$</span>.</li><li>One can define a partial order on the cells of <span>$X$</span> by letting <span>$x \le y$</span> if and only if for some integer <span>$n \in \mathbb{N}$</span> there exist cells <span>$x = x_1, \ldots, x_n = y$</span> such that <span>$x_k$</span> is a facet of <span>$x_{k+1}$</span> for all <span>$k = 1, \ldots, n-1$</span>. It is not difficult to show that this defines a partial order on <span>$X$</span>, i.e., this relation is reflexive, antisymmetric, and transitive. We call this partial order the <em>face relation</em>.  Moreover, if <span>$x \le y$</span> then <span>$x$</span> is called a <em>face</em> of <span>$y$</span>.</li><li>A subset <span>$C \subset X$</span> of a Lefschetz complex is called <em>closed</em>, if for every <span>$x \in C$</span> all the faces of the cell <span>$x$</span> are also contained in the subset <span>$C$</span>.</li><li>The <em>closure</em> of a subset <span>$C \subset X$</span> is the collection of all faces of all cells in <span>$C$</span>, and it is denoted by <span>$\mathrm{cl}\, C$</span>. Thus, a subset of a Lefschetz complex is closed if and only if it equals its closure.</li><li>A subset <span>$S \subset X$</span> is called <em>locally closed</em>, if its <em>mouth</em> <span>$\mathrm{mo}\, S = \mathrm{cl}\, S \setminus S$</span> is closed. Note that every closed set is automatically locally closed, but the reverse implication is usually false.</li></ul><p>While the first two points merely introduce notation for describing the combinatorial boundary of cells, the remaining three points establish important <em>topological concepts</em>. In fact, the above definition of closedness defines a topology on the Lefschetz complex <span>$X$</span>, which is the so-called <em>Alexandrov topology</em> from [<a href="../references/#alexandrov_37a">Ale37</a>]. As usual in the field of topology, a subset of a Lefschetz complex will be called <em>open</em>, if and only if its complement is closed.</p><p>We would like to point out that while the concept of local closedness is rarely considered in standard topology courses, it is of utmost important for the study of combinatorial topological dynamics. For the moment, we just mention the following result:</p><div class="admonition is-danger" id="Theorem:-Lefschetz-subcomplexes-80268facaa706ac0"><header class="admonition-header">Theorem: Lefschetz subcomplexes<a class="admonition-anchor" href="#Theorem:-Lefschetz-subcomplexes-80268facaa706ac0" title="Permalink"></a></header><div class="admonition-body"><p>Let <span>$X$</span> be a Lefschetz complex over a field <span>$F$</span>, and let <span>$\kappa : X \times X \to F$</span> denote its incidence coefficient map. Then a subset <span>$S \subset X$</span> is again a Lefschetz complex, with respect to the restriction of <span>$\kappa$</span> to <span>$S \times S$</span>, if the subset <span>$S$</span> is locally closed.</p></div></div><p>This result goes back to [<a href="../references/#mrozek_batko_09a">MB09</a>, Theorem 3.1]. In other words, in the category of Lefschetz complexes local closedness arises naturally. Due to its importance, we also mention the following two equivalent formulations:</p><ul><li>A subset <span>$S \subset X$</span> is locally closed, if and only if it is the difference of two closed subsets of <span>$X$</span>.</li><li>A subset <span>$S \subset X$</span> is locally closed, if and only if it is an interval with respect to the face relation on <span>$X$</span>, i.e., whenever we have three cells with <span>$S \ni x \le y \le z \in S$</span>, then one has to have <span>$y \in S$</span> as well.</li></ul><p>The proof of these characterizations can be found in [<a href="../references/#mrozek_wanner_25a">MW25</a>, Proposition 3.2.1] and [<a href="../references/#lipinski_etal_23a">LKMW23</a>, Proposition 3.10], respectively.</p><p>Lefschetz complexes are a very general mathematical concept, and they can be rather confusing at first sight. Nevertheless, they do encompass other complex types, which are more geometric in nature. As we already saw in the tutorial, every <em>simplicial complex</em> is automatically a Lefschetz complex, and we will further elaborate on this connection below. In addition, we will also demonstrate that <em>cubical complexes</em> are Lefschetz complexes. More general, any <em>regular CW complex</em> is  a Lefschetz complex as well. For more details on this, we refer to the definition in [<a href="../references/#massey_91a">Mas91</a>] and the discussion in [<a href="../references/#dlotko_etal_11a">DKMW11</a>].</p><h2 id="Lefschetz-Complex-Data-Structure"><a class="docs-heading-anchor" href="#Lefschetz-Complex-Data-Structure">Lefschetz Complex Data Structure</a><a id="Lefschetz-Complex-Data-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Lefschetz-Complex-Data-Structure" title="Permalink"></a></h2><p>For the efficient and easy manipulation of Lefschetz complexes in <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> we make use of a specific composite data type:</p><article><details class="docstring" open="true"><summary id="ConleyDynamics.LefschetzComplex-man-lefschetz"><a class="docstring-binding" href="#ConleyDynamics.LefschetzComplex-man-lefschetz"><code>ConleyDynamics.LefschetzComplex</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LefschetzComplex</code></pre><p>Collect the Lefschetz complex information in a struct.</p><p>The struct is created via the following fields:</p><ul><li><code>labels::Vector{String}</code>: Vector of labels associated with cell indices</li><li><code>dimensions::Vector{Int}</code>: Vector cell dimensions</li><li><code>boundary::SparseMatrix</code>: Boundary matrix, columns give the cell boundaries</li></ul><p>It is expected that the dimensions are given in increasing order, and that the square of the boundary matrix is zero. Otherwise, exceptions are raised. In addition, the following fields are created during initialization:</p><ul><li><code>ncells::Int</code>: Number of cells</li><li><code>dim::Int</code>: Dimension of the complex</li><li><code>indices::Dict{String,Int}</code>: Dictionary for finding cell index from label</li></ul><p>The coefficient field is specified by the boundary matrix.</p><div class="admonition is-warning" id="Warning-d423446bfab5f00d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-d423446bfab5f00d" title="Permalink"></a></header><div class="admonition-body"><p>Note that the constructor does not check whether the boundary matrix squares to zero. It is the responsibility of the user to ensure that!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/a0422b6cfdbaed4a6640458083a756547035b069/src/conley/composite_types.jl#L3-L23">source</a></section></details></article><p>The fields of this struct relate to the mathematical definition of a Lefschetz complex <span>$X$</span> in the following way:</p><ul><li>Internally, every cell of the Lefschetz complex is represented by an integer between 1 and the total number of cells. However, in order to make it easier to interpret the results of computations, each cell in a Lefschetz complex has to also be given a label. These labels are contained in the field <code>labels::Vector{String}</code>, where <code>labels[k]</code> gives the label of cell <code>k</code>.</li><li>The vector <code>dimensions</code> is a <code>Vector{Int}</code> and collects the  dimensions of the cells. In other words, the cell which is indexed by the integer <code>k</code> has dimension <code>dimensions[k]</code>. It is expected that the dimension vector is increasing, and the constructor method will verify this. Otherwise, an error is triggered.</li><li>The incidence coefficient map <span>$\kappa$</span> is encoded in the sparse matrix <code>boundary</code>. This matrix is a square matrix with <code>ncells</code>  rows and columns. The <span>$k$</span>-th column contains the incidence coefficients <span>$\kappa(k,\cdot)$</span> in the sense that the entry in row <span>$m$</span> and column <span>$k$</span> equals the value <span>$\kappa(k,m)$</span>. Since for most Lefschetz complexes the majority of the incidence coefficients is zero, the matrix is represented using the sparse format <a href="../../apicore/sparse/#ConleyDynamics.SparseMatrix"><code>SparseMatrix</code></a>, which is described in more detail in <a href="../sparse/#Sparse-Matrices">Sparse Matrices</a>. An exception is raised if the square of the boundary matrix is not zero.</li></ul><p>When creating a Lefschetz complex, only the above three items have to be specified, as they define a unique Lefschetz complex <span>$X$</span>. In other words, a Lefschetz complex is generally created via the command</p><pre><code class="language-julia hljs">   lc = LefschetzComplex(labels, dimensions, boundary)</code></pre><p>During the construction of the Julia object, additional fields are initialized which simplify working with a Lefschetz complex:</p><ul><li>The integer <code>ncells</code> gives the total number of cells in <span>$X$</span>. Internally, these cells are numbered by integers ranging from <code>1</code> to <code>ncells</code>.</li><li>The integer <code>dim</code> describes the overall dimension of the Lefschetz complex, which is the largest dimension of a cell.</li><li>In order to easily determine the integer index for a cell with a specific label, the field <code>indices</code> contains a dictionary of type <code>Dict{String,Int}</code> which maps labels to indices. For  example, if a cell has the label <code>&quot;124.010&quot;</code>, then the associated integer index is given by <code>indices[&quot;124.010&quot;]</code>.</li></ul><p>As mentioned above, note however that an object of type <code>LefschetzComplex</code> is created by passing only the first three the field items in the order given in <a href="../../apicore/datastruct/#ConleyDynamics.LefschetzComplex"><code>LefschetzComplex</code></a>. Consider for example the Lefschetz complex from Figure 2.4 in [<a href="../references/#mrozek_wanner_25a">MW25</a>], see also the left complex in the next image. This complex consists of six cells with labels <code>A</code>,  <code>B</code>, <code>a</code>, <code>b</code>, <code>c</code>, and <code>alpha</code>, and we initialize the vector of labels, the cell index dictionary, and the cell dimensions via the commands</p><pre><code class="language-julia hljs">ncL = 6
labelsL = Vector{String}([&quot;A&quot;,&quot;B&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;alpha&quot;])
cdimsL  = [0, 0, 1, 1, 1, 2]</code></pre><p>The boundary matrix can then be defined using</p><pre><code class="language-julia hljs">bndmatrixL = zeros(Int, ncL, ncL)
bndmatrixL[[1,2],3] = [1; 1]     # a
bndmatrixL[[1,2],4] = [1; 1]     # b
bndmatrixL[[1,2],5] = [1; 1]     # c
bndmatrixL[[3,4],6] = [1; 1]     # alpha
bndsparseL = sparse_from_full(bndmatrixL, p=2)</code></pre><p>Notice that we first create the matrix as a regular integer  matrix, and then use the function <a href="../../apicore/sparse/#ConleyDynamics.sparse_from_full"><code>sparse_from_full</code></a>  to turn it into sparse format over the field <span>$GF(2)$</span> with characteristic <code>p = 2</code>. This is the most convenient method for small boundary matrices, yet for larger ones it is better to use the function <a href="../../apicore/sparse/#ConleyDynamics.sparse_from_lists"><code>sparse_from_lists</code></a>. Finally, the Lefschetz complex is created using</p><pre><code class="language-julia hljs">lcL = LefschetzComplex(labelsL, cdimsL, bndsparseL)</code></pre><p><img src="../img/lefschetzex1.png" alt="Two sample Lefschetz complexes"/></p><p>Lefschetz complexes do not always have to contain cells of all dimensions. For example, the Lefschetz complex shown on the right side of the figure has no vertices, and it can be created using the commands</p><pre><code class="language-julia hljs">ncR = 4
labelsR  = Vector{String}([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;alpha&quot;])
cdimsR   = [1, 1, 1, 2]
bndmatrixR = zeros(Int, ncR, ncR)
bndmatrixR[[1,2,3],4] = [1; 1; 1]     # alpha
bndsparseR = sparse_from_full(bndmatrixR, p=2)
lcR = LefschetzComplex(labelsR, cdimsR, bndsparseR)</code></pre><p>While Lefschetz complexes can always be created in <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> in this direct way, it is often more convenient to make use of special types, such as simplicial and cubical complexes, and then restrict the complex to a locally closed set using the function <a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_subcomplex"><code>lefschetz_subcomplex</code></a>. As an alternative, if one is  interested in a fairly small Lefschetz complex over the field <span>$GF(2)$</span>, then the following special function can be used:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.create_lefschetz_gf2"><code>create_lefschetz_gf2</code></a> creates a Lefschetz complex over the two-element field <span>$GF(2)$</span> by specifying its essential cells and boundaries. The input argument <code>defcellbnd</code> of the function has to be a vector of vectors. Each entry <code>defcellbnd[k]</code> then has to be of one of the following two forms:<ul><li><code>[String, Int, String, String, ...]</code>: The first <code>String</code> contains  the label for the cell <code>k</code>, followed by its dimension in the second  entry. The remaining entries are for the labels of the cells which  make up the boundary.</li><li><code>[String, Int]</code>: This shorther form is for cells with empty boundary. The first entry denotes the cell label, and the second its dimension.</li></ul>The cells of the resulting Lefschetz complex correspond to the union of all occurring labels. Cell labels that only occur in the boundary specification are assumed to have empty boundary, and they do not have to be specified separately in the second form above. However, if their boundary is not empty, they have to be listed via the above first form as well.</li></ul><p>Using this function, our earlier Lefschetz complex <code>lcL</code> can be created using the commands</p><pre><code class="language-julia hljs">defcellbndL = [[&quot;a&quot;,1,&quot;A&quot;,&quot;B&quot;], [&quot;b&quot;,1,&quot;A&quot;,&quot;B&quot;], [&quot;c&quot;,1,&quot;A&quot;,&quot;B&quot;], [&quot;alpha&quot;,2,&quot;a&quot;,&quot;b&quot;]]
lcL = create_lefschetz_gf2(defcellbndL)</code></pre><p>while the Lefschetz complex <code>lcR</code> is defined via</p><pre><code class="language-julia hljs">defcellbndR = [[&quot;alpha&quot;,2,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], [&quot;a&quot;,1], [&quot;b&quot;,1], [&quot;c&quot;,1]]
lcR = create_lefschetz_gf2(defcellbndR)</code></pre><h2 id="Simplicial-Complexes"><a class="docs-heading-anchor" href="#Simplicial-Complexes">Simplicial Complexes</a><a id="Simplicial-Complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Simplicial-Complexes" title="Permalink"></a></h2><p>One of the earliest types of complexes that have been studied in  topology are <em>simplicial complexes</em>. As already mentioned in the tutorial, an <em>abstract simplicial complex</em> <span>$X$</span> is a finite collection of finite sets, called <em>simplices</em>, which is closed under taking subsets. Each simplex <span>$\sigma$</span> has a <em>dimension</em> <span>$\dim\sigma$</span>, which is one less than the number of its elements.</p><p>In order to see why every simplicial complex is automatically a  Lefschetz complex, we need to be able to define the incidence  coefficient map <span>$\kappa$</span>. For this, we make use of some notions from [<a href="../references/#munkres_84a">Mun84</a>]. Let <span>$X_0$</span> denote the collection of all vertices of the simplicial complex <span>$X$</span>. Then we use the notation</p><p class="math-container">\[   \sigma = \left[ v_0, v_1, \ldots, v_d \right]
   \quad\text{ with }\quad
   v_k \in X_0\]</p><p>to describe a <span>$d$</span>-dimensional simplex. Note that even though every simplex in <span>$X$</span> is just the set of its vertices, in the above  representation we pick an order of the vertices, called an <em>orientation</em> of the simplex. This orientation can be chosen arbitrarily, and there are two equivalence classes of orientations. To get from one orientation to the other, one just has to exchange two vertices, and we write</p><p class="math-container">\[   \left[ \ldots, v_i, \ldots, v_j, \ldots \right] \; = \;
   -\left[ \ldots, v_j, \ldots, v_i, \ldots \right] \; .\]</p><p>For more complicated reorderings, one has to represent the corresponding vertex permutation as a sequence of such exchanges. Using these oriented simplices we can define the boundary operator</p><p class="math-container">\[   \partial \sigma \; = \;
   \partial \left[ v_0, \ldots, v_d \right] \; = \;
   \sum_{i=0}^d (-1)^i \left[ v_0, \ldots, \hat{v}_i,
     \ldots, v_d \right] \; ,\]</p><p>where the notation <span>$\hat{v}_i$</span> means that in the simplex behind the summation sign on the right-hand side the vertex <span>$v_i$</span> is omitted. For example, for a two-dimensional simplex one obtains</p><p class="math-container">\[   \partial \left[ v_0, v_1, v_2 \right] \; = \;
   \left[ v_1, v_2 \right] - 
   \left[ v_0, v_2 \right] + 
   \left[ v_0, v_1 \right] \; .\]</p><p>Thus, if one chooses a total order of all the vertices in the simplicial complex, and orients the individual simplices in such a way that their vertices are arranged using this overall order, then the incidence coefficient map is given by</p><p class="math-container">\[   \kappa \left( \left[ v_0, \ldots, v_i, \ldots, v_d \right], \;
     \left[ v_0, \ldots, \hat{v}_i, \ldots, v_d \right] \right)
   \; = \; (-1)^i \; .\]</p><p>If some or all of the simplices are represented by different orientations, one simply has to multiply the value <span>$(-1)^i$</span> by the sign of a suitable vertex permutation. In either case, one can show that the so-defined map <span>$\kappa$</span> does indeed satisfy the definition of a Lefschetz complex. For more details, see [<a href="../references/#munkres_84a">Mun84</a>, Lemma 5.3].</p><p>In <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> there are three basic commands for defining a simplicial complex:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.create_simplicial_complex"><code>create_simplicial_complex</code></a> is the most general method, and it expects two input arguments. The first is usually called <code>labels</code>, and  it has to have the data type <code>Vector{String}</code>. This vector lists the labels for each vertex. It is important that all of these labels have exactly the same number of characters. The second argument is usually called <code>simplices</code>, and it lists as many simplices as necessary for defining the underlying simplicial complex. This means that in practice one only needs to include the simplices which are not faces of higher-dimensional ones, see also the example below. The variable <code>simplices</code> can either be of type <code>Vector{Vector{String}}</code> or <code>Vector{Vector{Int}}</code>, depending on whether the vertices are identified via their labels or integer indices, respectively. Finally, the optional parameter <code>p</code> can be used to specify the underlying field for the  boundary matrix. If <code>p</code> is a prime, then <span>$F = GF(p)$</span>, while for <code>p = 0</code> the function uses <span>$F = \mathbb{Q}$</span>. If the argument <code>p</code> is ommitted, the function defaults to <code>p = 2</code>.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.create_simplicial_rectangle"><code>create_simplicial_rectangle</code></a> expects two integer arguments <code>nx</code> and <code>ny</code>, and then creates a triangulation of the square <span>$[0,nx] \times [0,ny]$</span> by subdividing every unit square into four triangles which meet at the center of the square. As before, the optional parameter <code>p</code> specifies the underlying field.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.create_simplicial_delaunay"><code>create_simplicial_delaunay</code></a> creates a planar Delaunay triangulation inside a planar rectangle. The function selects a random sample of points inside the box, while either trying to maintain a minimum distance between the points, or just using a prespecified number of points. More details on these two options can be found in the documentation for the function.</li></ul><p>To illustrate the first of these functions, consider the commands</p><pre><code class="language-julia hljs">labels = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;]
simplices = [[&quot;A&quot;,&quot;B&quot;],[&quot;A&quot;,&quot;F&quot;],[&quot;B&quot;,&quot;F&quot;],[&quot;B&quot;,&quot;C&quot;,&quot;G&quot;],[&quot;D&quot;,&quot;E&quot;,&quot;H&quot;],[&quot;C&quot;,&quot;D&quot;],[&quot;G&quot;,&quot;H&quot;]]
sc = create_simplicial_complex(labels,simplices)</code></pre><p>These create the simplicial complex <code>sc</code>, in the form of a  Lefschetz complex. Note that the above commands only specify the labels for the vertices. The labels for simplices of dimension at least one are automatically generated by concatenating the labels for their vertices, sorted in lexicographic order. This can be seen in the following Julia output:</p><pre><code class="language-julia hljs">julia&gt; sc.labels[end-4:end]
5-element Vector{String}:
 &quot;DH&quot;
 &quot;EH&quot;
 &quot;GH&quot;
 &quot;BCG&quot;
 &quot;DEH&quot;</code></pre><p>The simplicial complex <code>sc</code> can be visualized using the commands</p><pre><code class="language-julia hljs">coords = [[0,0],[2,0],[4,0],[6,0],[8,0],[1,2],[4,2],[6,2]]
ldir   = [3,3,3,3,3,1,1,1]
fname  = &quot;lefschetzex2.pdf&quot;
plot_planar_simplicial(sc,coords,fname,labeldir=ldir,labeldis=10,hfac=2,vfac=1.5,sfac=50)</code></pre><p><img src="../img/lefschetzex2.png" alt="First sample simplicial complex"/></p><p>Similarly, the commands</p><pre><code class="language-julia hljs">sc2, coords2 = create_simplicial_rectangle(5,2)
fname2 = &quot;lefschetzex3.pdf&quot;
plot_planar_simplicial(sc2,coords2,fname2,hfac=2.0,vfac=1.2,sfac=75)</code></pre><p>define and illustrate a second simplicial complex, which triangularizes a rectangle in the plane.</p><p><img src="../img/lefschetzex3.png" alt="Second sample simplicial complex"/></p><p>For a demonstration of the Delaunay triangulation approach, please see <a href="../tutorial/#Analyzing-Planar-Vector-Fields">Analyzing Planar Vector Fields</a>.</p><p>In addition to the above methods, <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> also provides a few special simplicial complexes for illustration purposes:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.simplicial_torus"><code>simplicial_torus</code></a> constructs a triangulation of the two-dimensional torus.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.simplicial_klein_bottle"><code>simplicial_klein_bottle</code></a> returns a triangulation of the two-dimensional Klein bottle.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.simplicial_projective_plane"><code>simplicial_projective_plane</code></a> constructs a triangulation of the projective plane.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.simplicial_torsion_space"><code>simplicial_torsion_space</code></a> returns a simplicial complex <span>$K$</span> with the integer homology groups <span>$H_0(K) \cong {\mathbb Z}$</span>, as well as <span>$H_1(K) \cong {\mathbb Z}_n$</span> and <span>$H_2(K) \cong 0$</span>. In other words, this simplicial complex has nontrivial torsion in dimension 1. For <span>$n = 3$</span> and <span>$n = 4$</span> these triangulations are shown in the following figure. Notice that points with the same label have to be identified. This vertex naming scheme is the same as is used in the function.</li></ul><p><img src="../img/exampletorsion.png" alt="Simplicial torsion space"/></p><p>These examples can be used to illustrate homology over different fields.</p><h2 id="Cubical-Complexes"><a class="docs-heading-anchor" href="#Cubical-Complexes">Cubical Complexes</a><a id="Cubical-Complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Cubical-Complexes" title="Permalink"></a></h2><p>The second important special case of a Lefschetz complex is called <em>cubical complex</em>, and it has been discussed in detail in [<a href="../references/#kaczynski_etal_04a">KMM04</a>]. In the following, we only present the definitions that are essential for our purposes.</p><p>Loosely speaking, a cubical complex is a collection of cubes of varying dimensions in some Euclidean space <span>$\mathbb{R}^d$</span>. More precisely, we say that an interval <span>$I \subset \mathbb{R}$</span> is an <em>elementary interval</em> if it is of the form</p><p class="math-container">\[   I = [\ell, \ell+1]
   \quad\text{ or }\quad
   I = [\ell, \ell]
   \quad\text{ for some integer }\quad
   \ell \in \mathbb{Z} \; .\]</p><p>If the elementary interval <span>$I$</span> consists of only one point, then it is called <em>degenerate</em>, and it is <em>nondegenerate</em> if it is of length one. Elementary intervals are the building blocks for the cubes in a cubical complex. For a complex in <span>$\mathbb{R}^d$</span>, an <em>elementary cube</em> <span>$Q$</span> is of the form</p><p class="math-container">\[   Q \; = \;
   I_1 \times I_2 \times \ldots \times I_d \; \subset \;
   \mathbb{R}^d \; ,\]</p><p>where <span>$I_1, \ldots, I_d$</span> are elementary intervals. The <em>dimension</em> <span>$\dim Q$</span> of an elementary cube is given by the number of nondegenerate intervals in its representation. For example, the cube <span>$Q = [0,0]  \times [1,1]$</span> is a zero-dimensional elementary cube in <span>$\mathbb{R}^2$</span> which contains only the point <span>$(0,1)$</span>, while the elementary cube <span>$R = [2,2] \times [3,4]$</span> is one-dimensional, and consists of the  closed vertical line segment between the points <span>$(2,3)$</span> and <span>$(2,4)$</span>.</p><p>After these preparations, the definition of a cubical complex is now straightforward. A <em>cubical complex</em> <span>$X$</span> in <span>$\mathbb{R}^d$</span> is a finite collection of elementary cubes in <span>$\mathbb{R}^d$</span> which is closed under the inclusion of elementary subcubes. More precisely, if <span>$Q \in X$</span> is an elementary cube in the cubical complex, and if <span>$R \subset Q$</span> is any elementary cube contained in <span>$Q$</span>, then one also has <span>$R \in X$</span>.</p><p>The definition of a cubical complex is reminiscent of that of a simplicial complex. It is therefore not surprising that also in the cubical case one can describe the incidence coefficient map <span>$\kappa$</span> explicitly, and thus recognize a cubical complex as a Lefschetz complex. For this, we need more notation.</p><p>Let <span>$Q = I_1 \times I_2 \times \ldots \times I_d$</span> denote an elementary cube, and let the nondegenerate elementary intervals in this decomposition be given by <span>$I_{i_1}, \ldots, I_{i_n}$</span>, where <span>$I_{i_j} = [k_j, k_j + 1]$</span> and <span>$j = 1,\ldots,n = \dim Q$</span>. For every index <span>$j$</span>, we further define the two <span>$(n-1)$</span>-dimensional elementary cubes</p><p class="math-container">\[   \begin{array}{ccccccc}
   Q_j^- &amp; = &amp; I_1 \times \ldots \times I_{i_j - 1} &amp; \times &amp;
           [k_j, k_j] &amp; \times &amp; I_{i_j + 1} \times \ldots
           \times I_d \; , \\[2ex]
   Q_j^+ &amp; = &amp; I_1 \times \ldots \times I_{i_j - 1} &amp; \times &amp;
           [k_j + 1, k_j + 1] &amp; \times &amp; I_{i_j + 1} \times
           \ldots \times I_d \; .
   \end{array}\]</p><p>Geometrically, the two elementary cubes <span>$Q_j^-$</span> and <span>$Q_j^+$</span> are directly opposite sides of the elementary cube <span>$Q$</span>. Using them, one can define the algebraic <em>boundary</em> of the cube as</p><p class="math-container">\[   \partial Q \; = \;
   \sum_{j=1}^n (-1)^{j-1} \left( Q_j^+ - Q_j^- \right) .\]</p><p>This formula is the cubical analogue of the boundary operator in a simplicial complex, and it allows us to define the incidence coefficient map via</p><p class="math-container">\[   \kappa\left( Q, \, Q_j^+ \right) \; = \; (-1)^{j-1}
   \quad\text{ and }\quad
   \kappa\left( Q, \, Q_j^- \right) \; = \; (-1)^j \; ,
   \quad\text{ for all }\quad
   j = 1, \ldots, n \; .\]</p><p>For all remaining pairs of elementary cubes in <span>$X$</span> we let <span>$\kappa = 0$</span>. Then it was shown in [<a href="../references/#kaczynski_etal_04a">KMM04</a>, Proposition 2.37] that the so-defined incidence coefficient map satisfies the summation condition in the definition of a Lefschetz complex, i.e., we have <span>$\partial(\partial Q) = 0$</span> for every <span>$Q \in X$</span>. This in turn implies that every cubical complex is indeed a Lefschetz complex.</p><p>Cubical complexes in <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> are a little more restricted. Since a cubical complex in the above sense is always finite, one can assume without loss of generality that the left endpoints of all involved elementary intervals are nonnegative. In other words, we always assume that the cubical complex only contains elementary cubes from the set <span>$(\mathbb{R}_0^+)^d$</span>. This allows for a simple encoding of elementary cubes via labels of a fixed length, and without having to worry about the sign of an integer.</p><p>To describe this, fix a dimension <span>$d$</span> of the ambient space. Then every elementary cube in <span>$(\mathbb{R}_0^+)^d$</span> has the following label, which depends on a <em>coordinate width</em> <span>$L$</span>:</p><ul><li>The first <span>$d \cdot L$</span> characters of the label encode the  starting points of the elementary intervals <span>$I_1, \ldots, I_d$</span> in the standard representation of the elementary cube. For this, the starting points, which are nonnegative integers, are concatenated without spaces, but with leading zeros. For example, with <span>$L = 2$</span> the string <code>&quot;010203&quot;</code> would correspond to the starting points <span>$1$</span>, <span>$2$</span>, and <span>$3$</span>. Note that for given coordinate width <span>$L$</span>, one can only encode starting points between <span>$0$</span> and <span>$10^L-1$</span>.</li><li>The next entry in the label string is a period <code>.</code>.</li><li>The remaining <span>$d$</span> characters of the string are integers 0 or 1, which give the interval lengths of <span>$I_1, \ldots, I_d$</span>.</li></ul><p>For example, for <span>$L = 2$</span> the string <code>&quot;030600.000&quot;</code> corresponds to the point <span>$(3,6,0)$</span> in three dimensions. Similarly, the label <code>&quot;030600.101&quot;</code> represents the two-dimensional elementary cube <span>$[3,4] \times [6,6] \times [0,1] \subset \mathbb{R}^3$</span>. Note, however, that the label representation is not unique, since it depends on the coordinate width <span>$L$</span>. Thus, with <span>$L = 1$</span> the latter cube could also be written as <code>&quot;360.101&quot;</code>, or with <span>$L = 3$</span> as <code>&quot;003006000.101&quot;</code>. As we will see in a moment, though, <strong>within a given cubical complex all labels have to use the same coordinate width</strong> <span>$L$</span>! This implies in particular that for a given coordinate width <span>$L$</span> one can only represent bounded cubical complexes which are contained in the <span>$d$</span>-dimensional box <span>$[0,10^L-1]^d$</span>.</p><p>The following three helper functions simplify the work with these types of cube labels:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.cube_field_size"><code>cube_field_size</code></a> determines the field sizes of a given cube label. The first return value gives the dimension <span>$d$</span> of the ambient space, while the second value returns the coordinate width <span>$L$</span>.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.cube_information"><code>cube_information</code></a> returns all information encoded in the cube label. The function returns an integer vector of length <span>$2d+1$</span>, where <span>$d$</span> is the dimension of the ambient space. The first <span>$d$</span> entries give the vector of elementary interval starting points, while the next <span>$d$</span> values yield the corresponding interval lengths. The last entry specifies the dimension of the cube.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.cube_label"><code>cube_label</code></a> creates a label from a cube&#39;s coordinate information. As function parameters, one has to specify <span>$d$</span> and <span>$L$</span>, and then pass an integer vector of length six which specifies the coordinates of the starting points and the interval lengths as in the previous item.</li></ul><p>In <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> there are four basic commands for defining a cubical complex and working with it:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.create_cubical_complex"><code>create_cubical_complex</code></a> creates a cubical complex in the Lefschetz complex data format. The complex is specified via a list of all the highest-dimensional cubes which are necessary to define the cubical complex. For this, every cube has to be given using the above-described special label format, with the same coordinate width <span>$L$</span>. In other words, all label strings have to be of the same length! If the optional parameter <code>p</code> is specified, the complex will be defined over a field with characteristic <code>p</code>, analogous to the case of a simplicial complex. If the characteristic is not specified, then the function defaults to the field <span>$GF(2)$</span>.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.get_cubical_coords"><code>get_cubical_coords</code></a> determines the coordinates of all  vertices of a given cubical complex from the cube labels. This vector can then be used for plotting purposes, see below.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.create_cubical_rectangle"><code>create_cubical_rectangle</code></a> creates a cubical complex covering a rectangle in the plane. The rectangle is given by the subset <span>$[0,nx] \times [0,ny]$</span> of the plane, where the nonnegative integers <code>nx</code> and <code>ny</code> have to be passed as arguments to the function. The function returns the cubical complex, and a vector of coordinates for the vertices. The latter can also be randomly perturbed as described in more detail in the function documentation.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.create_cubical_box"><code>create_cubical_box</code></a> creates a cubical complex covering a box in three-dimensional Euclidean space. The box is given by the subset <span>$[0,nx] \times [0,ny] \times [0,nz]$</span> of space, where the nonnegative integers <code>nx</code>, <code>ny</code>, and <code>nz</code> have to be passed as arguments to the function. The optional parameters are the same as in the planar version.</li></ul><p>To illustrate the first of these functions, consider the commands</p><pre><code class="language-julia hljs">cubes = [&quot;00.11&quot;, &quot;01.01&quot;, &quot;02.10&quot;, &quot;11.10&quot;, &quot;11.01&quot;, &quot;22.00&quot;, &quot;20.11&quot;, &quot;31.01&quot;]
cc = create_cubical_complex(cubes)</code></pre><p>These create the cubical complex <code>cc</code>, in the form of a  Lefschetz complex. It can be visualized using the commands</p><pre><code class="language-julia hljs">coords = get_cubical_coords(cc)
fname  = &quot;lefschetzex4.pdf&quot;
plot_planar_cubical(cc,coords,fname,hfac=2.2,vfac=1.1,cubefac=60)</code></pre><p><img src="../img/lefschetzex4.png" alt="First sample cubical complex"/></p><p>Similarly, the commands</p><pre><code class="language-julia hljs">cc2, coords2 = create_cubical_rectangle(5,2)
fname2 = &quot;lefschetzex5.pdf&quot;
plot_planar_cubical(cc2,coords2,fname2,hfac=1.7,vfac=1.2,cubefac=75)</code></pre><p>define and illustrate a second cubical complex.</p><p><img src="../img/lefschetzex5.png" alt="Second sample cubical complex"/></p><p>Finally, it is also possible to perturb the vertices in a cubical rectangle to obtain a Lefschetz complex consisting of quadrilaterals in the plane. This can be accomplied as follows:</p><pre><code class="language-julia hljs">cc3, coords3 = create_cubical_rectangle(5,2,randomize=0.2)
fname3 = &quot;lefschetzex6.pdf&quot;
plot_planar_cubical(cc3,coords3,fname3,hfac=1.7,vfac=1.2,cubefac=75)</code></pre><p>The resulting Lefschetz complex is visualized in the last figure of this section.</p><p><img src="../img/lefschetzex6.png" alt="A randomly perturbed cubical complex"/></p><h2 id="Lefschetz-Complex-Operations"><a class="docs-heading-anchor" href="#Lefschetz-Complex-Operations">Lefschetz Complex Operations</a><a id="Lefschetz-Complex-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Lefschetz-Complex-Operations" title="Permalink"></a></h2><p>Once a Lefschetz complex has been created, there are a number of manipulations and queries that one has to be able to perform on the complex. At the moment, <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> supplies a number of functions for this. The following four functions  provide <em>basic information</em>:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_information"><code>lefschetz_information</code></a> provides basic information about the Lefschetz complex, including its Euler characteristic and homology, as well as cell counts by dimension and sparsity percentage of the boundary matrix.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_cell_count"><code>lefschetz_cell_count</code></a> returns the number of cells in each dimension in a vector of length <code>lc.dim + 1</code>. If the optional parameter <code>bounds=true</code> is passed, then the function also returns two integer vectors <code>lo</code> and <code>hi</code>. These contain the beginning and end indices of the cells in each dimension.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_field"><code>lefschetz_field</code></a> returns the field <span>$F$</span> over which the Lefschetz complex is defined as a <code>String</code>.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_is_closed"><code>lefschetz_is_closed</code></a> determines whether a given Lefschetz complex cell subset is closed or not.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_is_locally_closed"><code>lefschetz_is_locally_closed</code></a> checks whether a given Lefschetz complex cell subset is locally closed or not.</li></ul><p>The next set of functions can be used to extract certain <em>topological features</em> from a Lefschetz complex:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_boundary"><code>lefschetz_boundary</code></a> computes the support of the boundary <span>$\partial\sigma$</span> of a Lefschetz complex cell <span>$\sigma$</span>. In other words, it returns the vector of all facets of <span>$\sigma$</span>. The cell can either be specified via its index or its label, and the return format corresponds to the input format.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_coboundary"><code>lefschetz_coboundary</code></a> returns all cells which lie in the coboundary of the specified cell <span>$\sigma$</span>, i.e., it returns all cells which have <span>$\sigma$</span> as a facet.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_closure"><code>lefschetz_closure</code></a> determines the closure of a  given cell subset, i.e., the union of all faces of cells in the cell subset.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_interior"><code>lefschetz_interior</code></a> determines the interior of a  given cell subset. For this, the Lefschetz complex is interpreted as a finite topological space, where a set <span>$A$</span> is open if and only if for every cell <span>$\sigma \in A$</span> all of its cofaces are also contained in the set <span>$A$</span>.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_openhull"><code>lefschetz_openhull</code></a> computes the open hull of a cell subset, i.e., the smallest open set which contains the given cell subset. For this, we again interpret a Lefschetz complex as a finite topological space as above.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_topboundary"><code>lefschetz_topboundary</code></a> computes the topological boundary of a cell subset, i.e., the set difference of the closure and the interior of the set. Note that this usually differs from the (algebraic) boundary mentioned above.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_lchull"><code>lefschetz_lchull</code></a> finds the locally closed hull of a Lefschetz complex subset. This is the smallest locally closed set which contains the given cell subset. One can show that  it is the intersection of the closure and the open hull of the cell subset.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_clomo_pair"><code>lefschetz_clomo_pair</code></a> determines the closure-mouth-pair associated with a Lefschetz complex subset.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_skeleton"><code>lefschetz_skeleton</code></a> computes the <span>$k$</span>-dimensional skeleton of a Lefschetz complex or of a given Lefschetz complex subset. While in the first case the <span>$k$</span>-skeleton of the full Lefschetz complex is returned, in the second case it returns the <span>$k$</span>-skeleton of the closure of the given subset.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.manifold_boundary"><code>manifold_boundary</code></a> returns a list of cells which form the &quot;manifold boundary&quot; of the given Lefschetz complex. More  precisely, if the complex has dimension <span>$d$</span>, then it determines all cells of dimension <span>$d-1$</span> which have at most one cell in their coboundary, as well as all cells of dimensions less than <span>$d-1$</span> which have no cell in their coboundary, and finally returns the closure of the resulting cell subset.</li></ul><p>The following functions create <em>Lefschetz subcomplexes</em> from a Lefschetz complex:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_subcomplex"><code>lefschetz_subcomplex</code></a> determines a Lefschetz subcomplex from a given Lefschetz complex. The subcomplex has to be locally closed, and it is given by a collection of cells.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_closed_subcomplex"><code>lefschetz_closed_subcomplex</code></a> extracts a closed Lefschetz subcomplex from the given Lefschetz complex. The subcomplex is the closure of the specified collection of cells.</li></ul><p>In addition, it is possible to create a new Lefschetz complex from an existing one using the following functions:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.permute_lefschetz_complex"><code>permute_lefschetz_complex</code></a> determines a new Lefschetz complex which is obtained from the original one by a permutation of the cells. Note that the permutation has to respect the ordering of the cells by dimension, otherwise an error is raised. In other words, the permutation has to decompose into permutations within each dimension. This is automatically done if no permutation is explicitly specified and the function creates a random one.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_reduction"><code>lefschetz_reduction</code></a> uses <em>elementary reductions</em> to transform a Lefschetz complex into a smaller one while preserving homology. In fact, the new complex is chain homotopic to the  original one. For this, one has to specify a sequence of <em>reduction pairs</em>, which are disjoint pairs of cells whose dimensions differ by one, and such that one cell is a face of the other, once the earlier reductions have been performed. This function is based on [<a href="../references/#kaczynski_etal_98a">KMS98</a>]. It returns a new Lefschetz complex which no longer contains the cells contained in the reduction  pairs.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_reduction_maps"><code>lefschetz_reduction_maps</code></a> is an extension of the previous function <a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_reduction"><code>lefschetz_reduction</code></a>. While it performs the same basic Lefschetz complex reduction, it does compute useful additional  information. Besides the reduced Lefschetz complex, it also returns the chain equivalences between the original and the reduced complex, as well as the chain homotopy relating one of their compositions to the identity. The return values of this function are as follows:<ul><li><code>lcred</code>: The first return variable contains the reduced Lefschetz complex, just as in the previous function.</li><li><code>pp</code>: This is a sparse matrix representation of the chain equivalence between the original complex and the reduced one.</li><li><code>jj</code>: This sparse matrix gives the chain equivalence between the reduced complex and the original one.</li><li><code>hh</code>: The third sparse matrix represents the chain homotopy which shows that the composition <code>jj * pp</code> is chain homotopic to the identity.</li></ul>Note that these maps are constructed in such a way that the product <code>pp * jj</code> always is the identity.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_newbasis"><code>lefschetz_newbasis</code></a> creates a new Lefschetz complex <code>lcnew</code> from the given Lefschetz complex <code>lc</code> via a change of basis. The new basis has to be specified in the sparse matrix <code>basis</code>, whose columns represent the new basis in terms of the existing one. The basis matrix has to respect the grading by dimension, i.e., the cells which are used to form a new basis chain have to have the same dimensions as the cell which is being replaced.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_newbasis_maps"><code>lefschetz_newbasis_maps</code></a> extends the previous function in that besides the new Lefschetz complex <code>lcnew</code> it also returns the chain maps <code>pp</code> and <code>jj</code> which are the respective isomorphisms from the original complex <code>lc</code> to <code>lcnew</code>, and vice versa, as well as the zero chain homotopy <code>hh</code>.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.compose_reductions"><code>compose_reductions</code></a> can be used to find the composed chain maps and chain homotopy for a pair of subsequent reductions. These can be produced either via the function <a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_reduction_maps"><code>lefschetz_reduction_maps</code></a> or the function <a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_newbasis_maps"><code>lefschetz_newbasis_maps</code></a>.</li></ul><p>It was shown in [<a href="../references/#edelsbrunner_mrozek_23a">EM23</a>] that suitable reduction pairs for <a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_reduction"><code>lefschetz_reduction</code></a> can be found easily via the concept of filters. A <em>filter</em> on a Lefschetz complex is a function <span>$\varphi : X \to {\mathbb R}$</span> which has the property that <span>$\varphi(x) \le \varphi(y)$</span> if <span>$x$</span> is a face of <span>$y$</span>. Every such filter induces <em>shallow pairs</em>, which in the case of an injective filter generate a gradient Forman vector field on the Lefschetz complex. It turns out that these shallow pairs can be used to reduce the complex. In <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> there are three functions for working with filters:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.create_random_filter"><code>create_random_filter</code></a> creates a random injective filter on a Lefschetz complex. The filter is created by assigning integers to cell groups, increasing with dimension. Within each dimension the assignment is random, but all filter values of cells of dimension <span>$k$</span> are less than all filter values of cells with dimension <span>$k+1$</span>. The function returns the filter as <code>Vector{Int}</code>, with indices corresponding to the cell indices in the Lefschetz complex.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.filter_shallow_pairs"><code>filter_shallow_pairs</code></a> finds all shallow pairs for the filter <span>$\varphi$</span>. These are face-coface pairs <span>$(x,y)$</span> whose dimensions differ by one, and such that <span>$y$</span> has the smallest filter value on the coboundary of <span>$x$</span>, and <span>$x$</span> has the largest filter value on the boundary of <span>$y$</span>. For injective filters, these pairs give rise to a Forman vector field on the underlying Lefschetz complex. For noninjective filters this is not true in general.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.filter_induced_mvf"><code>filter_induced_mvf</code></a> returns the smallest multivector field which has the property that every shallow pair is contained in a multivector. For injective filters this is a Forman vector field, but in the noninjective case it can be a general multivector field.</li></ul><p>There are also two <em>helper functions</em> which can sometimes  be useful:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_gfp_conversion"><code>lefschetz_gfp_conversion</code></a> changes the base field of the given Lefschetz complex from the rationals <span>$\mathbb{Q}$</span> to a finite field <span>$GF(p)$</span>. Note that it is not possible to perform the reverse conversion.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_filtration"><code>lefschetz_filtration</code></a> computes a filtration on a Lefschetz subset. Based on integer filtration values assigned to some cells of the given Lefschetz complex, it determines the smallest closed subcomplex <code>lcsub</code> which contains all cells with nonzero filtration values, as well as filtration values <code>fvalsub</code> on this subcomplex, which give rise to a filtration of closed subcomplexes, and which can be used to compute persistent homology.</li></ul><p>In addition, <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> provides the following helper functions for the fundamental objects of <em>cells and cell subsets</em>, which can be represented either by integer cell indices or by cell labels:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.convert_cells"><code>convert_cells</code></a> converts a vector of cells from integer to label format, or vice versa.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.convert_cellsubsets"><code>convert_cellsubsets</code></a> converts a vector of cell subsets from integer to label format, and vice versa.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.cellsubset_bounding_box"><code>cellsubset_bounding_box</code></a> computes the bounding box for a cell subset, provided coordinates for the vertices of the Lefschetz complex are provided. The bounding box is purely based on the location of the vertices.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.locate_planar_cellsubsets"><code>locate_planar_cellsubsets</code></a> expects a list of cell subsets, for example the collection of Morse sets, or a multivector field, and it extracts the subsets whose closure lies in the interior of a geometric object <span>$G$</span>, and also the ones whose closure intersects the boundary of <span>$G$</span>. At the moment, <span>$G$</span> can be either a planar rectangle with sides  parallel to the coordinate axes, or a circle in the plane. The same command is used for both, the version of <span>$G$</span> is selected through the function arguments via multiple dispatch.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.cellsubset_location_rectangle"><code>cellsubset_location_rectangle</code></a> determines the  location of the closure of a given cell subset relative to a rectangle in the plane. It distinguishes between being in the interior, intersecting the boundary, or lying in the exterior. The rectangle has to be parallel to the coordinate axes.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.cellsubset_location_circle"><code>cellsubset_location_circle</code></a> determines the  location of the closure of a given cell subset relative to a circle in the plane. It distinguishes between being in the interior, intersecting the boundary, or lying in the exterior.</li></ul><p>Finally, there are a couple of <em>geometry helper functions</em> which allow for the transformation of vertex coordinates in a Lefschetz complex:</p><ul><li><a href="../../apicore/lefschetz/#ConleyDynamics.convert_planar_coordinates"><code>convert_planar_coordinates</code></a> transforms a given collection of planar coordinates in such a way that the extreme coordinates fit precisely in a given rectangle in the plane.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.convert_spatial_coordinates"><code>convert_spatial_coordinates</code></a> transforms a given collection of spatial coordinates in such a way that the extreme coordinates fit precisely in a given rectangular box in space.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.signed_distance_rectangle"><code>signed_distance_rectangle</code></a> determines the signed distance from a given point to the boundary of a rectangle in the plane. Negative values correspond to the interior, positive values to the exterior.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.signed_distance_circle"><code>signed_distance_circle</code></a> determines the signed distance from a given point to the boundary of a circle in the plane. Negative values correspond to the interior, positive values to the exterior.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.segment_intersects_rectangle"><code>segment_intersects_rectangle</code></a> determines whether a line segment intersects the boundary of an axes-parallel rectangle in the plane.</li><li><a href="../../apicore/lefschetz/#ConleyDynamics.segment_intersects_circle"><code>segment_intersects_circle</code></a> determines whether a line segment intersects a circle in the plane.</li></ul><p>For more details on the usage of any of these functions, please see their documentation in the API section of the manual. </p><h2 id="reflefschetz"><a class="docs-heading-anchor" href="#reflefschetz">References</a><a id="reflefschetz-1"></a><a class="docs-heading-anchor-permalink" href="#reflefschetz" title="Permalink"></a></h2><p>See the <a href="../references/#References">full bibliography</a> for a complete list of references cited throughout this documentation. This section cites the following references:</p><div class="citation noncanonical"><dl><dt>[Ale37]</dt><dd><div>P. Alexandrov. <em>Diskrete Räume</em>. Mathematiceskii Sbornik (N.S.) <strong>2</strong>, 501–518 (1937).</div></dd><dt>[DKMW11]</dt><dd><div>P. Dłotko, T. Kaczynski, M. Mrozek and T. Wanner. <em>Coreduction homology algorithm for regular CW-complexes</em>. <a href="https://doi.org/10.1007/s00454-010-9303-y">Discrete &amp; Computational Geometry <strong>46</strong>, 361–388</a> (2011).</div></dd><dt>[EM23]</dt><dd><div>H. Edelsbrunner and M. Mrozek. <a href="https://arxiv.org/abs/2311.14364v2"><em>The depth poset of a filtered Lefschetz complex</em></a> (2023), <a href="https://arxiv.org/abs/2311.14364v2">arXiv:2311.14364v2 [math.AT]</a>.</div></dd><dt>[KMM04]</dt><dd><div>T. Kaczynski, K. Mischaikow and M. Mrozek. <em>Computational Homology</em>. Vol. 157 of <em>Applied Mathematical Sciences</em> (Springer-Verlag, New York, 2004).</div></dd><dt>[KMS98]</dt><dd><div>T. Kaczynski, M. Mrozek and M. Slusarek. <em>Homology computation by reduction of chain complexes</em>. Computers &amp; Mathematics with Applications <strong>35</strong>, 59–70 (1998).</div></dd><dt>[Lef42]</dt><dd><div>S. Lefschetz. <em>Algebraic Topology</em>. Vol. 27 of <em>American Mathematical Society Colloquium Publications</em> (American Mathematical Society, New York, 1942).</div></dd><dt>[LKMW23]</dt><dd><div>M. Lipinski, J. Kubica, M. Mrozek and T. Wanner. <em>Conley-Morse-Forman theory for generalized combinatorial             multivector fields on finite topological spaces</em>. <a href="https://doi.org/10.1007/s41468-022-00102-9">Journal of Applied and Computational Topology <strong>7</strong>, 139–184</a> (2023).</div></dd><dt>[Mas91]</dt><dd><div>W. S. Massey. <em>A Basic Course in Algebraic Topology</em>. Vol. 127 of <em>Graduate Texts in Mathematics</em> (Springer-Verlag, New York, 1991).</div></dd><dt>[MB09]</dt><dd><div>M. Mrozek and B. Batko. <em>Coreduction homology algorithm</em>. Discrete &amp; Computational Geometry <strong>41</strong>, 96–118 (2009).</div></dd><dt>[MW25]</dt><dd><div>M. Mrozek and T. Wanner. <a href="https://doi.org/10.1007/978-3-031-87600-4"><em>Connection Matrices in Combinatorial Topological Dynamics</em></a>. <em>SpringerBriefs in Mathematics</em> (Springer-Verlag, Cham, 2025).</div></dd><dt>[Mun84]</dt><dd><div>J. R. Munkres. <a href="https://doi.org/10.1007/978-3-031-87600-4"><em>Elements of Algebraic Topology</em></a>. <em>SpringerBriefs in Mathematics</em> (Addison-Wesley, Menlo Park, 1984).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../homology/">Homology »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 15 February 2026 18:56">Sunday 15 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
