<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Homology · ConleyDynamics.jl</title><meta name="title" content="Homology · ConleyDynamics.jl"/><meta property="og:title" content="Homology · ConleyDynamics.jl"/><meta property="twitter:title" content="Homology · ConleyDynamics.jl"/><meta name="description" content="Documentation for ConleyDynamics.jl."/><meta property="og:description" content="Documentation for ConleyDynamics.jl."/><meta property="twitter:description" content="Documentation for ConleyDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ConleyDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ConleyDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../lefschetz/">Lefschetz Complexes</a></li><li class="is-active"><a class="tocitem" href>Homology</a><ul class="internal"><li><a class="tocitem" href="#Lefschetz-Complex-Homology"><span>Lefschetz Complex Homology</span></a></li><li><a class="tocitem" href="#Relative-Homology"><span>Relative Homology</span></a></li><li><a class="tocitem" href="#Persistent-Homology"><span>Persistent Homology</span></a></li><li><a class="tocitem" href="#refhomology"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../conley/">Conley Theory</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../sparse/">Sparse Matrices</a></li><li><a class="tocitem" href="../references/">References</a></li></ul></li><li><span class="tocitem">Core API</span><ul><li><a class="tocitem" href="../../apicore/datastruct/">Composite Data Structures</a></li><li><a class="tocitem" href="../../apicore/lefschetz/">Lefschetz Complex Functions</a></li><li><a class="tocitem" href="../../apicore/homology/">Homology Functions</a></li><li><a class="tocitem" href="../../apicore/conley/">Conley Theory Functions</a></li><li><a class="tocitem" href="../../apicore/examples/">Example Functions</a></li><li><a class="tocitem" href="../../apicore/plots/">Plotting Functions</a></li><li><a class="tocitem" href="../../apicore/sparse/">Sparse Matrix Functions</a></li><li><a class="tocitem" href="../../apicore/apiindex/">Complete API Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Homology</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Homology</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/almost6heads/ConleyDynamics.jl/blob/main/docs/src/man/homology.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Homology"><a class="docs-heading-anchor" href="#Homology">Homology</a><a id="Homology-1"></a><a class="docs-heading-anchor-permalink" href="#Homology" title="Permalink"></a></h1><p>Conley&#39;s theory for the qualitative study of dynamical systems is based on fundamental concepts from algebraic topology. One of these is homology, which studies the topological properties of spaces using algebraic means. As part of <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> a number of homology methods are included. It should be noted that these algorithms are not meant for truly large-scale problems, but mostly for illustrative purposes. They are based on the persistence algorithm described in [<a href="../references/#edelsbrunner_harer_10a">EH10</a>], and have been extended to work for arbitrary Lefschetz complexes over either the rationals or a finite field of prime order. For more serious applications one could use professional implementations such as <em>Gudhi</em>, see [<a href="../references/#gudhi_24a">GUD24</a>].</p><h2 id="Lefschetz-Complex-Homology"><a class="docs-heading-anchor" href="#Lefschetz-Complex-Homology">Lefschetz Complex Homology</a><a id="Lefschetz-Complex-Homology-1"></a><a class="docs-heading-anchor-permalink" href="#Lefschetz-Complex-Homology" title="Permalink"></a></h2><p>The most important notion of homology used in <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> is <em>Lefschetz homology</em>. It generalizes both <em>simplicial homology</em> as  described in [<a href="../references/#munkres_84a">Mun84</a>], and <em>cubical homology</em> in the sense of [<a href="../references/#kaczynski_etal_04a">KMM04</a>]. In order to fix our notation, we provide a brief introduction in the following. For more details, see [<a href="../references/#lefschetz_42a">Lef42</a>].</p><p>As we saw earlier, a Lefschetz complex <span>$X$</span> is a collection of cells with associated nonnegative dimensions, together with a boundary map <span>$\partial$</span> which is induced by the incidence coefficient map <span>$\kappa$</span>. The fundamental idea behind homology is to turn this underlying information into an algebraic form in such a way that the boundary map becomes a linear map. For this, define the <em><span>$k$</span>-th chain group</em> as</p><p class="math-container">\[   C_k(X) = \left\{ \sum_{i=1}^m \alpha_i \sigma_i \; : \;
   \alpha_1, \ldots, \alpha_m \in F \;\;\text{ and }\;\;
   \sigma_1, \ldots, \sigma_m \in X_k \right\} .\]</p><p>Since <span>$X_k$</span> denotes the collection of all cells of dimension <span>$k$</span>, this definition can be rephrased by saying that <span>$C_k(X)$</span> consists of all formal linear combinations of <span>$k$</span>-dimensional cells with coefficients in the underlying field <span>$F$</span>. It is not difficult to see that <span>$C_k(X)$</span> is in fact a vector space over <span>$F$</span>. Moreover, its dimension is equal to the number of <span>$k$</span>-dimensional cells in <span>$X$</span>. The collection of all chain groups is <span>$C(X) = (C_k(X))_{k \in {\mathbb Z}}$</span>, where we let <span>$C_k(X) = \{ 0 \}$</span> for all <span>$k &lt; 0$</span> and <span>$k &gt; \dim X$</span>.</p><p>We now turn our attention to the boundary map. It was already explained how the incidence coefficient map <span>$\kappa$</span> can be used to define the boundary <span>$\partial \sigma \in C_{k-1}(X)$</span> for every <span>$k$</span>-dimensional cell <span>$\sigma \in X_k$</span>. If one further defines</p><p class="math-container">\[   \partial \left( \sum_{i=1}^m \alpha_i \sigma_i \right) =
   \sum_{i=1}^m \alpha_i \partial\sigma_i \in C_{k-1}(X)
   \quad\text{ for }\quad
   \sum_{i=1}^m \alpha_i \sigma_i \in C_k(X) \; ,\]</p><p>then one obtains a map <span>$\partial : C_k(X) \to C_{k-1}(X)$</span>. It is not  difficult to verify that this map is both well-defined and linear. Sometimes, we write <span>$\partial_k$</span> instead of <span>$\partial$</span> to emphasize that we consider the boundary map defined on the <span>$k$</span>-th chain group <span>$C_k(X)$</span>.</p><p>Altogether, the above definitions have equipped us with a sequence of vector spaces and maps between them in the form</p><p class="math-container">\[   \ldots \stackrel{\partial_{k+2}}{\longrightarrow}
   C_{k+1}(X) \stackrel{\partial_{k+1}}{\longrightarrow}
   C_{k}(X) \stackrel{\partial_{k}}{\longrightarrow}
   C_{k-1}(X) \stackrel{\partial_{k-1}}{\longrightarrow} \ldots
   \stackrel{\partial_{1}}{\longrightarrow}
   C_0(X) \stackrel{\partial_{0}}{\longrightarrow} \{ 0 \}
   \stackrel{\partial_{-1}}{\longrightarrow} \ldots ,\]</p><p>and the properties of a Lefschetz complex further imply that</p><p class="math-container">\[   \partial_k \circ \partial_{k+1} = 0
   \quad\text{ for all }\quad
   k \in {\mathbb Z} .\]</p><p>In other words, the pair <span>$(C(X), \partial)$</span> is a <em>chain complex</em>, which consists of a sequence of vector spaces over <span>$F$</span> and linear maps between them. Recall from linear algebra that any linear map induces two important subspaces, which in the context of algebraic topology are given special names as follows:</p><ul><li>The elements of the subspace <span>$Z_k(X) = \mathrm{ker}\; \partial_k$</span> are called the <em><span>$k$</span>-cycles</em> of <span>$X$</span>.</li><li>The elements of the subspace <span>$B_k(X) = \mathrm{im}\; \partial_{k+1}$</span> are called the <em><span>$k$</span>-boundaries</em> of <span>$X$</span>.</li></ul><p>Both of these vector spaces are subspaces of the <span>$k$</span>-th chain group <span>$C_k(X)$</span>. Furthermore, in view of the above identity <span>$\partial_k \circ \partial_{k+1} = 0$</span>, one immediately obtains the subspace inclusion <span>$B_k(X) \subset Z_k(X)$</span>. We can therefore define the quotient space</p><p class="math-container">\[   H_k(X) \; = \;
   Z_k(X) / B_k(X) \; = \;
   \mathrm{ker}\;\partial_k / \mathrm{im}\;\partial_{k+1} .\]</p><p>This vector space is called the <em><span>$k$</span>-th homology group</em> of the Lefschetz complex <span>$X$</span>. It is again a vector space over <span>$F$</span>, and therefore its dimension provides important information. In view of this, the dimension of the <span>$k$</span>-th homology group <span>$H_k(X)$</span> is called the <em><span>$k$</span>-th Betti number of <span>$X$</span></em>, and abbreviated as <span>$\beta_k(X) = \dim H_k(X)$</span>.</p><p>In order to shed some light on the actual meaning of homology, and in particular the Betti numbers, we turn to an example. Consider the simplicial complex <code>sc</code> that was already introduced in the <a href="../tutorial/#Tutorial">Tutorial</a>, and which can be created using the commands</p><pre><code class="language-julia hljs">labels = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;]
simplices = [[&quot;A&quot;,&quot;B&quot;],[&quot;A&quot;,&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;B&quot;,&quot;D&quot;],[&quot;D&quot;,&quot;E&quot;,&quot;F&quot;]]
sc = create_simplicial_complex(labels,simplices)</code></pre><p>This two-dimensional simplicial complex is shown in the figure.</p><p><img src="../img/tutorialsimplex.png" alt="The simplicial complex from the tutorial"/></p><p>For simplicity, we consider the associated Lefschetz complex <span>$X$</span> over the field <span>$F = GF(2)$</span>. Then chains in a chain group are just a sum of individual cells of the same dimension.</p><p>In this simple example, one can determine the cycles and boundaries for <span>$k=1$</span> directly. The vector space <span>$Z_1(X)$</span> of <span>$1$</span>-cycles contains the two nonzero chains <span>$c_1 = \mathrm{AB} + \mathrm{BC} + \mathrm{AC}$</span> and <span>$c_2 = \mathrm{DE} + \mathrm{EF} + \mathrm{DF}$</span>, since one can verify that <span>$\partial c_1 = \partial c_2 = 0$</span>. These are, however, not all nontrivial <span>$1$</span>-cycles, as their sum <span>$c_1 + c_2$</span> is another one. Thus, the first cycle group is given by <span>$Z_1(X) = \{ 0, c_1, c_2, c_1 + c_2 \}$</span>. It is a vector space over <span>$F = GF(2)$</span> of dimension two, and any two nonzero elements of <span>$Z_1(X)$</span> form a basis. What about the <span>$1$</span>-boundaries? The simplicial complex <span>$X$</span> contains only one <span>$2$</span>-cell, namely <span>$\mathrm{DEF}$</span>, and its boundary is given by the chain <span>$c_2$</span>. Thus, the first boundary group is given by <span>$B_1(X) = \{ 0, c_2 \}$</span>, which is a one-dimensional vector space over <span>$F$</span>.</p><p>Combined, one can show that the first homology group <span>$H_1(X)$</span> consists of the two equivalence classes</p><p class="math-container">\[   H_1(X) = \left\{ B_1(X) , \; c_1 + B_1(X) \right\} \; ,\]</p><p>where the class <span>$B_1(X)$</span> is the zero element in <span>$H_1(X)$</span>. This implies that the first homology group is one-dimensional, and we have <span>$\beta_1(X) = 1$</span>. In some sense, the basis element of <span>$H_1(X)$</span>, which is the unique nonzero equivalence class given by <span>$c_1 + B_1(X)$</span>, is <em>represented</em> by the cycle <span>$c_1$</span>.</p><p>The above mathematically precise description can be summarized as follows. All three nontrivial cycles in <span>$Z_1(X)$</span> have the potential to enclose two-dimensional holes in the simplicial complex <span>$X$</span>, since they are chains without boundary. However, some of these potential holes have been filled in by two-dimensional cells. Thus, while <span>$c_1$</span> does indeed represent a hole, the chain <span>$c_2$</span> does not, since its interior is filled in by <span>$\mathrm{DEF}$</span>. Note that the cycle <span>$c_1 + c_2$</span> does not create a second hole, since we have <span>$(c_1 + c_2) - c_1 = c_2 \in B_1(X)$</span>. In other words, the first Betti number counts the number of independent holes in the complex <span>$X$</span>.</p><p>One can extend this discussion also to other dimensions and to general Lefschetz complexes <span>$X$</span>. In this way, one obtains the following informal interpretations of the Betti numbers:</p><ul><li><span>$\beta_0(X)$</span> counts the number of <em>connected components</em> of <span>$X$</span>,</li><li><span>$\beta_1(X)$</span> counts the number of independent <em>holes</em>  in <span>$X$</span>,</li><li><span>$\beta_2(X)$</span> counts the number of independent <em>cavities</em> in <span>$X$</span>.</li></ul><p>In general, one can show that <span>$\beta_k(X)$</span> represents the number of independent <span>$k$</span>-dimensional holes in the Lefschetz complex <span>$X$</span>. For more details, see [<a href="../references/#munkres_84a">Mun84</a>].</p><p>The package <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> provides one function to compute standard homology:</p><ul><li><a href="../../apicore/homology/#ConleyDynamics.homology"><code>homology</code></a> expects one input argument, which has to be  of the Lefschetz complex type <a href="../../apicore/datastruct/#ConleyDynamics.LefschetzComplex"><code>LefschetzComplex</code></a>. It returns a vector <code>betti</code> of integers, whose length is one more than  the dimension of the complex. The <span>$k$</span>-th Betti number <span>$\beta_k(X)$</span> is returned in <code>betti[k+1]</code>.</li></ul><p>We would like to point out that the field <span>$F$</span> is implicit in the data structure for the Lefschetz complex <span>$X$</span>, and therefore it does not have to be specified. It can always be queried using the function <a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_field"><code>lefschetz_field</code></a>. For the above example one obtains</p><pre><code class="language-julia hljs">julia&gt; homology(sc)
3-element Vector{Int64}:
 1
 1
 0</code></pre><p>This clearly gives the correct Betti numbers, as we have already seen that this simplicial complex has one hole, and it is obviously connected.</p><p><img src="../img/lefschetzex2.png" alt="Sample simplicial complex"/></p><p>The simplicial complex shown in the second figure can be created using the commands</p><pre><code class="language-julia hljs">labels2 = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;]
simplices2 = [[&quot;A&quot;,&quot;B&quot;],[&quot;A&quot;,&quot;F&quot;],[&quot;B&quot;,&quot;F&quot;],[&quot;B&quot;,&quot;C&quot;,&quot;G&quot;],[&quot;D&quot;,&quot;E&quot;,&quot;H&quot;],[&quot;C&quot;,&quot;D&quot;],[&quot;G&quot;,&quot;H&quot;]]
sc2 = create_simplicial_complex(labels2,simplices2)</code></pre><p>and its homology can then be determined as follows:</p><pre><code class="language-julia hljs">julia&gt; homology(sc2)
3-element Vector{Int64}:
 1
 2
 0</code></pre><p>This complex is also connected, and therefore one has <span>$\beta_0(X) = 1$</span>. However, this time one obtains two independent holes, which results in <span>$\beta_1(X) = 2$</span>.</p><p><img src="../img/lefschetzex4.png" alt="Sample cubical complex"/></p><p>Similarly, the cubical complex depicted in the next figure can be generated via</p><pre><code class="language-julia hljs">cubes = [&quot;00.11&quot;, &quot;01.01&quot;, &quot;02.10&quot;, &quot;11.10&quot;, &quot;11.01&quot;, &quot;22.00&quot;, &quot;20.11&quot;, &quot;31.01&quot;]
cc = create_cubical_complex(cubes)</code></pre><p>and its Betti numbers are given by</p><pre><code class="language-julia hljs">julia&gt; homology(cc)
3-element Vector{Int64}:
 2
 1
 0</code></pre><p>In  this case, the complex has two components and one hole. As a final example, consider a simplicial complex which consists of the manifold boundary of a  single cube. Such a complex can be generated using the commands</p><pre><code class="language-julia hljs">cc2,~ = create_cubical_box(1, 1, 1)
mbcells = manifold_boundary(cc2)
cc2bnd = lefschetz_subcomplex(cc2, mbcells)</code></pre><p>This time, the homology of the resulting cubical complex is given by the Betti numbers</p><pre><code class="language-julia hljs">julia&gt; homology(cc2bnd)
3-element Vector{Int64}:
 1
 0
 1</code></pre><p>This complex is connected and has no holes, but it does have one cavity. As shown, these observations translate into the Betti numbers <span>$\beta_0(X) = 1$</span> and <span>$\beta_1(X) = 0$</span>, as well as <span>$\beta_2(X) = 1$</span>.</p><p>Beyond these simple illustrative examples, homology can be a useful tool in a variety of applied settings. For example, it can be used to quantify the evolution of material microstructures during phase separation processes, see for example [<a href="../references/#gameiro_etal_05a">GMW05</a>].</p><h2 id="Relative-Homology"><a class="docs-heading-anchor" href="#Relative-Homology">Relative Homology</a><a id="Relative-Homology-1"></a><a class="docs-heading-anchor-permalink" href="#Relative-Homology" title="Permalink"></a></h2><p>For the definition of the Conley index of an isolated invariant set another notion of homology is essential, namely <em>relative homology</em>. For this, we assume that <span>$X$</span> is a Lefschetz complex, and <span>$Y \subset X$</span> is a closed subset. In other words, for every  cell in <span>$Y$</span>, all of its faces are contained in <span>$Y$</span> as well.  Then <em>relative homology</em> defines a sequence of groups <span>$H_k(X,Y)$</span> for <span>$k \in \mathbb{Z}$</span> which basically measures the topological properties of <span>$X$</span> if the subset <span>$Y$</span> is contracted to a point and then forgotten.</p><p>This admittedly very vague definition can be made precise in a number of ways. Two of these can easily be described:</p><ul><li>We have already seen that any locally closed subset of a Lefschetz complex is again a Lefschetz complex. Since the subset <span>$Y \subset X$</span> is closed, its complement <span>$X \setminus Y$</span> is open, and hence locally closed as well. Thus, the complement <span>$X \setminus Y$</span> is again a Lefschetz complex. It has been shown in [<a href="../references/#mrozek_batko_09a">MB09</a>, Theorem 3.5] that then<p class="math-container">\[   H_k(X,Y) \cong H_k(X \setminus Y)
   \quad\text{ for all }\quad
   k \in \mathbb{Z} .\]</p>In other words, the <em>relative homology</em> of the pair <span>$(X,Y)$</span> is just the regular homology of the Lefschetz complex given by the set <span>$X \setminus Y$</span>, with the incidence coefficient map inherited  from <span>$X$</span>.</li><li>On a more topological level, one can also think of the relative homology of <span>$(X,Y)$</span> in the following way. In the complex <span>$X$</span>, identify all cells in <span>$Y$</span> to a single point, in the sense of the <em>quotient space</em> <span>$X / Y$</span> defined in a standard topology course. Then one can show that<p class="math-container">\[   H_k(X,Y) \cong \tilde{H}_k(X / Y)
   \quad\text{ for all }\quad
   k \in \mathbb{Z} ,\]</p>where <span>$\tilde{H}_k(Z)$</span> denotes the <em>reduced homology</em> of a space <span>$Z$</span>. While the details of this latter notion of homology can be found in [<a href="../references/#munkres_84a">Mun84</a>, Section 7], for our purposes it suffices to note that the Betti numbers in reduced homology can be obtained from the ones in regular homology by decreasing the <span>$0$</span>-th Betti number by <span>$1$</span>, and keeping all other Betti numbers unchanged.</li></ul><p>The precise mathematical definition of relative homology can be found in [<a href="../references/#munkres_84a">Mun84</a>, Section 9], and it is briefly introduced in the following. Since the <span>$k$</span>-th chain group of a Lefschetz complex consists of all formal linear combinations of <span>$k$</span>-dimensional cells, one can consider the vector space <span>$C_k(Y)$</span> as a subspace of <span>$C_k(X)$</span>. Thus, it makes sense to form the quotient groups</p><p class="math-container">\[   C_k(X,Y) = C_k(X) / C_k(Y)\]</p><p>as in linear algebra. Moreover, if one considers a class <span>$[x] \in C_k(X,Y)$</span> represented by some <span>$x \in C_k(X)$</span>, then the definition</p><p class="math-container">\[   \partial [x] = [\partial x] \in C_{k-1}(X, Y)
   \quad\text{ for }\quad
   [x] \in C_k(X, Y)\]</p><p>gives a well-defined linear map <span>$\partial : C_k(X,Y) \to C_{k-1}(X,Y)$</span> which satisfies <span>$\partial \circ \partial = 0$</span>. In other words, the collection <span>$(C_k(X,Y))_{k \in \mathbb{Z}}$</span> equipped with this boundary operator <span>$\partial$</span> is a chain complex, and its associated homology groups <span>$H_k(X,Y)$</span> are called the <em>relative homology groups of the pair <span>$(X,Y)$</span></em>. Notice that by forming the quotient spaces <span>$C_k(X) / C_k(Y)$</span>, the chains in the subspace are all identified and set to zero, as mentioned earlier.</p><p>In <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a>, relative homology can be computed using <a href="../../apicore/homology/#ConleyDynamics.relative_homology"><code>relative_homology</code></a>. There are two possible ways to invoke this function:</p><ul><li>The method <a href="../../apicore/homology/#ConleyDynamics.relative_homology"><code>relative_homology(lc::LefschetzComplex, subc::Cells)</code></a> expects a Lefschetz complex <code>lc</code> which represents <span>$X$</span>, together with a list of cells <code>subc</code>. The closure of this cell list determines the closed subcomplex <span>$Y$</span>.</li><li>The method <a href="../../apicore/homology/#ConleyDynamics.relative_homology"><code>relative_homology(lc::LefschetzComplex, subc::Cells, subc0::Cells)</code></a> expects an ambient Lefschetz complex specified by the argument <code>lc</code>. The Lefschetz complex <span>$X$</span> is then the closure of the cell list <code>subc</code>, while the subcomplex <span>$Y$</span> is given by the closure of the cell list <code>subc0</code>. These closures are automatically computed by the function.</li></ul><p>Both versions of <a href="../../apicore/homology/#ConleyDynamics.relative_homology"><code>relative_homology</code></a> return the relative  homology as a vector <code>betti</code> of Betti numbers, where <code>betti[k]</code> is the Betti number in dimension <code>k-1</code>. Notice also that the necessary cell list arguments have to be variables of the type <code>Cells = Union{Vector{Int},Vector{String}}</code>, i.e., they can be given in either label or index form.</p><p><img src="../img/lefschetzex2.png" alt="Sample simplicial complex"/></p><p>In order to briefly illustrate the different usages of the command <a href="../../apicore/homology/#ConleyDynamics.relative_homology"><code>relative_homology</code></a>, we consider again the simplicial complex shown in the figure, which can be generated using the commands</p><pre><code class="language-julia hljs">labels2 = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;]
simplices2 = [[&quot;A&quot;,&quot;B&quot;],[&quot;A&quot;,&quot;F&quot;],[&quot;B&quot;,&quot;F&quot;],[&quot;B&quot;,&quot;C&quot;,&quot;G&quot;],[&quot;D&quot;,&quot;E&quot;,&quot;H&quot;],[&quot;C&quot;,&quot;D&quot;],[&quot;G&quot;,&quot;H&quot;]]
sc2 = create_simplicial_complex(labels2,simplices2)</code></pre><p>If we identify the vertices <span>$\mathrm{A}$</span> and <span>$\mathrm{E}$</span>, then an additional loop is created along the bottom of the original simplicial complex. This leads to the following relative homology:</p><pre><code class="language-julia hljs">julia&gt; relative_homology(sc2, [&quot;A&quot;,&quot;E&quot;])
3-element Vector{Int64}:
 0
 3
 0</code></pre><p>Note that the <span>$0$</span>-th Betti number becomes zero, since these identified vertices are considered as zero in the chain group <span>$C_0(X,Y)$</span>. On the other hand, if we consider the boundary of the triangle <span>$\mathrm{DEH}$</span> as the subcomplex <span>$Y$</span>, then one obtains:</p><pre><code class="language-julia hljs">julia&gt; relative_homology(sc2, [&quot;DE&quot;,&quot;DH&quot;,&quot;EH&quot;])
3-element Vector{Int64}:
 0
 2
 1</code></pre><p>Again, the <span>$0$</span>-th Betti number is reduced by one. But this time, the first Betti number does not change, as no new holes are created. Nevertheless, collapsing the boundary of the triangle to a point does create a cavity, and therefore the <span>$2$</span>-nd Betti number is now one. One can also just consider the closure of the triangle  <span>$\mathrm{BCG}$</span> as a Lefschetz complex <span>$X$</span>, and use its boundary as subcomplex <span>$Y$</span>. In this case we get:</p><pre><code class="language-julia hljs">julia&gt; relative_homology(sc2, [&quot;BCG&quot;], [&quot;BC&quot;,&quot;BG&quot;,&quot;CG&quot;])
3-element Vector{Int64}:
 0
 0
 1</code></pre><p>This is the reduced homology of a two-dimensional sphere, which is the topological space obtained from the quotient space <span>$X / Y$</span>. As our final example, consider the closed edge <span>$\mathrm{AB}$</span> as Lefschetz complex <span>$X$</span>, and the vertex <span>$\mathrm{B}$</span> as subcomplex <span>$Y$</span>, then the relative homology of the pair <span>$(X,Y)$</span> is given by</p><pre><code class="language-julia hljs">julia&gt; relative_homology(sc2, [&quot;AB&quot;], [&quot;B&quot;])
3-element Vector{Int64}:
 0
 0
 0</code></pre><p>In this case, all Betti numbers are zero. This can also be seen by recalling that this relative homology is isomorphic to the relative homology of the two-element Lefschetz complex which consists only of the edge <span>$\mathrm{AB}$</span> and the vertex <span>$\mathrm{A}$</span>:</p><pre><code class="language-julia hljs">julia&gt; homology(lefschetz_subcomplex(sc2, [&quot;A&quot;,&quot;AB&quot;]))
2-element Vector{Int64}:
 0
 0</code></pre><p>Note that one obtains a Betti number vector of length two, since this subcomplex has dimension one.</p><h2 id="Persistent-Homology"><a class="docs-heading-anchor" href="#Persistent-Homology">Persistent Homology</a><a id="Persistent-Homology-1"></a><a class="docs-heading-anchor-permalink" href="#Persistent-Homology" title="Permalink"></a></h2><p>Even though the notion of persistence is not strictly necessary for the study of combinatorial topological dynamics, the package <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a> provides rudimentary support for the computation of persistence intervals for filtrations of Lefschetz complexes. A detailed introduction to persistence can be found in the book [<a href="../references/#edelsbrunner_harer_10a">EH10</a>], and we briefly provide an intuitive definition and some examples below.</p><p>Persistent homology is concerned with the creation and destruction of topological features in a sequence of nested Lefschetz complexes. More precisely, consider the sequence of Lefschetz complexes</p><p class="math-container">\[   X^{(1)} \subset X^{(2)}
   \subset \ldots \subset X^{(n)} ,\]</p><p>where we assume that <span>$X^{(k)}$</span> is closed in <span>$X^{(n)}$</span> for  all <span>$1 \le k &lt; n$</span>. This is called a <em>filtration</em> of Lefschetz complexes. As we have seen above, every one of the complexes <span>$X^{(k)}$</span> has associated homology groups, and the notion of persistence is concerned with how these groups change as <span>$k$</span> is increased from <span>$1$</span> to <span>$n$</span>. More precisely, this is based on the following intuition:</p><ul><li>For <span>$k = 1$</span>, the Betti numbers of the Lefschetz complex <span>$X^{(1)}$</span> describe how many nontrivial holes the complex has in each dimension. Each of these holes is represented by a cycle which generates the associated homology class. One then says that each of these homology classes is <em>born</em> at <span>$k=1$</span>.</li><li>As one passes from the complex <span>$X^{(k)}$</span> to the  complex <span>$X^{(k+1)}$</span>, for <span>$k = 1,\ldots,n-1,$</span> these Betti numbers can change in a number of ways:<ul><li>A new homology class is created in <span>$X^{(k+1)}$</span>, which leads to an increase in the corresponding Betti number. As before, this means that a new homology class is <em>born</em> at level <span>$k+1$</span>.</li><li>A homology class that was present in <span>$X^{(k)}$</span> is no longer present in <span>$X^{(k+1)}$</span>. On the one hand, this could be the result of the merging of two separate topological features, such as for example two separate connected components of the complex <span>$X^{(k)}$</span> which become one connected component in <span>$X^{(k+1)}$</span>. On the other hand, the corresponding hole in the complex could have been filled in through the introduction of cells in the set difference <span>$X^{(k+1)} \setminus X^{(k)}$</span>. In either case, we say that the homology class <em>died</em> at level <span>$k+1$</span>.</li></ul></li><li>The <em>persistent homology</em> associated with this filtration then consists of a collection of <em>persistence intervals</em> for each dimension. All of these intervals are of the form <span>$[b,d)$</span>, where <span>$b$</span> denotes the <em>birth time</em> and <span>$d$</span> the <em>death time</em> of a topological feature. Note that some homology classes might still be present in the homology of the final Lefschetz complex <span>$X^{(n)},$</span> and in this case one obtains an interval of the form <span>$[b,\infty)$</span>, i.e., the <em>feature never dies</em>.</li></ul><p>With the above intuitive description one usually can work out the collection of persistence intervals for small and simple examples. There is, however, one final ambiguity that has to be resolved. Suppose that two topological features are born at times <span>$b_1$</span> and <span>$b_2$</span>, and they merge to a single feature at time <span>$d$</span>. Which of these survives into the next complex, and which dies? In this situation, the <em>elder rule</em> applies, which says that the older feature persists. Thus, if <span>$b_1 \ge b_2$</span>, then  one obtains the persistence interval <span>$[b_1,d)$</span>, while the death time <span>$e$</span> in the interval <span>$[b_2,e)$</span> will be determined by a later level, i.e., we have <span>$e &gt; d$</span>.</p><p>In order to illustrate this informal definition, we consider the filtration given by the four simplicial complexes shown in the figures. All of these are subcomplexes of, and the last one is equal to, one of our earlier examples.</p><p><img src="../img/persistence1.png" alt="The 1-st complex in the filtration"/> <img src="../img/persistence2.png" alt="The 2-nd complex in the filtration"/> <img src="../img/persistence3.png" alt="The 3-rd complex in the filtration"/> <img src="../img/persistence4.png" alt="The 4-th complex in the filtration"/></p><p>In this simple example, the persistence intervals in each dimension can be determined easily:</p><ul><li><strong>Dimension 0</strong>: The first complex has one connected  component. A second component, namely the vertex <span>$\mathrm{H}$</span>, is added in <span>$X^{(2)}$</span>. Both of these  components merge in <span>$X^{(3)}$</span>, and no additional components are created. In view of the elder rule, this gives the two persistence intervals <span>$[1,\infty)$</span> and <span>$[2,3)$</span>.</li><li><strong>Dimension 1</strong>: The first hole is created in <span>$X^{(2)},$</span> given by the cycle <span>$\mathrm{AB} + \mathrm{AF} + \mathrm{BF}$</span>. Moreover, in <span>$X^{(3)}$</span> the hole determined by the chain <span>$\mathrm{DE} + \mathrm{DH} + \mathrm{EH}$</span> is added to the mix. Finally, in <span>$X^{(4)}$</span> the latter hole is removed through filling in the triangle <span>$\mathrm{DEH}$</span>, while the hole bounded by the cycle <span>$\mathrm{CD} + \mathrm{DH} + \mathrm{CG} + \mathrm{GH}$</span> is created. This gives the unbounded persistence intervals <span>$[2,\infty)$</span> and <span>$[4,\infty)$</span>, as well as the bounded one <span>$[3,4)$</span>.</li><li><strong>Dimension 2</strong>: None of the complexes form any cavities, and therefore there are no persistence intervals in  dimension two.</li></ul><p>In <a href="https://almost6heads.github.io/ConleyDynamics.jl">ConleyDynamics.jl</a>, there are two functions that provide basic persistence functionality:</p><ul><li>The function <a href="../../apicore/homology/#ConleyDynamics.persistent_homology"><code>persistent_homology</code></a> computes the persistence intervals, and it is usually invoked using the command <code>pinf, ppairs = persistent_homology(lc, filtration)</code>. It expects two arguments: The first is an underlying Lefschetz complex <code>lc</code> of type <a href="../../apicore/datastruct/#ConleyDynamics.LefschetzComplex"><code>LefschetzComplex</code></a>, which has to be the complex <span>$X^{(n)}$</span> in the above notation. The second argument <code>filtration</code> is of type <code>Vector{Int}</code> and has to have length <code>lc.ncells</code>. For each cell index, it contains the integer level <span>$k$</span> of the the first complex <span>$X^{(k)}$</span> in which the cell appears. The function returns two vectors, <code>pinf</code> and <code>ppairs</code>, each of which have length <code>1 + lc.dim</code>, and which contain the following information:<ul><li><code>pinf[k]</code> contains a vector of birth times for all unbounded persistence intervals in dimension <span>$k-1$</span>. It is an empty vector if no such intervals exist.</li><li><code>ppairs[k]</code> contains a vector of pairs <code>(b,d)</code> for each of the bounded persistence interval <span>$[b,d)$</span> in dimension <span>$k-1$</span>. Again, this vector is empty if no such intervals exist.</li></ul>Note that the integer vector <code>filtration</code> has to contain every integer between <span>$1$</span> and <span>$n$</span> at least once, and only these integers. An error is raised if this is not the case, or if the resulting subcomplexes <span>$X^{(k)}$</span> are not closed.</li><li>The function <a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_filtration"><code>lefschetz_filtration</code></a> is meant to simplify the construction of the argument <code>filtration</code>, especially in the situation that <span>$X^{(n)}$</span> is a proper subcomplex of some ambient Lefschetz complex <span>$X$</span>. The function is invoked using the form <code>lcsub, filtration = lefschetz_filtration(lc, partialfil)</code>. The argument <code>lc</code> contains the Lefschetz complex <span>$X$</span>. The  argument <code>partialfil</code> has the type <code>Vector{Int}</code> and is of length <code>lc.ncells</code>. For each cell index <code>j</code> it contains an integer <code>partialfil[j]</code> between <span>$0$</span> and <span>$n$</span>. If the cell appears first in complex <span>$X^{(k)}$</span>, then <code>partialfil[j] = k</code>. This time, however, not all cells have to be specified, since the function automatically computes the complex closure at every level. Clearly, this means that the final complex is the closure of all cells with positive <code>partialfil</code>-values, and this can be a proper subcomplex of <code>lc</code>. The function therefore returns this subcomplex <code>lcsub</code>, together with a filtration <code>filtration</code> which satisfies the requirements of the function <a href="../../apicore/homology/#ConleyDynamics.persistent_homology"><code>persistent_homology</code></a>.</li></ul><p>We close this section with two examples illustrating these  functions. As first example, we consider the filtration given above, which consists of four simplicial complexes. In this case the persistence can be computed using the  commands:</p><pre><code class="language-julia hljs">labels     = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;]
simplices  = [[&quot;A&quot;,&quot;B&quot;],[&quot;A&quot;,&quot;F&quot;],[&quot;B&quot;,&quot;F&quot;],[&quot;B&quot;,&quot;C&quot;,&quot;G&quot;],[&quot;D&quot;,&quot;E&quot;,&quot;H&quot;],[&quot;C&quot;,&quot;D&quot;],[&quot;G&quot;,&quot;H&quot;]]
sc         = create_simplicial_complex(labels,simplices)
filtration = [1,1,1,1,1,2,1,2,
              1,2,1,2,1,1,1,1,3,3,4,
              1,4]
pinf, ppairs = persistent_homology(sc, filtration)</code></pre><p>The first three lines establish the simplicial complex <span>$X^{(4)}$</span>, while the next command defines the filtration. For easier reading, we used different lines for the cells of each dimension. Finally, the last command computes the persistence intervals. The unbounded ones have the birth times</p><pre><code class="language-julia hljs">julia&gt; pinf
3-element Vector{Vector{Int64}}:
 [1]
 [2, 4]
 []</code></pre><p>while the bounded ones are given by</p><pre><code class="language-julia hljs">julia&gt; ppairs
3-element Vector{Vector{Tuple{Int64, Int64}}}:
 [(2, 3)]
 [(3, 4)]
 []</code></pre><p>This is in accordance with our earlier observations. Notice also that the Betti numbers of the final complex <span>$X^{(4)}$</span> in the filtration can easily be determined via</p><pre><code class="language-julia hljs">julia&gt; length.(pinf)
3-element Vector{Int64}:
 1
 2
 0</code></pre><p>With the second example we illustrate the use of the function <a href="../../apicore/lefschetz/#ConleyDynamics.lefschetz_filtration"><code>lefschetz_filtration</code></a>. For this, suppose that the ambient Lefschetz complex <span>$X$</span> is the final simplicial complex in the filtration of the previous example. Within this complex, we  consider the following new filtration:</p><ul><li>The complex <span>$X^{(1)}$</span> is the closure of <span>$\{ \mathrm{CD}, \mathrm{GH} \}.$</span></li><li>The complex <span>$X^{(2)}$</span> is the closure of <span>$X^{(1)} \cup \{ \mathrm{BC}, \mathrm{BG}, \mathrm{DEH} \}.$</span></li><li>The complex <span>$X^{(3)}$</span> is the closure of <span>$X^{(2)} \cup \{ \mathrm{BCG} \}.$</span></li></ul><p>The persistent intervals of this filtration can be determined using the following commands:</p><pre><code class="language-julia hljs">labels    = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;]
simplices = [[&quot;A&quot;,&quot;B&quot;],[&quot;A&quot;,&quot;F&quot;],[&quot;B&quot;,&quot;F&quot;],[&quot;B&quot;,&quot;C&quot;,&quot;G&quot;],[&quot;D&quot;,&quot;E&quot;,&quot;H&quot;],[&quot;C&quot;,&quot;D&quot;],[&quot;G&quot;,&quot;H&quot;]]
sc        = create_simplicial_complex(labels,simplices)
tmpfil    = fill(Int(0),sc.ncells)
tmpfil[sc.indices[&quot;CD&quot;]]  = 1
tmpfil[sc.indices[&quot;GH&quot;]]  = 1
tmpfil[sc.indices[&quot;BC&quot;]]  = 2
tmpfil[sc.indices[&quot;BG&quot;]]  = 2
tmpfil[sc.indices[&quot;DEH&quot;]] = 2
tmpfil[sc.indices[&quot;BCG&quot;]] = 3
scsub, filtration = lefschetz_filtration(sc, tmpfil)
psinf, pspairs = persistent_homology(scsub, filtration)</code></pre><p>The unbounded persistence intervals have birth times</p><pre><code class="language-julia hljs">julia&gt; psinf
3-element Vector{Vector{Int64}}:
 [1]
 [2]
 []</code></pre><p>while the bounded persistence intervals are</p><pre><code class="language-julia hljs">julia&gt; pspairs
3-element Vector{Vector{Tuple{Int64, Int64}}}:
 [(1, 2)]
 []
 []</code></pre><p>Their correctness can immediately be established.</p><p>As we mentioned earlier, more information on persistence can be found in [<a href="../references/#edelsbrunner_harer_10a">EH10</a>], which also contains a detailed  discussion of the implemented persistence algorithm in the context of simplicial complexes. Further examples of persistence computations for general Lefschetz complexes are given in [<a href="../references/#dlotko_wanner_18a">DW18</a>].</p><h2 id="refhomology"><a class="docs-heading-anchor" href="#refhomology">References</a><a id="refhomology-1"></a><a class="docs-heading-anchor-permalink" href="#refhomology" title="Permalink"></a></h2><p>See the <a href="../references/#References">full bibliography</a> for a complete list of references cited throughout this documentation. This section cites the following references:</p><div class="citation noncanonical"><dl><dt>[DW18]</dt><dd><div>P. Dłotko and T. Wanner. <em>Rigorous cubical approximation and persistent homology of             continuous functions</em>. <a href="https://doi.org/10.1016/j.camwa.2017.11.027">Computers &amp; Mathematics with Applications <strong>75</strong>, 1648–1666</a> (2018).</div></dd><dt>[EH10]</dt><dd><div>H. Edelsbrunner and J. L. Harer. <em>Computational Topology</em> (American Mathematical Society, Providence, 2010).</div></dd><dt>[GMW05]</dt><dd><div>M. Gameiro, K. Mischaikow and T. Wanner. <em>Evolution of pattern complexity in the Cahn-Hilliard             theory of phase separation</em>. <a href="https://doi.org/10.1016/j.actamat.2004.10.022">Acta Materialia <strong>53</strong>, 693–704</a> (2005).</div></dd><dt>[KMM04]</dt><dd><div>T. Kaczynski, K. Mischaikow and M. Mrozek. <em>Computational Homology</em>. Vol. 157 of <em>Applied Mathematical Sciences</em> (Springer-Verlag, New York, 2004).</div></dd><dt>[Lef42]</dt><dd><div>S. Lefschetz. <em>Algebraic Topology</em>. Vol. 27 of <em>American Mathematical Society Colloquium Publications</em> (American Mathematical Society, New York, 1942).</div></dd><dt>[MB09]</dt><dd><div>M. Mrozek and B. Batko. <em>Coreduction homology algorithm</em>. Discrete &amp; Computational Geometry <strong>41</strong>, 96–118 (2009).</div></dd><dt>[Mun84]</dt><dd><div>J. R. Munkres. <a href="https://doi.org/10.1007/978-3-031-87600-4"><em>Elements of Algebraic Topology</em></a>. <em>SpringerBriefs in Mathematics</em> (Addison-Wesley, Menlo Park, 1984).</div></dd><dt>[GUD24]</dt><dd><div>GUDHI Project. <a href="https://gudhi.inria.fr/doc/3.10.1/"><em>GUDHI User and Reference Manual</em></a>. 3.10.1 Edition (GUDHI Editorial Board, 2024).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lefschetz/">« Lefschetz Complexes</a><a class="docs-footer-nextpage" href="../conley/">Conley Theory »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Saturday 28 February 2026 17:26">Saturday 28 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
