var documenterSearchIndex = {"docs":
[{"location":"apicore/apiindex/#Complete-API-Index","page":"Complete API Index","title":"Complete API Index","text":"","category":"section"},{"location":"apicore/apiindex/#Index-of-Composite-Data-Structures","page":"Complete API Index","title":"Index of Composite Data Structures","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"datastruct.md\"]","category":"page"},{"location":"apicore/apiindex/#Index-of-Utility-Functions","page":"Complete API Index","title":"Index of Utility Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"utils.md\"]","category":"page"},{"location":"apicore/apiindex/#Index-of-Plotting-Functions","page":"Complete API Index","title":"Index of Plotting Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"plots.md\"]","category":"page"},{"location":"apicore/apiindex/#Index-of-Conley-Theory-Functions","page":"Complete API Index","title":"Index of Conley Theory Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"cmcore.md\"]","category":"page"},{"location":"apicore/apiindex/#Index-of-Homology-Functions","page":"Complete API Index","title":"Index of Homology Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"homology.md\"]","category":"page"},{"location":"apicore/apiindex/#Index-of-Sparse-Matrix-Functions","page":"Complete API Index","title":"Index of Sparse Matrix Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"sparse.md\"]","category":"page"},{"location":"apicore/homology/#Homology-Functions","page":"Homology Functions","title":"Homology Functions","text":"","category":"section"},{"location":"apicore/homology/#Regular-Homology","page":"Homology Functions","title":"Regular Homology","text":"","category":"section"},{"location":"apicore/homology/","page":"Homology Functions","title":"Homology Functions","text":"homology(::LefschetzComplex;::Int)\nrelative_homology(::LefschetzComplex,::Union{Vector{Int},Vector{String}};::Int)\nrelative_homology(::LefschetzComplex,::Union{Vector{Int},Vector{String}},::Union{Vector{Int},Vector{String}};::Int)","category":"page"},{"location":"apicore/homology/#ConleyDynamics.homology-Tuple{LefschetzComplex}","page":"Homology Functions","title":"ConleyDynamics.homology","text":"homology(lc::LefschetzComplex; [p::Int])\n\nCompute the homology of a Lefschetz complex.\n\nThe homology is computed over the rationals (for p=0) or the finite field GF(p) (for prime p) and is returned as a vector betti of Betti numbers, where betti[k] is the Betti number in dimension k-1. If the Lefschetz complex boundary matrix already has been specialized to a field, the optional argument p can be omitted.\n\n\n\n\n\n","category":"method"},{"location":"apicore/homology/#ConleyDynamics.relative_homology-Tuple{LefschetzComplex, Union{Vector{Int64}, Vector{String}}}","page":"Homology Functions","title":"ConleyDynamics.relative_homology","text":"relative_homology(lc::LefschetzComplex,\n                  subc::Union{Vector{Int},Vector{String}};\n                  [p::Int])\n\nCompute the relative homology of a Lefschetz complex with respect to a subcomplex.\n\nThe subcomplex is the closure of the cells in subc, which can be given either as indices or labels. The homology is computed over the rationals (for p=0) or the finite field GF(p) (for prime p) and is returned as a vector betti of Betti numbers, where betti[k] is the Betti number in dimension k-1. If the Lefschetz complex boundary matrix already has been specialized to a field, the optional argument p can be omitted.\n\n\n\n\n\n","category":"method"},{"location":"apicore/homology/#ConleyDynamics.relative_homology-Tuple{LefschetzComplex, Union{Vector{Int64}, Vector{String}}, Union{Vector{Int64}, Vector{String}}}","page":"Homology Functions","title":"ConleyDynamics.relative_homology","text":"relative_homology(lc::LefschetzComplex,\n                  subc::Union{Vector{Int},Vector{String}},\n                  subc0::Union{Vector{Int},Vector{String}};\n                  [p::Int])\n\nCompute the relative homology of a Lefschetz complex with respect to a subcomplex.\n\nIn this implementation, relative homology of the pair cl(subc), cl(subc0)) is computed. An error is raised if cl(subc0) is not a subset of cl(subc). The homology is computed over the rationals (for p=0) or the finite field GF(p) (for prime p) and is returned as a vector betti of Betti numbers, where betti[k] is the Betti number in dimension k-1. If the Lefschetz complex boundary matrix already has been specialized to a field, the optional argument p can be omitted.\n\n\n\n\n\n","category":"method"},{"location":"apicore/homology/#Persistent-Homology","page":"Homology Functions","title":"Persistent Homology","text":"","category":"section"},{"location":"apicore/homology/","page":"Homology Functions","title":"Homology Functions","text":"persistent_homology(::LefschetzComplex,::Vector{Int};::Int)","category":"page"},{"location":"apicore/homology/#ConleyDynamics.persistent_homology-Tuple{LefschetzComplex, Vector{Int64}}","page":"Homology Functions","title":"ConleyDynamics.persistent_homology","text":"persistent_homology(lc::LefschetzComplex, filtration::Vector{Int};\n                    [p::Int])\n\nComplete the persistent homology of a Lefschetz complex filtration.\n\nThe function returns the two values\n\nphsingles::Vector{Vector{Int}}\nphpairs::Vector{Vector{Tuple{Int,Int}}}\n\nIt assumes that the order given by the filtration values is admissible, i.e., the permuted boundary matrix is strictly upper triangular. The persistence computation is performed over the finite field GF(p) (for prime p) or over the rationals (for p=0). The function returns the starting filtration values for infinite length persistence intervals in phsingles, and the birth- and death-filtration values for finite length persistence intervals in phpairs. If the Lefschetz complex boundary matrix already has been specialized to a field, then the optional argument p can be omitted.\n\n\n\n\n\n","category":"method"},{"location":"apicore/homology/#Reduction-Algorithm","page":"Homology Functions","title":"Reduction Algorithm","text":"","category":"section"},{"location":"apicore/homology/","page":"Homology Functions","title":"Homology Functions","text":"ph_reduce!(::SparseMatrix;::Bool)","category":"page"},{"location":"apicore/homology/#ConleyDynamics.ph_reduce!-Tuple{SparseMatrix}","page":"Homology Functions","title":"ConleyDynamics.ph_reduce!","text":"ph_reduce!(matrix::SparseMatrix; [returnbasis=true])\n\nApply the persistence reduction algorithm to the matrix.\n\nThe function returns the values\n\nphsingles::Vector{Vector{Int}}\nphpairs::Vector{Vector{Tuple{Int,Int}}}\nbasis::SparseMatrix (if returnbasis=true)\n\nIt assumes that matrix is strictly upper triangular. The function returns the starting columns for infinite length persistence intervals in phsingles, and the birth- and death-columns for finite length persistence intervals in phpairs. If the optional argument returnbasis=true is given, then the function also returns the computed basis matrix B with reduced = matrix * B.\n\n\n\n\n\n","category":"method"},{"location":"man/lefschetz/#Lefschetz-Complexes","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Here we need a more detailed description of Lefschetz complexes. In particular, this should discuss the various field types that can be used, as well as all the entries in the LefschetzComplex data structure.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"[DKMW11] [LKMW23]","category":"page"},{"location":"man/lefschetz/#Lefschetz-Complexes-References","page":"Lefschetz Complexes","title":"Lefschetz Complexes References","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"P. Dłotko, T. Kaczynski, M. Mrozek and T. Wanner. Coreduction homology algorithm for regular CW-complexes. Discrete & Computational Geometry 46, 361–388 (2011).\n\n\n\nM. Lipinski, J. Kubica, M. Mrozek and T. Wanner. Conley-Morse-Forman theory for generalized combinatorial             multivector fields on finite topological spaces. Journal of Applied and Computational Topology 7, 139–184 (2023).\n\n\n\n","category":"page"},{"location":"man/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"DocTestSetup = quote\n    push!(LOAD_PATH,\"../../../src/\")\n    using ConleyDynamics\nend","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"In the following we discuss a number of connection matrix examples.","category":"page"},{"location":"man/examples/#Critical-flow-on-a-simplex","page":"Examples","title":"Critical flow on a simplex","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_critical_simplex(::Int)","category":"page"},{"location":"man/examples/#ConleyDynamics.example_critical_simplex-Tuple{Int64}","page":"Examples","title":"ConleyDynamics.example_critical_simplex","text":"example_critical_simplex(dim)\n\nCreate a simplicial complex of dimension dim as well as a multivector field on it in which every cell is critical.\n\nThe function returns the Lefschetz complex lc and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_critical_simplex(2);\n\njulia> cm = connection_matrix(lc, mvf, p=2);\n\njulia> sparse_show(cm.cm)\n[0   0   0   1   1   0   0]\n[0   0   0   1   0   1   0]\n[0   0   0   0   1   1   0]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"A\", \"B\", \"C\", \"AB\", \"AC\", \"BC\", \"ABC\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#Combinatorial-flows-on-a-cylinder-and-a-Moebius-strip","page":"Examples","title":"Combinatorial flows on a cylinder and a Moebius strip","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_moebius()","category":"page"},{"location":"man/examples/#ConleyDynamics.example_moebius-Tuple{}","page":"Examples","title":"ConleyDynamics.example_moebius","text":"lc1, mvf1, lc2, mvf2 = example_moebius()\n\nCreate two simplicial complexes for a cylinder and Moebius strip, respectively, together with associated multivector fields on them.\n\nThe function returns the Lefschetz complexes lc1 and lc2, as well as the multivector fields mvf1 and mvf2.\n\nThe multivector field is the same, and it has one critical  cell each in dimension 1 and 2 in the interior of the strip. The boundary consists of two periodic orbits for lc1 and mvf1, and of one periodic orbit in the Moebius case lc2 and mvf2. The latter case leads to different connection matrices for the fields GFP(2) and GFP(7), for example.\n\nExamples\n\njulia> lc1, mvf1, lc2, mvf2 = example_moebius();\n\njulia> cmp2 = connection_matrix(lc2, mvf2; p=2);\n\njulia> cmp7 = connection_matrix(lc2, mvf2; p=7);\n\njulia> sparse_show(cmp2.cm)\n[0   0   0   0]\n[0   0   0   1]\n[0   0   0   0]\n[0   0   0   0]\n\njulia> sparse_show(cmp7.cm)\n[0   0   0   0]\n[0   0   0   1]\n[0   0   0   2]\n[0   0   0   0]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#Nonunique-connection-matrices","page":"Examples","title":"Nonunique connection matrices","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: An example with nonunique connection matrices)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_nonunique()","category":"page"},{"location":"man/examples/#ConleyDynamics.example_nonunique-Tuple{}","page":"Examples","title":"ConleyDynamics.example_nonunique","text":"example_nonunique()\n\nCreate two representations of a simplicial complex and one multivector field which illustrates nonunique connection matrices.\n\nThe two complexes lc1 and lc2 represent the same simplicial complex, but differ in the ordering of the labels.\n\nThe function returns the Lefschetz complexes lc1 and lc2, as well as the multivector field mvf. If desired for plotting, the fourth and fifth return values coords1 and coords2 give vectors of coordinates for the vertices of the two complexes.\n\nExamples\n\njulia> lc1, lc2, mvf = example_nonunique();\n\njulia> cm1 = connection_matrix(lc1, mvf, p=2);\n\njulia> cm2 = connection_matrix(lc2, mvf, p=2);\n\njulia> sparse_show(cm1.cm)\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   0   0   0   0   1   1]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm1.labels)\n[\"1\", \"6\", \"68\", \"18\", \"34\", \"56\", \"057\", \"238\", \"678\"]\njulia> sparse_show(cm2.cm)\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   0   0   0   1   0   1]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm2.labels)\n[\"1\", \"7\", \"67\", \"18\", \"34\", \"56\", \"057\", \"238\", \"678\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#Examples-from-MW-2023","page":"Examples","title":"Examples from MW-2023","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The following examples are taken from [MW23].","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: Four sample combinatorial vector fields)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_MW_fig02()","category":"page"},{"location":"man/examples/#ConleyDynamics.example_MW_fig02-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig02","text":"example_MW_fig02(mvftype)\n\nCreate the simplicial complex and multivector field for the example from Figure 2 in the connection matrix paper by Mrozek & Wanner.\n\nDepending on the value of mvftype, return the periodic orbit (0=default) or one of the three gradient (1,2,3) examples.\n\nThe function returns the Lefschetz complex lc and the multivector field mvf. If desired for plotting, the third return value coords gives a vector of coordinates for the vertices.\n\nExamples\n\njulia> lc, mvf = example_MW_fig02(0);\n\njulia> cm = connection_matrix(lc, mvf; p=0);\n\njulia> print(cm.labels)\n[\"A\", \"C\", \"CE\", \"AC\", \"BD\", \"DF\", \"ABC\", \"EFG\"]\n\njulia> full_from_sparse(cm.cm)\n8×8 Matrix{Rational{Int64}}:\n 0  0  0  -1  -1  0   0  0\n 0  0  0   1   1  0   0  0\n 0  0  0   0   0  0   0  0\n 0  0  0   0   0  0  -1  0\n 0  0  0   0   0  0   1  0\n 0  0  0   0   0  0   0  1\n 0  0  0   0   0  0   0  0\n 0  0  0   0   0  0   0  0\n\n\n\n\n\n","category":"method"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_MW_fig01()\nexample_MW_fig03()\nexample_MW_fig04()\nexample_MW_fig11()","category":"page"},{"location":"man/examples/#ConleyDynamics.example_MW_fig01-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig01","text":"example_MW_fig01()\n\nCreate the simplicial complex and multivector field for the example from Figure 1 in the connection matrix paper by Mrozek & Wanner.\n\nThe function returns the Lefschetz complex lc and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_MW_fig01();\n\njulia> cm = connection_matrix(lc, mvf, p=2);\n\njulia> sparse_show(cm.cm)\n[0   0   0]\n[0   0   1]\n[0   0   0]\n\njulia> print(cm.labels)\n[\"D\", \"AC\", \"ABC\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#ConleyDynamics.example_MW_fig03-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig03","text":"example_MW_fig03()\n\nCreate the Lefschetz complex and multivector field for the example from Figure 3 in the connection matrix paper by Mrozek & Wanner.\n\nThe function returns the Lefschetz complex lc and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_MW_fig03();\n\njulia> cm = connection_matrix(lc, mvf, p=2);\n\njulia> sparse_show(cm.cm)\n[0   0   0   0]\n[0   0   0   0]\n[0   0   0   0]\n[0   0   0   0]\n\njulia> print(cm.labels)\n[\"BD\", \"DF\", \"AC\", \"CE\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#ConleyDynamics.example_MW_fig04-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig04","text":"example_MW_fig04()\n\nCreate two representations of the Lefschetz complex and the multivector field for the example from Figure 4 in the connection matrix paper by Mrozek & Wanner.\n\nThe complexes lc1 and lc2 are just two representations of the same complex, but they lead to different connection matrices.\n\nThe function returns the Lefschetz complexes lc1 and lc2, as well as the multivector field mvf.\n\nExamples\n\njulia> lc1, lc2, mvf = example_MW_fig04();\n\njulia> cm1 = connection_matrix(lc1, mvf);\n\njulia> cm2 = connection_matrix(lc2, mvf);\n\njulia> full_from_sparse(cm1.cm)\n4×4 Matrix{Int64}:\n 0  0  0  0\n 0  0  0  1\n 0  0  0  1\n 0  0  0  0\n\njulia> full_from_sparse(cm2.cm)\n4×4 Matrix{Int64}:\n 0  0  0  0\n 0  0  0  0\n 0  0  0  1\n 0  0  0  0\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#ConleyDynamics.example_MW_fig11-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig11","text":"example_MW_fig11(mvftype)\n\nCreate the Lefschetz complex and multivector field for the example from Figure 11 in the connection matrix paper by Mrozek & Wanner.\n\nDepending on the value of mvftype, return the multivector (0=default) or one of the two combinatorial vector field (1,2) examples.\n\nThe function returns the Lefschetz complex lc and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_MW_fig11(1);\n\njulia> cm = connection_matrix(lc, mvf; p=0);\n\njulia> full_from_sparse(cm.cm)\n5×5 Matrix{Rational{Int64}}:\n 0  0  1  -1  -1\n 0  0  1   0   0\n 0  0  0   0   0\n 0  0  0   0   0\n 0  0  0   0   0\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#Examples-from-BKMW-2020","page":"Examples","title":"Examples from BKMW-2020","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The following examples are taken from [BKMW20].","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_BKMW20_fig1()\nexample_BKMW20_fig3()","category":"page"},{"location":"man/examples/#ConleyDynamics.example_BKMW20_fig1-Tuple{}","page":"Examples","title":"ConleyDynamics.example_BKMW20_fig1","text":"example_BKMW20_fig1()\n\nCreate the simplicial complex and multivector field for the example from Figure 1 in the FoCM 2020 paper by Batko, Kaczynski, Mrozek, and Wanner.\n\nThe function returns the Lefschetz complex lc and the  multivector field mvf. If desired for plotting, the third return value coords gives a vector of coordinates for the vertices.\n\nExamples\n\njulia> lc, mvf = example_BKMW20_fig1();\n\njulia> cm = connection_matrix(lc, mvf, p=2);\n\njulia> sparse_show(cm.cm)\n[0   0   0   0   1]\n[0   0   0   0   0]\n[0   0   0   0   1]\n[0   0   0   0   0]\n[0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"A\", \"AD\", \"F\", \"BF\", \"DE\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#ConleyDynamics.example_BKMW20_fig3-Tuple{}","page":"Examples","title":"ConleyDynamics.example_BKMW20_fig3","text":"example_BKMW20_fig3()\n\nCreate the simplicial complex and multivector field for the example from Figure 3 in the FoCM 2020 paper by Batko, Kaczynski, Mrozek, and Wanner.\n\nThe function returns the Lefschetz complex lc and the multivector field mvf. If desired for plotting, the third return value coords gives a vector of coordinates for the vertices.\n\nExamples\n\njulia> lc, mvf = example_BKMW20_fig3();\n\njulia> cm = connection_matrix(lc, mvf, p=2);\n\njulia> sparse_show(cm.cm)\n[0   0   0   0   1   0   1   0   0]\n[0   0   0   0   0   1   0   0   0]\n[0   0   0   0   1   1   1   0   0]\n[0   0   0   0   0   0   0   0   1]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"D\", \"E\", \"F\", \"GJ\", \"BF\", \"EF\", \"HI\", \"ADE\", \"FGJ\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#Examples-References","page":"Examples","title":"Examples References","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"B. Batko, T. Kaczynski, M. Mrozek and T. Wanner. Linking combinatorial and classical dynamics: Conley             index and Morse decompositions. Foundations of Computational Mathematics 20, 967–1012 (2020).\n\n\n\nM. Mrozek and T. Wanner. Connection matrices in combinatorial topological dynamics, arXiv:2103.04269 (2023).\n\n\n\n","category":"page"},{"location":"man/conley/#Conley-Theory","page":"Conley Theory","title":"Conley Theory","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Here we need a more detailed description of Conley theory, and in particular connection matrices.  In particular, this should discuss the various field types that can be used, as well as all the entries in the ConleyMorseCM data structure.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"[KMW16] [MW21] [MSTW22]","category":"page"},{"location":"man/conley/#Connection-Matrices-References","page":"Conley Theory","title":"Connection Matrices References","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"T. Kaczynski, M. Mrozek and T. Wanner. Towards a formal tie between combinatorial and classical             vector field dynamics. Journal of Computational Dynamics 3, 17–50 (2016).\n\n\n\nM. Mrozek, R. Srzednicki, J. Thorpe and T. Wanner. Combinatorial vs. classical dynamics: Recurrence. Communications in Nonlinear Science and Numerical Simulation 108, Paper No. 106226, 30 pp (2022).\n\n\n\nM. Mrozek and T. Wanner. Creating semiflows on simplicial complexes from combinatorial vector fields. Journal of Differential Equations 304, 375–434 (2021).\n\n\n\n","category":"page"},{"location":"man/references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"man/references/","page":"References","title":"References","text":"B. Batko, T. Kaczynski, M. Mrozek and T. Wanner. Linking combinatorial and classical dynamics: Conley             index and Morse decompositions. Foundations of Computational Mathematics 20, 967–1012 (2020).\n\n\n\nC. Conley. Isolated Invariant Sets and the Morse Index (American Mathematical Society, Providence, R.I., 1978).\n\n\n\nP. Dłotko, T. Kaczynski, M. Mrozek and T. Wanner. Coreduction homology algorithm for regular CW-complexes. Discrete & Computational Geometry 46, 361–388 (2011).\n\n\n\nR. Forman. Combinatorial vector fields and dynamical systems. Mathematische Zeitschrift 228, 629–681 (1998).\n\n\n\nR. Forman. Morse theory for cell complexes. Advances in Mathematics 134, 90–145 (1998).\n\n\n\nT. Kaczynski, M. Mrozek and T. Wanner. Towards a formal tie between combinatorial and classical             vector field dynamics. Journal of Computational Dynamics 3, 17–50 (2016).\n\n\n\nS. Lefschetz. Algebraic Topology. Vol. 27 of American Mathematical Society Colloquium Publications (American Mathematical Society, New York, 1942).\n\n\n\nM. Lipinski, J. Kubica, M. Mrozek and T. Wanner. Conley-Morse-Forman theory for generalized combinatorial             multivector fields on finite topological spaces. Journal of Applied and Computational Topology 7, 139–184 (2023).\n\n\n\nM. Mrozek, R. Srzednicki, J. Thorpe and T. Wanner. Combinatorial vs. classical dynamics: Recurrence. Communications in Nonlinear Science and Numerical Simulation 108, Paper No. 106226, 30 pp (2022).\n\n\n\nM. Mrozek and T. Wanner. Creating semiflows on simplicial complexes from combinatorial vector fields. Journal of Differential Equations 304, 375–434 (2021).\n\n\n\nM. Mrozek and T. Wanner. Connection matrices in combinatorial topological dynamics, arXiv:2103.04269 (2023).\n\n\n\nJ. R. Munkres. Elements of Algebraic Topology (Addison-Wesley, Menlo Park, 1984).\n\n\n\n","category":"page"},{"location":"man/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial explains the basic usage of the main components of ConleyDynamics. It is not meant to be exhaustive, since more details will be provided in the more indiviualized sections. Also, precise mathematical definitions will be delayed until then. The presented examples are taken from the papers [BKMW20] and [MW23], with minor modifications.","category":"page"},{"location":"man/tutorial/#Creating-Lefschetz-Complexes","page":"Tutorial","title":"Creating Lefschetz Complexes","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The fundamental mathematical object for ConleyDynamics is a Lefschetz complex [Lef42]. For now we note that both simplicial complexes and cubical complexes are special cases, and ConleyDynamics provides convenient interfaces for generating them.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"For the sake of simplicity, this tutorial only considers the case of a simplicial complex. Recall that an abstract simplicial complex K is just a collection of finite sets, called simplices, which is closed under taking subsets. In other words, every subset of a simplex is again a simplex. Each simplex has an associated dimension, which is one less than the number of its elements. One usually calls simplices of dimension 0 vertices, edges have dimension 1, and simplices of dimension 2 are triangles. It follows easily from these definitions that every simplex is the union of its vertices.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In ConleyDynamics it is easy to generate a simplicial complex. This requires two objects:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The vertices are described by a vector labels of string labels for the vertices of the simplicial complex. Thus, the length of the vector equals the number of vertices, and the k-th entry is the label for the k-th vertex.\nIn addition, a second vector simplices has to describe enough simplices so that the simplicial complex is determined. This object is a vector of vectors, and the vector simplices[k] describes the index values of all the vertices in the k-th simplex. These indices are precisely the corresponding locations of the vertices in labels.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"tip: Simplices via labels\nIt is also possible to specify the list of simplices using a Vector{Vector{String}}, i.e., as a vector of string vectors. In this case, the entry simplices[k] is a list of the labels of the vertices.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Watch the label length\nIt is expected that the labels in labels all have the same number of characters. This is due to the fact that when creating the simplicial complex, ConleyDynamics automatically creates  labels for each of the simplices in K, by concatenating the vertex labels. Not using a fixed label size could lead to  ambiguities, and will therefore raise an error message.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: A first simplicial complex)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The following first example creates a simple simplicial complex.  The complex is shown in the above figure, and it has six vertices which we label by the first six letters.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"using ..ConleyDynamics # hide\nlabels = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\nsimplices = [[\"A\",\"B\"],[\"A\",\"C\"],[\"B\",\"C\"],[\"B\",\"D\"],[\"D\",\"E\",\"F\"]]\nsc = create_simplicial_complex(labels,simplices)\nfieldnames(typeof(sc))","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Based on the simplex specifications, the generated simplicial complex K consists of three edges connecting each of the vertices A, B, and C, a two-dimensional triangle DEF, as well as the edge BD which connects the triangle boundary and the filled triangle. The created struct sc is of type LefschetzComplex, with fieldnames as indicated in the above output. The number of cells in the complex can be seen as follows:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(sc.ncells)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the final simplicial complex has a total of seven edges, since also the edges of DEF are part of the simplicial complex. They are automatically generated by create_simplicial_complex. The dimension of K is the largest simplex dimensions, and can be recalled via","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(sc.dim)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The sc struct also contains a vector of labels, which in this case takes the form","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(sc.labels)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, the Lefschetz complex data structure for our simplicial complex K also includes the dimensions for the corresponding cells in the integer vector sc.dimensions, a dictionary sc.indices which associates each simplex label with its integer index, and the boundary map sc.boundary which will be described in more detail in Lefschetz Complexes. The latter map is internally stored as an integer sparse matrix.","category":"page"},{"location":"man/tutorial/#Computing-Homology-and-Persistence","page":"Tutorial","title":"Computing Homology and Persistence","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Any simplicial complex, and in fact any Lefschetz complex, has an associated homology. Informally, homology describes the connectivity structure of the simplicial complex. More precisely, the homology consists of a sequence of integers, called the Betti numbers, which are indexed by dimension. There are Betti numbers beta_k(K) for every k = 0ldotsdim K. The zero-dimensional Betti number beta_0(K) gives the number of connected components of K, while beta_1(K) counts the number of independent loops that can be found in K. Finally, beta_2(K) equals the number of cavities. In our case, we have","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"homology(sc, p=0)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This means that the simplicial complex K has one component, as well as one loop, and no cavities. The function homology returns a vector of integers, whose k-th entry is beta_k-1(K). We would like to point out that in ConleyDynamics all homology computations are performed over fields, and  therefore homology is completely described by the Betti numbers. Two types of fields are supported, and they are selected by specifying the field characteristic p:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"If p=0, then the homology computation uses the field of rational numbers.\nFor any prime number p, homology is determined over the finite field GF(p) with p elements. ","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"ConleyDynamics also allows for the computation of relative homology. In the case of relative homology, together with the simplicial complex K one has to specify a closed subcomplex K_0. Intuitively, the relative homology H_*(KK_0) is the homology of a new space, which is obtained from K by identifying K_0 to a single point, and then decreasing the zero-dimensional Betti number by 1. Consider for example the following command:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"relative_homology(sc, [1,6], p=0)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In this case, the subcomplex K_0 consists of the two vertices A and F, which are therefore glued together. This leads to zero Betti numbers in dimension 0 and 2 (remember that the zero-dimensional Betti number is decreased by 1!), and a one-dimensional Betti number of 2. The latter is increased by one since we obtain a second loop by moving from A to F = A along the edges AB, BD, and DF.  Another example is the following:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"relative_homology(sc, [\"DE\",\"DF\",\"EF\"], p=0)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Now the subcomplex K_0 consists of the edges DE, DF, and EF – together with the three vertices D, E, and F which are automatically added by relative_homology. Identifying them all to one point creates a hollow two-dimensional sphere, and the relative Betti numbers reflect that fact.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As the above two examples demonstrate, the subcomplex can be specified either as a list of simplex indices, or through the simplex labels.  Moreover, the specfied subspace simplex list is automatically extended by relative_homology to include all simplex faces, i.e., it computes the simplicial closure to arrive at a closed subcomplex. Finally, note that the subcomplex can be empty:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"relative_homology(sc, [], p=0)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected, in this case one obtains the standard homology of sc.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In addition to regular and relative homology, ConleyDynamics can also compute persistent homology. For this, one has to specify a filtration of closed Lefschetz complexes","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"  K_1 subset K_2 subset ldots subset K_m ","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Then persistent homology tracks the appearance and disappearance (also often called the birth and death) of topological features as one moves through the complexes in the filtration. In ConleyDynamics, one can specify a Lefschetz complex filtration by assigning the integer k to each simplex that first appears in K_k. Moreover, it is expected that K_m = K. Then the persistent homology is computed via the following command:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"filtration = [1,1,1,2,2,2,1,1,1,3,2,2,2,4]\nphsingles, phpairs = persistent_homology(sc, filtration, p=0)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The function returns the persistence intervals, which give the birth and death indices of each topological feature in each dimension. There are two types of intervals:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Intervals of the form ainfty) correspond to topological features that first appear in K_a and are still present in the final complex. The starting indices of such features in dimension k are contained in the list phsingles[k+1].\nIntervals of the form ab) correspond to topological features that first appear in K_a and first disappear in K_b. The corresponding pairs (a,b) in dimension k are contained in the list phsingles[k+1].","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In our above example, one observes intervals 1infty) in dimensions zero and one – and these correspond to a connected component and the loop generated by the edges AB, AC, and BC. These appear first in K_1 and are still present in K_4. The interval 23) in dimension zero represents the new component created by K_2, and it disappears through merging with the older component from K_1 when the edge BD is introduced with K_3. Similarly, the interval 24) in dimension one is the loop created by the triangle DE, DF, and EF in K_2, which disappears with the introduction of the triangle DEF in K_4. Note that the interval death times respect the elder rule: When for example a component disappears through merging, the younger interval gets killed, and the older one continues to live. Similarly in higher dimensions.","category":"page"},{"location":"man/tutorial/#Forman-Vector-Fields","page":"Tutorial","title":"Forman Vector Fields","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The main focus of ConleyDynamics is on the study of combinatorial topological dynamics on Lefschetz complexes. While the phase space as Lefschetz complex has been discussed above, albeit only for the special case of a simplicial complex, the dynamics part can be given in the simplest form by a combinatorial vector field, also called a Forman vector field [For98a, For98b].  We will soon see that such vector fields are a more restrictive version of multivector fields, but they are easier to start with.  The following command defines a simple Forman vector field on our sample simplicial complex K from above:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"formanvf = [[\"A\",\"AC\"],[\"B\",\"AB\"],[\"C\",\"BC\"],[\"D\",\"BD\"],[\"E\",\"DE\"]]","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The Forman vector field formanvf is viualized in the accompanying figure.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: A first Forman vector field)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"According to the figure, a Forman vector field is comprised of arrows, as well as critical cells which are indicated by red dots. Every simplex of the underlying simplicial complex is either critical, or it is contained in a unique arrow. In other words, the collection of critical cells and arrows forms a partition of the simplicial complex K. Arrows always have to consist of precisely two simplices: The source of the arrow is a simplex sigma^-, while its target is a second simplex sigma^+. These two simplices have to be related in the sense that sigma^- is a facet of sigma^+. Recall that a facet of a simplex tau is any subsimplex obtained from tau by removing precisely one vertex, i.e., its dimension is exactly one less that dimtau, and it is therefore contained in the boundary of tau.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As the above Julia code shows, a forman vector field is described by a vector of string vectors, where each of the latter contains the labels of the two simplices making up an arrow. Note that the critical cells are not explicitly listed, as any simplex of K that is not part of a vector is automatically critical. Alternatively, one could define the Forman vector field as a Vector{Vector{Int}}, if the labels are replaced by the corresponding indices in sc.indices.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Intuitively, the above visualization of the Forman vector field formanvf clearly induces dynamical behavior on the simplicial complex sc:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Critical cells can be though of as equilibrium states for the dynamics, i.e., they contain a stationary solution. Depending on their dimension, they can also exhibit nonconstant dynamics – which in backward time converges to the equilibrium, and in forward time flows towards the boundary of the simplex.\nArrow sources always lead to flow into the interior of their target simplex sigma^+.\nArrow targets create flow towards the boundary of sigma^+, except towards the source facet sigma^-.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In the above figure, for example, the simplex EF is a critical cell, so it contains an equilibrium. At the same time, it also allows for flow towards the boundary, which consists of the vertices E and F.  A solution flowing to the former then has to enter DE, flow through D to BD, before entering the periodic orbit given by","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"   B to AB to A to AC to C to BC to B to AB to ldots","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This heuristic description can be made precise. It was shown in [MW21] that for every Forman vector field on a simplicial complex there exists a classical dynamical system which exhibits dynamics consistent with the above interpretation.","category":"page"},{"location":"man/tutorial/#Isolated-Invariant-Sets","page":"Tutorial","title":"Isolated Invariant Sets","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The global dynamical behavior of a Forman vector field on a simplicial complex can be described by first decomposing it into smaller building blocks. An invariant set is a subset S subset K of the simplicial complex such that for every simplex sigma in S there exists a solution through sigma which is contained in S and which exists for all forward and backward time. For example, in our example the following are sample invariant sets:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Every critical cell sigma by itself is an invariant set, since we can choose the constant solution sigma in the above definition. Thus, also every union of critical cells is invariant.\nThe periodic orbit S_P =  A B C AB AC BC  is an invariant set, since the periodic orbit mentioned earlier exists for all forward and backward time in S_P and passes through every simplex of the orbit.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"While it is tempting to try to decompose the dynamics into invariant sets and \"everything else\", Conley realized that a better theory can be built around invariant sets which are isolated [Con78]. In our combinatorial setting, an isolated invariant set is an invariant set S subset K with the following two additional properties:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The set S is locally closed, i.e., the associated set mathrmmo S = mathrmcl S setminus S is closed in the simplicial complex. Recall that the closure mathrmcl A of a set A subset K consists of all simplices which are subsets of simplices in A, and a set is closed if it equals its closure. The set mathrmmo S is called the mouth of S.\nThe set S is compatible with the Forman vector field, i.e., the set is the union of critical cells and arrows. In other words, if one of the  arrow ends is contained in S, then so is the other.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"One can easily see that the periodic orbit S_P is an isolated invariant set, since it is compatible and closed – and therefore mathrmmo S_P = emptyset is closed. Similarly, the single critical simplex S_1 =  DEF  is an isolated invariant set, since in this case the set mathrmmo S_1 =  D E F DE DF EF  is closed, and S_1 is compatible. On the other hand, the invariant set S_2 =  DEF F  is not an isolated invariant set, since the mouth mathrmmo S_2 =  D E DE DF EF  is not closed – despite the fact that S_2 is compatible.  For an example of an invariant set which has a closed mouth but is not compatible, see [KMW16, Figure 5].","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"It follows from the definition of isolation that for every isolated invariant set S subset K the two sets mathrmcl S and mathrmmo S are closed, and that the latter is a (possibly empty) subset of the former. Thus, the relative homology of this pair is defined and we let","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"  CH_*(S) = H_*(mathrmcl S mathrmmo S)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"denote the Conley index of the isolated invariant set. The Conley index can be computed using the command conley_index. For example, for the three critical cells F, DF, and DEF one obtains the following Conley indices:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(conley_index(sc, [\"F\"], p=0))\nprintln(conley_index(sc, [\"DF\"], p=0))\nprintln(conley_index(sc, [\"DEF\"], p=0))","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In other words, the Conley index of a critical cell of dimension k has Betti number beta_k = 1, while the remaining Betti numbers vanish. This is precisely the relative homology of a k-dimensional sphere, relative to a point on the sphere. On the other hand, for the Conley index of the periodic orbit S_P one obtains:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"conley_index(sc, [\"AB\", \"AC\", \"BC\", \"A\", \"B\", \"C\"], p=0)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This Conley index is nontrivial in dimensions 0 and 1. This is exactly the Conley index of an attracting periodic orbit in classical dynamics.","category":"page"},{"location":"man/tutorial/#Connection-Matrices","page":"Tutorial","title":"Connection Matrices","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"One of the main features of ConleyDynamics is its capability to take a given combinatorial vector or multivector field on an arbitrary Lefschetz complex and determine its global dynamical behavior. This is done by computing the connection matrix, which in our setting is discussed in detail in [MW23].  For the sample simplicial complex sc and the Forman vector field formanvf the connection matrix information can be determined as follows:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cm = connection_matrix(sc, formanvf, p=2)\nfieldnames(typeof(cm))","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This command computes the connection matrix over the finite field GF(2) = mathbb Z_2. The connection_matrix function returns a struct which contains the following information regarding the global dynamics of the combinatorial dynamical system:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The field cm.morsesets contains the Morse decomposition of the Forman vector field. This is a collection of isolated invariant sets which capture all recurrent behavior. Outside of these sets, the dynamics is gradient-like, i.e., it moves from one Morse set to another.\nSince each of the Morse sets is an isolated invariant set, they all have an associated Conley index. These are contained in the field cm.poincare.\nIn addition, the struct cm contains information on the actual connection matrix in the field cm.cm. While the field contains the matrix, the rows and columns of the connection matrix correspond to the cells listed in cm.labels. These cells form the basis for the homology groups of all the Morse sets. Moreover, a nonzero entry in the connection matrix indicates that there has to be a connecting orbit between the Morse set for the column label and the Morse set for the row label.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"For our example system, the Morse sets are given by","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cm.morsesets","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"There are five of them: The stable periodic orbit S_P mentioned earlier, the stable critical state F, the unstable equilibria DF and EF, as well as the two-dimensional unstable critical cell DEF.  The associated Conley indices are","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cm.poincare","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that these are exactly as described in the homology section, despite the fact that now we are computing over the finite field GF(2). An example where the index depends on the underlying field is provided by the function example_moebius.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, the connection matrix itself is contained in cm.cm. Since internally the connection matrix is stored in a sparse format, we display it after conversion to a full matrix:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"full_from_sparse(cm.cm)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to see which simplices correspond to the columns of the matrix, we use the command","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(cm.labels)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The right-most column contains two nonzero entries, and they imply that there are connecting orbits between the critical cell DEF and the two critical cells DF and EF, respectively. The second-to-last column establishes connecting orbits originating from EF. One of these ends at the critical vertex F, while the other one leads to A. Notice, however, that since A is part of the Morse set S_P, i.e., the periodic orbit, this second nonzero entry in the column implies the existence of a heteroclinic orbit between the equilibrium and the complete periodic solution. Similarly, there are connections between DF and both F and the periodic orbit, in view of the fourth column of the connection matrix.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A description of the remaining fields of the struct cm can be found in the API entry for the function connection_matrix. Internally, all computations necessary for determining the connection matrix are performed automatically over the rationals or over GF(p), dependending on the value of the arguent p. If this argument is omitted, then the function either uses the value of lc.boundary.char, provided it is a nonzero integer, or raises an error. This is due to the fact that the boundary of a Lefschetz complex can be specified either as a matrix over the integers or over GF(p), but the connection matrix computations have to be performed over a field. Thus, the case of an integer boundary matrix (which corresponds to lc.boundary.char=0) raises an error. For more details, see the discussion of connection_matrix.","category":"page"},{"location":"man/tutorial/#Multivector-Fields","page":"Tutorial","title":"Multivector Fields","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As second and last example of this first tutorial we turn our attention to the logo of ConleyDynamics.jl. It shows a simple multivector field on a simplicial complex, and both the simplicial complex sclogo and the multivector field mvflogo can be defined using the commands","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"using ..ConleyDynamics # hide\nlabels = [\"A\",\"B\",\"C\",\"D\"]\nsimplices = [[\"A\",\"B\",\"C\"],[\"B\",\"C\",\"D\"]]\nsclogo = create_simplicial_complex(labels,simplices)\nmvflogo = [[\"A\",\"AB\"],[\"C\",\"AC\"],[\"B\",\"BC\",\"BD\",\"BCD\"]]","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This example is taken from [MW23, Figure 1], and is visualized in the accompanying figure.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: The logo multivector field)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The multivector field mvflogo clearly has a different structure from the earlier Forman vector field. While the latter consists exclusively of arrows and critical cells, the former is made up of multivectors.  For the case of a simplicial complex, a multivector is a collection of simplices which form a locally closed set, i.e., if sigma_1 subset sigma_2 are two simplices in the multivector, then so are all simplices tau with sigma_1 subset tau subset sigma_2.  In other words, multivectors are convex with respect to simplex inclusion.  A multivector field is a partition of the simplicial complex into multivectors. See [LKMW23] for more details.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"It is not difficult to see that every Forman vector field is a multivector field. Every critical cell consists of just one simplex, so it trivially satisfies the above convexity condition. In addition, the two simplices contained in an arrow do not allow for any simplex sigma^- subset tau subset sigma^+ apart from tau = sigma^pm.  As in the case of Forman vector fields, multivector fields in ConleyDynamics only need to list multivectors containing at least two simplices. Any simplex not contained on the list automatically gives rise to a one-element multivector.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"One important difference between Forman vector fields and multivector fields is the definition of criticality. In the mutlivector field case, multivectors are distinguished as follows:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A multivector V is called critical, if the relative homology H_*(mathrmcl V mathrmmo V) is not trivial, i.e., at least one Betti number is nonzero.\nA multivector V is called regular, if the relative homology H_*(mathrmcl V mathrmmo V) is trivial, i.e., it vanishes in all dimensions.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"One can show that in the case of a Forman vector field, critical cells are always critical in the above sense, while arrows are always regular. In our above example mvflogo, all three multivectors which are not singletons are regular. For example, the following computation shows that the cell ABC is a critical cell:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cl1, mo1 = lefschetz_clomo_pair(sclogo, [\"ABC\"])\nrelative_homology(sclogo, cl1, mo1, p=2)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The first command creates the closure-mouth pair associated with the cell ABC, i.e., the variable cl1 is the closed triangle, while mo1 is the closed boundary of the triangle. The next  command determines the relative homology. Notice that this employs another method under the name relative_homology, in contrast to the one used earlier in this tutorial. For more details, see Homology Functions.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, the next sequence of commands verifies that the third nontrivial multivector mvflogo[3] is indeed a regular multivector:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cl2, mo2 = lefschetz_clomo_pair(sclogo, mvflogo[3])\nrelative_homology(sclogo, cl2, mo2, p=2)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The global dynamics can again be determined using the function connection_matrix:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cmlogo = connection_matrix(sclogo, mvflogo, p=2)\ncmlogo.morsesets","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As it turns out, our logo gives rise to three Morse sets, which in fact partition the simplicial complex. Their Conley indices are given by","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(cmlogo.poincare)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, the connection matrix has the form","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"full_from_sparse(cmlogo.cm)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice that in this example, only the connection between the Morse set ABC and the large index 1 Morse set comprising almost all  of the simplicial complex can be detected algebraically. In fact, there are two connections between the large Morse set and the stable equilibrium D, but they cancel algebraically.","category":"page"},{"location":"man/tutorial/#Tutorial-References","page":"Tutorial","title":"Tutorial References","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"B. Batko, T. Kaczynski, M. Mrozek and T. Wanner. Linking combinatorial and classical dynamics: Conley             index and Morse decompositions. Foundations of Computational Mathematics 20, 967–1012 (2020).\n\n\n\nC. Conley. Isolated Invariant Sets and the Morse Index (American Mathematical Society, Providence, R.I., 1978).\n\n\n\nR. Forman. Combinatorial vector fields and dynamical systems. Mathematische Zeitschrift 228, 629–681 (1998).\n\n\n\nR. Forman. Morse theory for cell complexes. Advances in Mathematics 134, 90–145 (1998).\n\n\n\nT. Kaczynski, M. Mrozek and T. Wanner. Towards a formal tie between combinatorial and classical             vector field dynamics. Journal of Computational Dynamics 3, 17–50 (2016).\n\n\n\nS. Lefschetz. Algebraic Topology. Vol. 27 of American Mathematical Society Colloquium Publications (American Mathematical Society, New York, 1942).\n\n\n\nM. Lipinski, J. Kubica, M. Mrozek and T. Wanner. Conley-Morse-Forman theory for generalized combinatorial             multivector fields on finite topological spaces. Journal of Applied and Computational Topology 7, 139–184 (2023).\n\n\n\nM. Mrozek and T. Wanner. Creating semiflows on simplicial complexes from combinatorial vector fields. Journal of Differential Equations 304, 375–434 (2021).\n\n\n\nM. Mrozek and T. Wanner. Connection matrices in combinatorial topological dynamics, arXiv:2103.04269 (2023).\n\n\n\n","category":"page"},{"location":"man/homology/#Homology","page":"Homology","title":"Homology","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Conley's theory for the qualitative study of dynamical systems is based on fundamental concepts from algebraic topology. One of these is homology, which studies the topological properties of spaces. As part of ConleyDynamics a number of homology methods are included. These are described in detail  below. More detailed information on the discussed topics can be found in Munkres [Mun84].","category":"page"},{"location":"man/homology/#Homology-of-Lefschetz-Complexes","page":"Homology","title":"Homology of Lefschetz Complexes","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"As we saw earlier, a Lefschetz complex is a collection of cells which associated nonnegative dimensions, together with a boundary map.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   ldots stackrelpartial_k+2longrightarrow\n   C_k+1(L) stackrelpartial_k+1longrightarrow\n   C_k(L) stackrelpartial_klongrightarrow\n   C_k-1(L) stackrelpartial_k-1longrightarrow ldots\n   stackrelpartial_1longrightarrow\n   C_0(L) longrightarrow 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The boundary map partial_k is a linear map from the chain group C_k(L) to the chain group C_k-1(L). Since ConleyDynamics uses only field coefficients, these chain groups are in fact vector spaces. As such, any linear map induces two important subspaces, which in the context of algebraic topology are called as follows:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The elements of the subspace Z_k(L) subset C_k(L) = mathrmker partial_k are called the k-cycles of L.\nThe elements of the subspace B_k(L) subset C_k(L) = mathrmim partial_k+1 are called the k-boundaries of L.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Recall that the fundamental property of the boundary map is the identity partial^2 = 0, i.e., its square vanishes. Using the dimension-induced gradation mentioned above, this can be reformulated as the equation partial_k circ partial_k+1 = 0. This immmediately implies the subspace inclusion B_k(L) subset Z_k(L), and we can therefore define the quotient space","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   H_k(L) =\n   mathrmkerpartial_k  mathrmimpartial_k+1","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This vector space is called the k-th homology group of the Lefschetz  complex L.","category":"page"},{"location":"man/homology/#Relative-Homology","page":"Homology","title":"Relative Homology","text":"","category":"section"},{"location":"man/homology/#Persistent-Homology-of-Filtrations","page":"Homology","title":"Persistent Homology of Filtrations","text":"","category":"section"},{"location":"man/homology/#Tutorial-References","page":"Homology","title":"Tutorial References","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"J. R. Munkres. Elements of Algebraic Topology (Addison-Wesley, Menlo Park, 1984).\n\n\n\n","category":"page"},{"location":"apicore/plots/#Plotting-Functions","page":"Plotting Functions","title":"Plotting Functions","text":"","category":"section"},{"location":"apicore/plots/#Visualizing-Simplicial-Complexes","page":"Plotting Functions","title":"Visualizing Simplicial Complexes","text":"","category":"section"},{"location":"apicore/plots/","page":"Plotting Functions","title":"Plotting Functions","text":"plot_planar_simplicial(::LefschetzComplex,::Vector{<:Vector{<:Real}},::String;::MultiVectorField,::Vector{<:Real},::Real,::Real,::Real,::Real,::Vector{Bool},::Bool)\nplot_planar_simplicial_morse(::LefschetzComplex,::Vector{<:Vector{<:Real}},::String,::MultiVectorField;::Real,::Real,::Real,::Vector{Bool},::Bool)","category":"page"},{"location":"apicore/plots/#ConleyDynamics.plot_planar_simplicial-Tuple{LefschetzComplex, Vector{<:Vector{<:Real}}, String}","page":"Plotting Functions","title":"ConleyDynamics.plot_planar_simplicial","text":"plot_planar_simplicial(sc::LefschetzComplex,\n                       coords::Vector{<:Vector{<:Real}},\n                       fname::String;\n                       [mvf::MultiVectorField=Vector{Vector{Int}}([]),]\n                       [labeldir::Vector{<:Real}=Vector{Int}([]),]\n                       [labeldis::Real=8,]\n                       [hfac::Real=1.2,]\n                       [vfac::Real=1.2,]\n                       [sfac::Real=0,]\n                       [pdim::Vector{Bool}=[true,true,true],]\n                       [pv::Bool=false])\n\nCreate an image of a planar simplicial complex, and if specified, a Forman vector field on it.\n\nThe vector coords contains coordinates for every one of the vertices of the simplicial complex sc. The image will be saved in the file with name fname, and the ending determines the image type. Accepted are .pdf, .svg, .png, and .eps.\n\nIf the optional mvf is specified and is a Forman vector field, then this Forman vector field is drawn as well. The optional vector labeldir contains directions for the vertex labels, and labeldis the distance from the vertex. The directions have to be reals between 0 and 4, with 0,1,2,3 corresponding to E,N,W,S. The optional constants hfac and vfac contain the horizontal and vertical scale vectors, while sfac describes a uniform scale. If sfac=0 the latter is automatically determined. The vector pdim specifies in which dimensions cells are drawn; the default shows vertices, edges, and triangles. Finally if one passes the argument pv=true, then in addition to saving the file a preview is displayed.\n\nExamples\n\nSuppose we have created a simplicial complex using the commands\n\nsc, coords = create_simplicial_delaunay(300, 300, 30, 20)\nfname = \"sc_plot_test.pdf\"\n\nThen the following code creates an image of the simplicial complex without labels, but with a preview:\n\nplot_planar_simplicial(sc, coords, fname, pv=true)\n\nIf we want to see the labels, we can use\n\nldir = fill(0.5, sc.ncells);\nplot_planar_simplicial(sc, coords, fname, labeldir=ldir, labeldis=10, pv=true)\n\nThis command puts all labels in the North-East direction at a distance of 10.\n\n\n\n\n\n","category":"method"},{"location":"apicore/plots/#ConleyDynamics.plot_planar_simplicial_morse-Tuple{LefschetzComplex, Vector{<:Vector{<:Real}}, String, Union{Vector{Vector{Int64}}, Vector{Vector{String}}}}","page":"Plotting Functions","title":"ConleyDynamics.plot_planar_simplicial_morse","text":"plot_planar_simplicial_morse(sc::LefschetzComplex,\n                             coords::Vector{<:Vector{<:Real}},\n                             fname::String,\n                             morsesets::MultiVectorField;\n                             [hfac::Real=1.2,]\n                             [vfac::Real=1.2,]\n                             [sfac::Real=0,]\n                             [pdim::Vector{Bool}=[false,true,true],]\n                             [pv::Bool=false])\n\nCreate an image of a planar simplicial complex, together with Morse sets, or also selected multivectors.\n\nThe vector coords contains coordinates for every one of the vertices of the simplicial complex sc. The image will be saved in the file with name fname, and the ending determines the image type. Accepted are .pdf, .svg, .png, and .eps.\n\nThe vector morsesets contains a list of Morse sets, or more general, subsets of the simplicial complex. For every k, the set described by morsesets[k] will be shown in a distinct color.\n\nThe optional constants hfac and vfac contain the horizontal and vertical scale vectors for the margins, while sfac describes a uniform scale. If sfac=0 the latter is automatically determined. The vector pdim specifies in which dimensions cells are drawn; the default only shows edges and triangles. Finally if one passes the argument pv=true, then in addition to saving the file a preview is displayed.\n\n\n\n\n\n","category":"method"},{"location":"apicore/plots/#Visualizing-Cubical-Complexes","page":"Plotting Functions","title":"Visualizing Cubical Complexes","text":"","category":"section"},{"location":"apicore/plots/","page":"Plotting Functions","title":"Plotting Functions","text":"plot_planar_cubical(::LefschetzComplex,::String;::Real,::Real,::Real,::Vector{Bool},::Bool)\nplot_planar_cubical_morse(::LefschetzComplex,::String,::MultiVectorField;::Real,::Real,::Real,::Vector{Bool},::Bool)","category":"page"},{"location":"apicore/plots/#ConleyDynamics.plot_planar_cubical-Tuple{LefschetzComplex, String}","page":"Plotting Functions","title":"ConleyDynamics.plot_planar_cubical","text":"plot_planar_cubical(cc::LefschetzComplex,\n                    fname::String;\n                    [hfac::Real=1.2,]\n                    [vfac::Real=1.2,]\n                    [cubefac::Real=0,]\n                    [pdim::Vector{Bool}=[true,true,true],]\n                    [pv::Bool=false])\n\nCreate an image of a planar cubical complex.\n\nThe image will be saved in the file with name fname, and the ending determines the image type. Accepted are .pdf, .svg, .png, and .eps. The optional constants hfac and vfac contain the horizontal and vertical scale vectors. The optional argument cubefac specifies the side length of an elementary cube for plotting, and it will be automatically determined otherwise. The vector pdim specifies which cell dimensions should be plotted, with pdim[k] representing dimension k-1. Finally if one passes the argument pv=true, then in addition to saving the file a preview is displayed.\n\nExamples\n\nSuppose we have created a cubical complex using the commands\n\ncubes = [\"00.11\", \"01.01\", \"02.10\", \"11.10\", \"11.01\", \"22.00\"]\ncc = create_cubical_complex(cubes)\nfname = \"cc_plot_test.pdf\"\n\nThen the following code creates an image of the simplicial complex without labels, but with a preview:\n\nplot_planar_cubical(cc, fname, pv=true)\n\nIf one only wants to plot the edges in the complex, but not the vertices or rectangles, then one can use:\n\nplot_planar_cubical(cc, fname, pv=true, pdim=[false,true,false])\n\n\n\n\n\n","category":"method"},{"location":"apicore/plots/#ConleyDynamics.plot_planar_cubical_morse-Tuple{LefschetzComplex, String, Union{Vector{Vector{Int64}}, Vector{Vector{String}}}}","page":"Plotting Functions","title":"ConleyDynamics.plot_planar_cubical_morse","text":"plot_planar_cubical_morse(cc::LefschetzComplex,\n                          fname::String,\n                          morsesets::MultiVectorField;\n                          [hfac::Real=1.2,]\n                          [vfac::Real=1.2,]\n                          [cubefac::Real=0,]\n                          [pdim::Vector{Bool}=[false,true,true],]\n                          [pv::Bool=false])\n\nCreate an image of a planar cubical complex, together with Morse sets, or also selected multivectors.\n\nThe image will be saved in the file with name fname, and the ending determines the image type. Accepted are .pdf, .svg, .png, and .eps.\n\nThe vector morsesets contains a list of Morse sets, or more general, subsets of the cubical complex. For every k, the set described by morsesets[k] will be shown in a distinct color.\n\nThe optional constants hfac and vfac contain the horizontal and vertical scale vectors for the margins, while cubefac describes a uniform scale. If cubefac=0 the latter is automatically determined. The vector pdim specifies in which dimensions cells are drawn; the default only shows edges and squares. Finally if one passes the argument pv=true, then in addition to saving the file a preview is displayed.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#Utility-Functions","page":"Utility Functions","title":"Utility Functions","text":"","category":"section"},{"location":"apicore/utils/","page":"Utility Functions","title":"Utility Functions","text":"DocTestSetup = quote\n    push!(LOAD_PATH,\"../../../src/\")\n    using ConleyDynamics\nend","category":"page"},{"location":"apicore/utils/#Simplicial-Complexes","page":"Utility Functions","title":"Simplicial Complexes","text":"","category":"section"},{"location":"apicore/utils/","page":"Utility Functions","title":"Utility Functions","text":"create_simplicial_complex(::Vector{String},::Vector{Vector{Int}})\ncreate_simplicial_complex(::Vector{String},::Vector{Vector{String}})\ncreate_simplicial_rectangle(::Int,::Int)\ncreate_simplicial_delaunay(::Real,::Real,::Real,::Int)\ncreate_simplicial_delaunay(::Real,::Real,::Int)\nconvert_simplices(::Vector{Vector{Int}},::Vector{String})\nconvert_simplices(::Vector{Vector{String}},::Vector{String})","category":"page"},{"location":"apicore/utils/#ConleyDynamics.create_simplicial_complex-Tuple{Vector{String}, Vector{Vector{Int64}}}","page":"Utility Functions","title":"ConleyDynamics.create_simplicial_complex","text":"create_simplicial_complex(labels::Vector{String},\n                          simplices::Vector{Vector{Int}})\n\nInitialize a Lefschetz complex from a simplicial complex.\n\nThe vector labels contains a label for every vertex, while simplices contains all the highest-dimensional simplices necessary to define the simplicial complex. Every simplex is represented as a vector of Int, with entries corresponding to the vertex indices.\n\nwarning: Warning\nNote that the labels all have to have the same character length!\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.create_simplicial_complex-Tuple{Vector{String}, Vector{Vector{String}}}","page":"Utility Functions","title":"ConleyDynamics.create_simplicial_complex","text":"create_simplicial_complex(labels::Vector{String},\n                          simplices::Vector{Vector{String}})\n\nInitialize a Lefschetz complex from a simplicial complex.\n\nThe vector labels contains a label for every vertex, while simplices contains all the highest-dimensional simplices necessary to define the simplicial complex.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.create_simplicial_rectangle-Tuple{Int64, Int64}","page":"Utility Functions","title":"ConleyDynamics.create_simplicial_rectangle","text":"create_simplicial_rectangle(nx::Int, ny::Int)\n\nCreate a simplicial complex covering a rectangle in the plane.\n\nThe rectangle is given by the subset [0,nx] x [0,ny] of the plane. Each unit square is represented by four triangles, which meet in the center point of the square. Labels have the following meaning:\n\nThe label XXXYYYb corresponds to the point (XXX, YYY).\nThe label XXXYYYc corresponds to (XXX + 1/2, YYY + 1/2).\n\nThe number of characters in XXX and YYY matches the number  of digits of the larger number of nx and ny. The function returns the following objects:\n\nA simplicial complex sc::LefschetzComplex.\nA vector coords::Vector{Vector{Float64}} of vertex coordinates.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.create_simplicial_delaunay-Tuple{Real, Real, Real, Int64}","page":"Utility Functions","title":"ConleyDynamics.create_simplicial_delaunay","text":"create_simplicial_delaunay(boxw::Real, boxh::Real, pdist::Real, attmpt::Int)\n\nCreate a planar Delaunay triangulation inside a box.\n\nThe function selects a random sample of points inside the rectangular box [0,boxw] x [0,boxh], while trying to maintain a minimum distance  of pdist between the points. The argument attmpt specifies the number of attempts when trying to add points. A standard value is 20, and larger values tend to fill holes better, but at the expense of runtime. From the random sample, the function then creates a Delaunay triangulation, and returns the following objects:\n\nA simplicial complex sc::LefschetzComplex.\nA vector coords::Vector{Vector{Float64}} of vertex coordinates.\n\nNote that the function does not provide a full triangulation of the given rectangle. Close to the boundary there will be gaps.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.create_simplicial_delaunay-Tuple{Real, Real, Int64}","page":"Utility Functions","title":"ConleyDynamics.create_simplicial_delaunay","text":"create_simplicial_delaunay(boxw::Real, boxh::Real, npoints::Int)\n\nCreate a planar Delaunay triangulation inside a box.\n\nThe function selects a random sample of npoints points inside the rectangular box [0,boxw] x [0,boxh]. From the random sample, the function then creates a Delaunay triangulation, and returns the following objects:\n\nA simplicial complex sc::LefschetzComplex.\nA vector coords::Vector{Vector{Float64}} of vertex coordinates.\n\nNote that the function does not provide a full triangulation of the given rectangle. Close to the boundary there will be gaps.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.convert_simplices-Tuple{Vector{Vector{Int64}}, Vector{String}}","page":"Utility Functions","title":"ConleyDynamics.convert_simplices","text":"convert_simplices(simplices::Vector{Vector{Int}},\n                  labels::Vector{String})\n\nConvert list of simplices from index form to label form.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.convert_simplices-Tuple{Vector{Vector{String}}, Vector{String}}","page":"Utility Functions","title":"ConleyDynamics.convert_simplices","text":"convert_simplices(simplices::Vector{Vector{String}},\n                  labels::Vector{String})\n\nConvert list of simplices from label form to index form.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#Cubical-Complexes","page":"Utility Functions","title":"Cubical Complexes","text":"","category":"section"},{"location":"apicore/utils/","page":"Utility Functions","title":"Utility Functions","text":"create_cubical_complex(::Vector{String})\ncreate_cubical_rectangle(::Int,::Int)\ncube_field_size(::String)\ncube_information(::String)\ncube_label(::Int,::Int,::Vector{Int})","category":"page"},{"location":"apicore/utils/#ConleyDynamics.create_cubical_complex-Tuple{Vector{String}}","page":"Utility Functions","title":"ConleyDynamics.create_cubical_complex","text":"create_cubical_complex(cubes::Vector{String})\n\nInitialize a Lefschetz complex from a cubical complex.\n\nThe vector cubes contains a list of all the highest-dimensional cubes necessary to define the cubical complex. Every cube is represented as a string as follows:\n\nd integers, which correspond to the coordinates of a point in d-dimensional Euclidean space\na point .\nd integers 0 or 1, which give the interval length in the respective dimension\n\nThe first d integers all have to occupy the same number of characters. In addition, if the occupied space is L characters for each coordinate, the coordinates only can take values from 0 to 10^L - 2. This is due to the fact that the boundary operator will add one to certain coordinates, and they still need to be  representable withing the same L digits.\n\nFor example, the string 030600.101 corresponds to the point (3,6,0) in three dimensions. The dimensions are 1, 0, and 1, and therefore this string corresponds to the cube [3,4] x [6] x [0,1]. The same cube could have also been represented by 360.101 or by 003006000.101.\n\nwarning: Warning\nNote that the labels all have to have the same format!\n\nExample\n\njulia> cubes = [\"00.11\", \"01.01\", \"02.10\", \"11.10\", \"11.01\", \"22.00\"];\n\njulia> lc = create_cubical_complex(cubes);\n\njulia> lc.ncells\n17\n\njulia> homology(lc, p=0)\n3-element Vector{Int64}:\n 2\n 1\n 0\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.create_cubical_rectangle-Tuple{Int64, Int64}","page":"Utility Functions","title":"ConleyDynamics.create_cubical_rectangle","text":"create_cubical_rectangle(nx::Int, ny::Int)\n\nCreate a cubical complex covering a rectangle in the plane.\n\nThe rectangle is given by the subset [0,nx] x [0,ny] of the plane, and each unit square gives a two-dimensional cube in the resulting cubical complex. The function returns the following objects:\n\nA cubical complex cc::LefschetzComplex.\nA vector coords::Vector{Vector{Float64}} of vertex coordinates.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.cube_field_size-Tuple{String}","page":"Utility Functions","title":"ConleyDynamics.cube_field_size","text":"cube_field_size(cube::String)\n\nDetermine the field sizes of a given cube label.\n\nThe function returns the dimension of the ambient space in the first output parameter pointdim, and the length of the individual coordinate fields in the second return variable pointlen.\n\nExample\n\njulia> cube_field_size(\"011654003020.0110\")\n(4, 3)\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.cube_information-Tuple{String}","page":"Utility Functions","title":"ConleyDynamics.cube_information","text":"cube_information(cube::String)\n\nCompute a cube's coordinate information.\n\nThe function returns an integer vector with the cubes coordinate information. The return vector intinfo contains in its components the following data:\n\n1:pointdim: Coordinates of the anchor point\n1+pointdim:2*pointdim: Interval length in each dimension\n1+2*pointdim: Dimension of the cube\n\nNote that pointdim equals the dimension of the points specifying the cube.\n\nExample\n\njulia> cube_information(\"011654003.011\")\n7-element Vector{Int64}:\n  11\n 654\n   3\n   0\n   1\n   1\n   2\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.cube_label-Tuple{Int64, Int64, Vector{Int64}}","page":"Utility Functions","title":"ConleyDynamics.cube_label","text":"cube_label(pointdim::Int, pointlen::Int, pointinfo::Vector{Int})\n\nCreate a label from a cube's coordinate information.\n\nThe dimension of the ambient Eucliden space is pointdim, while the field length for each coordinate is pointlen. The vector pointinfo has to be of length at least two times pointdim. The first pointdim entries contain the coordinates of the anchor point, while the next pointdim entries are either 0 or 1 depending on the size of the interval. For example, if poindim = 3 and pointinfo = [1,2,3,1,0,1], then we represent the cube in three-dimensional space given by [1,2] x [2] x [3 4].\n\nExample\n\njulia> cube_label(3,2,[10,23,5,1,1,0])\n\"102305.110\"\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#General-Lefschetz-complexes","page":"Utility Functions","title":"General Lefschetz complexes","text":"","category":"section"},{"location":"apicore/utils/","page":"Utility Functions","title":"Utility Functions","text":"lefschetz_boundary(::LefschetzComplex,::Int)\nlefschetz_boundary(::LefschetzComplex,::String)\nlefschetz_coboundary(::LefschetzComplex,::Int)\nlefschetz_coboundary(::LefschetzComplex,::String)\nlefschetz_openhull(::LefschetzComplex,::Vector{Int})\nlefschetz_openhull(::LefschetzComplex,::Vector{String})\nlefschetz_closure(::LefschetzComplex,::Vector{Int})\nlefschetz_closure(::LefschetzComplex,::Vector{String})\nlefschetz_lchull(::LefschetzComplex,::Vector{Int})\nlefschetz_lchull(::LefschetzComplex,::Vector{String})\nlefschetz_is_closed(::LefschetzComplex,::Vector{Int})\nlefschetz_is_closed(::LefschetzComplex,::Vector{String})\nlefschetz_clomo_pair(::LefschetzComplex,::Vector{Int})\nlefschetz_clomo_pair(::LefschetzComplex,::Vector{String})\nlefschetz_skeleton(::LefschetzComplex,::Vector{Int},::Int)\nlefschetz_skeleton(::LefschetzComplex,::Vector{String},::Int)\nlefschetz_skeleton(::LefschetzComplex,::Int)\nlefschetz_subcomplex(::LefschetzComplex,::Vector{Int})\nlefschetz_subcomplex(::LefschetzComplex,::Vector{String})\nlefschetz_filtration(::LefschetzComplex,::Vector{Int})\nlefschetz_filtration(::LefschetzComplex,::Vector{Vector{String}})\npermute_lefschetz_complex(::LefschetzComplex,::Vector{Int})","category":"page"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_boundary-Tuple{LefschetzComplex, Int64}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_boundary","text":"lefschetz_boundary(lc::LefschetzComplex, cellI::Int)\n\nCompute the support of the boundary of a Lefschetz complex cell.\n\nThis method returns the boundary support as a Vector{Int}.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_boundary-Tuple{LefschetzComplex, String}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_boundary","text":"lefschetz_boundary(lc::LefschetzComplex, cellS::String)\n\nCompute the support of the boundary of a Lefschetz complex cell.\n\nThis method returns the boundary support as a Vector{String}.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_coboundary-Tuple{LefschetzComplex, Int64}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_coboundary","text":"lefschetz_coboundary(lc::LefschetzComplex, cellI::Int)\n\nCompute the support of the coboundary of a Lefschetz complex cell.\n\nThis method returns the boundary support as a Vector{Int}.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_coboundary-Tuple{LefschetzComplex, String}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_coboundary","text":"lefschetz_coboundary(lc::LefschetzComplex, cellS::String)\n\nCompute the support of the coboundary of a Lefschetz complex cell.\n\nThis method returns the boundary support as a Vector{String}.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_openhull-Tuple{LefschetzComplex, Vector{Int64}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_openhull","text":"lefschetz_openhull(lc::LefschetzComplex, subcomp::Vector{Int})\n\nCompute the open hull of a Lefschetz complex subset.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_openhull-Tuple{LefschetzComplex, Vector{String}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_openhull","text":"lefschetz_openhull(lc::LefschetzComplex, subcomp::Vector{String})\n\nCompute the open hull of a Lefschetz complex subset.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_closure-Tuple{LefschetzComplex, Vector{Int64}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_closure","text":"lefschetz_closure(lc::LefschetzComplex, subcomp::Vector{Int})\n\nCompute the closure of a Lefschetz complex subset.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_closure-Tuple{LefschetzComplex, Vector{String}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_closure","text":"lefschetz_closure(lc::LefschetzComplex, subcomp::Vector{String})\n\nCompute the closure of a Lefschetz complex subset.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_lchull-Tuple{LefschetzComplex, Vector{Int64}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_lchull","text":"lefschetz_lchull(lc::LefschetzComplex, subcomp::Vector{Int})\n\nCompute the locally closed hull of a Lefschetz complex subset.\n\nThe locally closed hull is the smallest locally closed set which contains the given cells. It is the intersection of the closure and the open hull.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_lchull-Tuple{LefschetzComplex, Vector{String}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_lchull","text":"lefschetz_lchull(lc::LefschetzComplex, subcomp::Vector{String})\n\nCompute the locally closed hull of a Lefschetz complex subset.\n\nThe locally closed hull is the smallest locally closed set which contains the given cells. It is the intersection of the closure and the open hull.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_is_closed-Tuple{LefschetzComplex, Vector{Int64}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_is_closed","text":"lefschetz_is_closed(lc::LefschetzComplex, subcomp::Vector{Int})\n\nDetermine whether a Lefschetz complex subset is closed.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_is_closed-Tuple{LefschetzComplex, Vector{String}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_is_closed","text":"lefschetz_is_closed(lc::LefschetzComplex, subcomp::Vector{String})\n\nDetermine whether a Lefschetz complex subset is closed.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_clomo_pair-Tuple{LefschetzComplex, Vector{Int64}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_clomo_pair","text":"lefschetz_clomopair(lc::LefschetzComplex, subcomp::Vector{Int})\n\nDetermine the closure-mouth-pair associated with a Lefschetz complex subset.\n\nThe function returns the pair (closure,mouth).\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_clomo_pair-Tuple{LefschetzComplex, Vector{String}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_clomo_pair","text":"lefschetz_clomopair(lc::LefschetzComplex, subcomp::Vector{String})\n\nDetermine the closure-mouth-pair associated with a Lefschetz complex subset.\n\nThe function returns the pair (closure,mouth).\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_skeleton-Tuple{LefschetzComplex, Vector{Int64}, Int64}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_skeleton","text":"lefschetz_skeleton(lc::LefschetzComplex, subcomp::Vector{Int}, skdim::Int)\n\nCompute the skdim-dimensional skeleton of a Lefschetz complex subset.\n\nThe computed skeleton is for the closure of the subcomplex given by subcomp.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_skeleton-Tuple{LefschetzComplex, Vector{String}, Int64}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_skeleton","text":"lefschetz_skeleton(lc::LefschetzComplex, subcomp::Vector{String}, skdim::Int)\n\nCompute the skdim-dimensional skeleton of a Lefschetz complex subset.\n\nThe computed skeleton is for the closure of the subcomplex given by subcomp.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_skeleton-Tuple{LefschetzComplex, Int64}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_skeleton","text":"lefschetz_skeleton(lc::LefschetzComplex, skdim::Int)\n\nCompute the skdim-dimensional skeleton of a Lefschetz complex.\n\nThe computed skeleton is for the full Lefschetz complex.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_subcomplex-Tuple{LefschetzComplex, Vector{Int64}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_subcomplex","text":"lefschetz_subcomplex(lc::LefschetzComplex, subcomp::Vector{Int})\n\nExtract a closed subcomplex from a Lefschetz complex. The subcomplex is the closure of the collection of cells given in subcomp.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_subcomplex-Tuple{LefschetzComplex, Vector{String}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_subcomplex","text":"lefschetz_subcomplex(lc::LefschetzComplex, subcomp::Vector{String})\n\nExtract a closed subcomplex from a Lefschetz complex. The subcomplex is the closure of the collection of cells given in subcomp.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_filtration-Tuple{LefschetzComplex, Vector{Int64}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_filtration","text":"lefschetz_filtration(lc::LefschetzComplex, fvalues::Vector{Int})\n\nCompute a filtration on a Lefschetz subset.\n\nThe considered Lefschetz complex is given in lc. The vector fvalues assigns an integer between 0 and N to every cell in lc. For every k the complex L_k is given by the closure of all cells with values between 1 and k. The function returns the following variables:\n\nlcsub: The subcomplex L_N\nfvalsub: The filtration on the subcomplex with values 1,...,N\n\nExample\n\njulia> labels = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"];\n\njulia> simplices = [[\"A\",\"B\",\"D\"],[\"B\",\"D\",\"E\"],[\"B\",\"C\",\"E\"],[\"C\",\"E\",\"F\"],[\"F\",\"G\"]];\n\njulia> sc = create_simplicial_complex(labels,simplices);\n\njulia> filtration = [0,0,0,0,0,0,0,1,1,0,1,2,0,4,2,4,0,5,3,7,6];\n\njulia> lcsub, fvalsub = lefschetz_filtration(sc,filtration);\n\njulia> phinf, phint = persistent_homology(lcsub, fvalsub, p=2);\n\njulia> phinf\n3-element Vector{Vector{Int64}}:\n [1]\n []\n []\n\njulia> phint\n3-element Vector{Vector{Tuple{Int64, Int64}}}:\n []\n [(1, 5), (2, 7), (4, 6)]\n []\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_filtration-Tuple{LefschetzComplex, Vector{Vector{String}}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_filtration","text":"lefschetz_filtration(lc::LefschetzComplex, strfilt::Vector{Vector{String}})\n\nCompute a filtration on a Lefschetz subset.\n\nThe considered Lefschetz complex is given in lc. The vector of string vectors strfilt contains the necessary simplices to build the filtration. The list strfilt[k] contains the simplices that are added at the k-th step, together with their closures. Thus, for every k the complex L_k is given by the closure of all cells listed in strfilt[i] for i between 1 and k. The function returns the following variables:\n\nlcsub: The subcomplex L_N, where N = length(strfilt)\nfvalsub: The filtration on the subcomplex with values 1,...,N\n\nExample\n\njulia> labels = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"];\n\njulia> simplices = [[\"A\",\"B\",\"D\"],[\"B\",\"D\",\"E\"],[\"B\",\"C\",\"E\"],[\"C\",\"E\",\"F\"],[\"F\",\"G\"]];\n\njulia> sc = create_simplicial_complex(labels,simplices);\n\njulia> strfiltration = [[\"AB\",\"AD\",\"BD\"],[\"BE\",\"DE\"],[\"BCE\"],[\"CF\",\"EF\"],[\"ABD\"],[\"CEF\"],[\"BDE\"]];\n\njulia> lcsub, fvalsub = lefschetz_filtration(sc, strfiltration);\n\njulia> phinf, phint = persistent_homology(lcsub, fvalsub, p=2);\n\njulia> phinf\n3-element Vector{Vector{Int64}}:\n [1]\n []\n []\n\njulia> phint\n3-element Vector{Vector{Tuple{Int64, Int64}}}:\n []\n [(1, 5), (2, 7), (4, 6)]\n []\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.permute_lefschetz_complex-Tuple{LefschetzComplex, Vector{Int64}}","page":"Utility Functions","title":"ConleyDynamics.permute_lefschetz_complex","text":"permute_lefschetz_complex(lc::LefschetzComplex,\n                          permutation::Vector{Int})\n\nPermute the indices of a Lefschetz complex.\n\nThe vector permutation contains a permutation of the indices for the given Lefschetz complex lc. If no permutation is specified, or if the length of the vector is not correct, then a randomly generated one will be used.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#Multivector-Fields","page":"Utility Functions","title":"Multivector Fields","text":"","category":"section"},{"location":"apicore/utils/","page":"Utility Functions","title":"Utility Functions","text":"convert_mvf(::Vector{Vector{Int}},::LefschetzComplex)\nconvert_mvf(::Vector{Vector{String}},::LefschetzComplex)\ncreate_mvf_hull(::Vector{Vector{Int}},::LefschetzComplex)\ncreate_mvf_hull(::Vector{Vector{String}},::LefschetzComplex)\ncreate_planar_mvf(::LefschetzComplex,::Vector{Vector{Float64}},vf)","category":"page"},{"location":"apicore/utils/#ConleyDynamics.convert_mvf-Tuple{Vector{Vector{Int64}}, LefschetzComplex}","page":"Utility Functions","title":"ConleyDynamics.convert_mvf","text":"convert_mvf(mvf::Vector{Vector{Int}}, lc::LefschetzComplex)\n\nConvert multivector field mvf on the Lefschetz complex lc from  index form to label form.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.convert_mvf-Tuple{Vector{Vector{String}}, LefschetzComplex}","page":"Utility Functions","title":"ConleyDynamics.convert_mvf","text":"convert_mvf(mvf::Vector{Vector{String}}, lc::LefschetzComplex)\n\nConvert multivector field mvf on the Lefschetz complex lc from  label form to index form.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.create_mvf_hull-Tuple{Vector{Vector{Int64}}, LefschetzComplex}","page":"Utility Functions","title":"ConleyDynamics.create_mvf_hull","text":"create_mvf_hull(mvfbase::Vector{Vector{Int}}, lc::LefschetzComplex)\n\nCreate the smallest multivector field containing the given sets.\n\nThe resulting multivector field has the property that every set of the form mvfbase[k] is contained in a minimal multivector. Notice that these sets do not have to be disjoint, and that not even their locally closed hulls have to be disjoint. In the latter case, this leads to two such sets having to be contained in the same multivector. If the sets in mvfbase are poorly chosen, one might end up with extremely large multivectors due to the above potential merging of locally closed hulls.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.create_mvf_hull-Tuple{Vector{Vector{String}}, LefschetzComplex}","page":"Utility Functions","title":"ConleyDynamics.create_mvf_hull","text":"create_mvf_hull(mvfbase::Vector{Vector{String}}, lc::LefschetzComplex)\n\nCreate the smallest multivector field containing the given sets.\n\nThe resulting multivector field has the property that every set of the form mvfbase[k] is contained in a minimal multivector. Notice that these sets do not have to be disjoint, and that not even their locally closed hulls have to be disjoint. In the latter case, this leads to two such sets having to be contained in the same multivector. If the sets in mvfbase are poorly chosen, one might end up with extremely large multivectors due to the above potential merging of locally closed hulls.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.create_planar_mvf-Tuple{LefschetzComplex, Vector{Vector{Float64}}, Any}","page":"Utility Functions","title":"ConleyDynamics.create_planar_mvf","text":"create_planar_mvf(lc::LefschetzComplex, coords::Vector{Vector{Float64}}, vf)\n\nCreate a planar multivector field from a regular vector field.\n\nThe function expects a planar Lefschetz complex lc and a coordinate vector coords of coordinates for all the 0-dimensional cells in the complex. Moreover, the underlying vector field is specified by the function vf(z::Vector{Float64})::Vector{Float64}, where both the input and output vectors have length two. The function create_planar_mvf returns a multivector field mvf on lc, which can then be further analyzed using for example the function connection_matrix.\n\nThe input data lc and coords can be generated using one of the following methods:\n\ncreate_cubical_rectangle\ncreate_simplicial_rectangle\ncreate_simplicial_delaunay\n\nIn each case, the provided coordinate vector can be transformed to the correct bounding box using convert_planar_coordinates.\n\nExample 1\n\nSuppose we define a sample vector field using the commands\n\nfunction samplevf(x::Vector{Float64})\n    #\n    # Sample vector field with nontrivial Morse decomposition\n    #\n    x1, x2 = x\n    y1 = x1 * (1.0 - x1*x1 - 3.0*x2*x2)\n    y2 = x2 * (1.0 - 3.0*x1*x1 - x2*x2)\n    return [y1, y2]\nend\n\nOne first creates a triangulation of the enclosing box, which in this case is given by [-2,2] x [-2,2] using the commands\n\nn = 21\nlc, coords = create_simplicial_rectangle(n,n);\ncoordsN = convert_planar_coordinates(coords,[-2.0,-2.0],[2.0,2.0]);\n\nThe multivector field is then generated using\n\nmvf = create_planar_mvf(lc,coordsN,samplevf);\n\nand the commands\n\ncm = connection_matrix(lc, mvf, p=2);\ncm.poincare\nfull_from_sparse(cm.cm)\n\nfinally show that this vector field gives rise to a Morse decomposition with nine Morse sets, and twelve connecting orbits. Using the commands\n\nfname = \"morse_test.pdf\"\nplot_planar_simplicial_morse(lc, coordsN, fname, cm.morsesets)\n\nthese Morse sets can be visualized. The image will be saved in fname.\n\nExample 2\n\nAn example with periodic orbits can be generated using the vector field\n\nfunction samplevf2(x::Vector{Float64})\n    #\n    # Sample vector field with nontrivial Morse decomposition\n    #\n    x1, x2 = x\n    c0 = x1*x1 + x2*x2\n    c1 = (c0 - 4.0) * (c0 - 1.0)\n    y1 = -x2 + x1 * c1\n    y2 =  x1 + x2 * c1\n    return [-y1, -y2]\nend\n\nThe Morse decomposition can now be computed via\n\nn2 = 51\nlc2, coords2 = create_cubical_rectangle(n2,n2);\ncoords2N = convert_planar_coordinates(coords2,[-4.0,-4.0],[4.0,4.0]);\nmvf2 = create_planar_mvf(lc2,coords2N,samplevf2);\ncm2 = connection_matrix(lc2, mvf2, p=2);\ncm2.poincare\ncm2.poset\nfull_from_sparse(cm2.cm)\n\nfname2 = \"morse_test2.pdf\"\nplot_planar_cubical_morse(lc2, fname2, cm2.morsesets)\n\nIn this case, one obtains three Morse sets: One is a stable equilibrium, one is an unstable periodic orbit, and the last is a stable periodic orbit.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#General-Helper-Functions","page":"Utility Functions","title":"General Helper Functions","text":"","category":"section"},{"location":"apicore/utils/","page":"Utility Functions","title":"Utility Functions","text":"convert_planar_coordinates(::Vector{Vector{Float64}},::Vector{Float64},::Vector{Float64})\nconvert_matrix_gfp(::SparseMatrix{Int},::Int)","category":"page"},{"location":"apicore/utils/#ConleyDynamics.convert_planar_coordinates-Tuple{Vector{Vector{Float64}}, Vector{Float64}, Vector{Float64}}","page":"Utility Functions","title":"ConleyDynamics.convert_planar_coordinates","text":"convert_planar_coordinates(coords::Vector{Vector{Float64}},\n                           p0::Vector{Float64},\n                           p1::Vector{Float64})\n\nConvert a given collection of planar coordinates.\n\nThe vector coords contains pairs of coordinates, which are then transformed to fit into the box with vertices p0 = (p0x,p0y) and p1 = (p1x,p1y). It is assumed that p0 denotes the lower left box corner, while p1 is the upper right corner. The function shifts and scales the coordinates in such a way that every side of the box contains at least one point. Upon completion, it returns a new coordinate vector coordsNew.\n\nMore precisely, if the x-coordinates are spanning the interval [xmin,xmax] and the y-coordinates span [ymin,ymax], then the point (x,y) is transformed to (xn,yn) with:\n\nxn = p0x + (p1x-p0x) * (x-cxmin) / (cxmax-cxmin)\nyn = p0y + (p1y-p0y) * (y-cymin) / (cymax-cymin)\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.convert_matrix_gfp-Tuple{SparseMatrix{Int64}, Int64}","page":"Utility Functions","title":"ConleyDynamics.convert_matrix_gfp","text":"convert_matrix_gfp(matrix::SparseMatrix{Int}, p::Int)\n\nConvert a sparse integer matrix to a finite field sparse matrix over GF(p). For the choice p=0 the rationals are used.\n\n\n\n\n\n","category":"method"},{"location":"man/sparse/#Sparse-Matrices","page":"Sparse Matrices","title":"Sparse Matrices","text":"","category":"section"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"While Julia provides a data structure for sparse matrix computations, the employed design decisions make it difficult to use this implementation for computations over finite fields. This is mainly due to the fact that in the Julia implementation, it is assumed that one can determine the zero and one elements from the data type alone. However, a finite field data type and especially the ones implemented in the package Nemo, generally also depends on additional parameters, such as the characteristic of the field.","category":"page"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"Since the algorithms underlying ConleyDynamics only require basic row and column operations, we decided to include a specialized sparse matrix implementation.","category":"page"},{"location":"man/sparse/#Sparse-Matrix-Format","page":"Sparse Matrices","title":"Sparse Matrix Format","text":"","category":"section"},{"location":"apicore/sparse/#Sparse-Matrix-Functions","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"","category":"section"},{"location":"apicore/sparse/#Internal-Sparse-Matrix-Representation","page":"Sparse Matrix Functions","title":"Internal Sparse Matrix Representation","text":"","category":"section"},{"location":"apicore/sparse/","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"SparseMatrix","category":"page"},{"location":"apicore/sparse/#ConleyDynamics.SparseMatrix","page":"Sparse Matrix Functions","title":"ConleyDynamics.SparseMatrix","text":"SparseMatrix{T}\n\nComposite data type for a sparse matrix with entries of type T.\n\nThe struct has the following fields:\n\nconst nrow::Int: Number of rows\nconst ncol::Int: Number of columns\nconst char::Int: Characteristic of type T\nconst zero::T: Number 0 of type T\nconst one::T:  Number 1 of type T\nentries::Vector{Vector{T}}: Matrix entries corresponding to columns\ncolumns::Vector{Vector{Int}}: column[k] points to nonzero entries in column k\nrows::Vector{Vector{Int}}: rows[k] points to nonzero entries in the k-th row\n\n\n\n\n\n","category":"type"},{"location":"apicore/sparse/#Access-Functions","page":"Sparse Matrix Functions","title":"Access Functions","text":"","category":"section"},{"location":"apicore/sparse/","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"sparse_get_entry(matrix::SparseMatrix, ri::Int, ci::Int)\nBase.getindex(matrix::SparseMatrix, ri::Int, ci::Int)\nsparse_set_entry!(matrix::SparseMatrix, ri::Int, ci::Int, val)\nBase.setindex!(matrix::SparseMatrix, val, ri::Int, ci::Int)\nsparse_get_column(matrix::SparseMatrix, ci::Int)\nsparse_get_nz_column(matrix::SparseMatrix, ci::Int)\nsparse_minor(sm::SparseMatrix, rvec::Vector{Int}, cvec::Vector{Int})","category":"page"},{"location":"apicore/sparse/#ConleyDynamics.sparse_get_entry-Tuple{SparseMatrix, Int64, Int64}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_get_entry","text":"sparse_get_entry(matrix::SparseMatrix, ri::Int, ci::Int)\n\nGet the sparse matrix entry at location (ri,ci).\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#Base.getindex-Tuple{SparseMatrix, Int64, Int64}","page":"Sparse Matrix Functions","title":"Base.getindex","text":"Base.getindex(matrix::SparseMatrix, ri::Int, ci::Int)\n\nGet the sparse matrix entry at location (ri,ci).\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_set_entry!-Tuple{SparseMatrix, Int64, Int64, Any}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_set_entry!","text":"sparse_set_entry!(matrix::SparseMatrix, ri::Int, ci::Int, val)\n\nSet the sparse matrix entry at location (ri,ci) to val.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#Base.setindex!-Tuple{SparseMatrix, Any, Int64, Int64}","page":"Sparse Matrix Functions","title":"Base.setindex!","text":"Base.setindex!(matrix::SparseMatrix, val, ri::Int, ci::Int)\n\nSet the sparse matrix entry at location (ri,ci) to val.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_get_column-Tuple{SparseMatrix, Int64}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_get_column","text":"sparse_get_column(matrix::SparseMatrix, ci::Int)\n\nGet the ci-th column of the sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_get_nz_column-Tuple{SparseMatrix, Int64}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_get_nz_column","text":"sparse_get_nz_column(matrix::SparseMatrix, ci::Int)\n\nGet the row indices for the nonzero entries in the ci-th column of the sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_minor-Tuple{SparseMatrix, Vector{Int64}, Vector{Int64}}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_minor","text":"smp = sparse_minor(sm::SparseMatrix, rvec::Vector{Int}, cvec::Vector{Int})\n\nCreate sparse submatrix by specifying the desired row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#Basic-Functions","page":"Sparse Matrix Functions","title":"Basic Functions","text":"","category":"section"},{"location":"apicore/sparse/","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"sparse_size(matrix::SparseMatrix, dim::Int)\nsparse_low(matrix::SparseMatrix, col::Int)\nsparse_is_sut(sm::SparseMatrix)\nsparse_identity(n::Int, tone)\nsparse_fullness(sm::SparseMatrix)\nsparse_sparsity(sm::SparseMatrix)\nsparse_show(sm::SparseMatrix)\nsparse_show(sm::SparseMatrix{Int})","category":"page"},{"location":"apicore/sparse/#ConleyDynamics.sparse_size-Tuple{SparseMatrix, Int64}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_size","text":"sparse_size(matrix::SparseMatrix, dim::Int)\n\nNumber of rows (dim=1) or columns (dim=2) of a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_low-Tuple{SparseMatrix, Int64}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_low","text":"sparse_low(matrix::SparseMatrix, col::Int)\n\nRow index of the lowest nonzero matrix entry in column col.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_is_sut-Tuple{SparseMatrix}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_is_sut","text":"bool = sparse_is_sut(sm::SparseMatrix)\n\nCheck whether the sparse matrix is strictly upper triangular.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_identity-Tuple{Int64, Any}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_identity","text":"sparse_identity(n::Int, tone; p::Int=0)\n\nCreate a sparse identity matrix with n rows and columns, and with diagonal entry tone. The optional argument p specifies the field characteristic if typeof(tone)==Int.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_fullness-Tuple{SparseMatrix}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_fullness","text":"sparse_fullness(sm::SparseMatrix)\n\nDisplay the fullness of the sparse matrix sm.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_sparsity-Tuple{SparseMatrix}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_sparsity","text":"sparse_sparsity(sm::SparseMatrix)\n\nDisplay the sparsity of the sparse matrix sm.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_show-Tuple{SparseMatrix}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_show","text":"sparse_show(sm::SparseMatrix)\n\nDisplay the sparse matrix sm.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_show-Tuple{SparseMatrix{Int64}}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_show","text":"sparse_show(sm::SparseMatrix{Int})\n\nDisplay the sparse matrix sm.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#Elementary-Matrix-Operations","page":"Sparse Matrix Functions","title":"Elementary Matrix Operations","text":"","category":"section"},{"location":"apicore/sparse/","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"sparse_add_column!(matrix::SparseMatrix, ci1::Int, ci2::Int, cn, cd)\nsparse_add_column!(::SparseMatrix{Int}, ::Int, ::Int, ::Int, ::Int)\nsparse_add_row!(matrix::SparseMatrix, ri1::Int, ri2::Int, cn, cd)\nsparse_add_row!(::SparseMatrix{Int}, ::Int, ::Int, ::Int, ::Int)\nsparse_permute(sm::SparseMatrix, pr::Vector{Int}, pc::Vector{Int})\nsparse_remove!(matrix::SparseMatrix, ri::Int, ci::Int)\nsparse_multiply(A::SparseMatrix,B::SparseMatrix)\nBase.:*(::SparseMatrix,::SparseMatrix)","category":"page"},{"location":"apicore/sparse/#ConleyDynamics.sparse_add_column!-Tuple{SparseMatrix, Int64, Int64, Any, Any}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_add_column!","text":"sparse_add_column!(matrix::SparseMatrix, ci1::Int, ci2::Int, cn, cd)\n\nReplace column[ci1] by column[ci1] + (cn/cd) * column[ci2].\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_add_column!-Tuple{SparseMatrix{Int64}, Vararg{Int64, 4}}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_add_column!","text":"sparse_add_column!(matrix::SparseMatrix{Int}, ci1::Int, ci2::Int,\n                   cn::Int, cd::Int)\n\nReplace column[ci1] by column[ci1] + (cn/cd) * column[ci2].\n\nThe computation is performed mod p, where the characteristic is taken from matrix.char. An error is thrown if matrix.char==0.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_add_row!-Tuple{SparseMatrix, Int64, Int64, Any, Any}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_add_row!","text":"sparse_add_row!(matrix::SparseMatrix, ri1::Int, ri2::Int, cn, cd)\n\nReplace row[ri1] by row[ri1] + (cn/cd) * row[ri2].\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_add_row!-Tuple{SparseMatrix{Int64}, Vararg{Int64, 4}}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_add_row!","text":"sparse_add_row!(matrix::SparseMatrix{Int}, ri1::Int, ri2::Int,\n                cn::Int, cd::Int)\n\nReplace row[ri1] by row[ri1] + (cn/cd) * row[ri2].\n\nThe computation is performed mod p, where the characteristic is taken from matrix.char. An error is thrown if matrix.char==0.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_permute-Tuple{SparseMatrix, Vector{Int64}, Vector{Int64}}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_permute","text":"sparse_permute(sm::SparseMatrix, pr::Vector{Int}, pc::Vector{Int})\n\nCreate sparse matrix by permuting the row and column indices.\n\nThe vector pr describes the row permutation, and pc the column permutation.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_remove!-Tuple{SparseMatrix, Int64, Int64}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_remove!","text":"sparse_remove!(matrix::SparseMatrix, ri::Int, ci::Int)\n\nRemove the sparse matrix entry at location (ri,ci).\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_multiply-Tuple{SparseMatrix, SparseMatrix}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_multiply","text":"sparse_multiply(A::SparseMatrix, B::SparseMatrix)\n\nMultiply two sparse matrices.\n\nExceptions are raised if the matrix product is not defined  or the entry types do not match.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#Base.:*-Tuple{SparseMatrix, SparseMatrix}","page":"Sparse Matrix Functions","title":"Base.:*","text":"Base.:*(A::SparseMatrix, B::SparseMatrix)\n\nMultiply two sparse matrices.\n\nExceptions are raised if the matrix product is not defined  or the entry types do not match.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#Conversion-Functions","page":"Sparse Matrix Functions","title":"Conversion Functions","text":"","category":"section"},{"location":"apicore/sparse/","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"sparse_from_full(matrix::Matrix{Int}; p::Int)\nfull_from_sparse(sm::SparseMatrix)\nsparse_from_lists(nr::Int, nc::Int, tchar::Int, tzero, tone, r::Vector{Int}, c::Vector{Int}, vals)\nlists_from_sparse(sm::SparseMatrix)","category":"page"},{"location":"apicore/sparse/#ConleyDynamics.sparse_from_full-Tuple{Matrix{Int64}}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_from_full","text":"sparse_from_full(matrix::Matrix{Int}; [p::Int=0])\n\nCreate integer sparse matrix from full matrix. If the optional argument p is specified and positive, then the matrix is interpreted over GF(p).\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.full_from_sparse-Tuple{SparseMatrix}","page":"Sparse Matrix Functions","title":"ConleyDynamics.full_from_sparse","text":"full_from_sparse(sm::SparseMatrix)\n\nCreate full matrix from sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_from_lists-Tuple{Int64, Int64, Int64, Any, Any, Vector{Int64}, Vector{Int64}, Any}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_from_lists","text":"sparse_from_lists(nr, nc, tchar, tzero, tone, r, c, v)\n\nCreate sparse matrix from lists describing the entries.\n\nThe vectors r, c, and v have to have the same length and the matric has entry v[k] at (r[k],c[k]). Zero entries will be ignored, and multiple entries for the same matrix position raise an error.\n\nThe input arguments have the following meaning:\n\nnr::Int: Number of rows\nnc::Int: Number of columns\ntchar: Field characteristic if T==Int\ntzero::T: Number 0 of type T\ntone::T:  Number 1 of type T\nr::Vector{Int}: Vector of row indices\nc::Vector{Int}: Vector of column indices\nv::Vector{T}: Vector of matrix entries\n\nIf tchar>0, then the entries in v are all replaced by their values mod tchar.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.lists_from_sparse-Tuple{SparseMatrix}","page":"Sparse Matrix Functions","title":"ConleyDynamics.lists_from_sparse","text":"nr, nc, tchar, tzero, tone, r, c, v = lists_from_sparse(sm::SparseMatrix)\n\nCreate list representation from sparse matrix.\n\nThe output variables are exactly what is needed to create a sparse matrix object using sparse_from_lists.\n\n\n\n\n\n","category":"method"},{"location":"#ConleyDynamics.jl","page":"Overview","title":"ConleyDynamics.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Conley index and multivector fields for Julia.","category":"page"},{"location":"#Introduction","page":"Overview","title":"Introduction","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"ConleyDynamics.jl is a Julia package for studying combinatorial multivector fields using Conley theory. The multivector fields can be studied on arbitrary Lefschetz complexes, which include both simplicial and cubical complexes as important special cases. The concept of combinatorial multivector field generalizes Forman vector fields, which were originally introduced to study Morse theory in a discrete combinatorial setting.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"note: Note\nThis package and the documentation is still very much work in progress!","category":"page"},{"location":"#Features","page":"Overview","title":"Features","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Data structures for Lefschetz complexes, in particular simplicial and cubical complexes.\nClassical Forman combinatorial vector fields and multivector fields are supported.\nComputation of Conley indices, connection matrices, and Conley-Morse graphs.\nBasic homology algorithms over finite fields and the rationals, including persistent homology and relative homology.\nAlgorithms rely on a built-in sparse matrix implementation which is geared towards computations over finite fields and the rationals.","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"To use ConleyDynamics please install Julia 1.10 or higher. See https://julialang.org/downloads/ for instructions on how to obtain Julia for your system.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"At the Julia prompt simply type","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> using Pkg; Pkg.add(\"ConleyDynamics\")","category":"page"},{"location":"#Manual-Outline","page":"Overview","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The Tutorial briefly explains how to get started with ConleyDynamics. More details, including on the underlying mathematics, are provided in the following four sections, which cover Lefschetz complexes, homology, Conley theory including connection matrices, and sparse matrices, respectively. Finally, a discussion of all included examples can be found in the Examples section.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Pages = [\n    \"man/tutorial.md\",\n    \"man/lefschetz.md\",\n    \"man/homology.md\",\n    \"man/conley.md\",\n    \"man/sparse.md\",\n    \"man/examples.md\",\n]\nDepth = 2","category":"page"},{"location":"apicore/datastruct/#Composite-Data-Structures","page":"Composite Data Structures","title":"Composite Data Structures","text":"","category":"section"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"The package relies on three basic composite data structures that encompass more complicated objects. For the internal representation of sparse matrices we refer to Internal Sparse Matrix Representation.","category":"page"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"ConleyDynamics","category":"page"},{"location":"apicore/datastruct/#ConleyDynamics","page":"Composite Data Structures","title":"ConleyDynamics","text":"module ConleyDynamics\n\nCollection of tools for computational Conley theory.\n\n\n\n\n\n","category":"module"},{"location":"apicore/datastruct/#Representation-of-a-Lefschetz-Complex","page":"Composite Data Structures","title":"Representation of a Lefschetz Complex","text":"","category":"section"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"LefschetzComplex","category":"page"},{"location":"apicore/datastruct/#ConleyDynamics.LefschetzComplex","page":"Composite Data Structures","title":"ConleyDynamics.LefschetzComplex","text":"LefschetzComplex\n\nCollect the Lefschetz complex information in a struct.\n\nThe struct has the following fields:\n\nncells::Int: Number of cells\ndim::Int: Dimension of the complex\nboundary::SparseMatrix{Int}: Boundary matrix, columns give the cell boundaries\nlabels::Vector{String}: Vector of labels associated with cell indices\nindices::Dict{String,Int}: Dictionary for finding cell index from label\ndimensions::Vector{Int}: Vector cell dimensions\n\nThe boundary matrix has to be of type SparseMatrix{Int}. The specific type is inferred from boundary.char. If the latter equals zero, then the matrix is over the ring of integers, and can be converted to either a rational or finite field matrix for connection matrix or homology computations. On the other hand, if boundary.char is a prime p, then it is interpreted as matrix over GF(p) and all future computations are restricted to that field.\n\n\n\n\n\n","category":"type"},{"location":"apicore/datastruct/#Representation-of-a-Multivector-Field","page":"Composite Data Structures","title":"Representation of a Multivector Field","text":"","category":"section"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"MultiVectorField","category":"page"},{"location":"apicore/datastruct/#ConleyDynamics.MultiVectorField","page":"Composite Data Structures","title":"ConleyDynamics.MultiVectorField","text":"MultiVectorField = Union{Vector{Vector{Int}},Vector{Vector{String}}}\n\nType of a multivector field.\n\n\n\n\n\n","category":"type"},{"location":"apicore/datastruct/#Representation-of-a-Conley-Morse-Graph","page":"Composite Data Structures","title":"Representation of a Conley-Morse Graph","text":"","category":"section"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"ConleyMorseCM","category":"page"},{"location":"apicore/datastruct/#ConleyDynamics.ConleyMorseCM","page":"Composite Data Structures","title":"ConleyDynamics.ConleyMorseCM","text":"ConleyMorseCM{T}\n\nCollect the connection matrix information in a struct.\n\nThe struct has the following fields:\n\ncm::SparseMatrix{T}: Connection matrix\ncolumns::Vector{Int}: Corresponding columns in the boundary matrix\nposet::Vector{Int}: Poset indices for the connection matrix columns\nlabels::Vector{String}: Labels for the connection matrix columns\nmorsesets::Vector{Vector{String}}: Vector of Morse sets in original complex\npoincare::Vector{Vector{Int}}: Vector of Poincare polynomial coefficients for the Morse sets. The k-th entry is the coefficient of t^(k-1).\n\n\n\n\n\n","category":"type"},{"location":"apicore/cmcore/#Conley-Theory-Functions","page":"Conley Theory Functions","title":"Conley Theory Functions","text":"","category":"section"},{"location":"apicore/cmcore/#Conley-Index-Computations","page":"Conley Theory Functions","title":"Conley Index Computations","text":"","category":"section"},{"location":"apicore/cmcore/","page":"Conley Theory Functions","title":"Conley Theory Functions","text":"conley_index(::LefschetzComplex,::Vector{Int};::Int)\nconley_index(::LefschetzComplex,::Vector{String};::Int)","category":"page"},{"location":"apicore/cmcore/#ConleyDynamics.conley_index-Tuple{LefschetzComplex, Vector{Int64}}","page":"Conley Theory Functions","title":"ConleyDynamics.conley_index","text":"conley_index(lc::LefschetzComplex, subcomp::Vector{Int};\n             p::Int)\n\nDetermine the Conley index of a Lefschetz complex subset.\n\nThe function raises an error if the subset subcomp is not locally closed. The optional parameter p specifies the field characteristic for the homology computation.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.conley_index-Tuple{LefschetzComplex, Vector{String}}","page":"Conley Theory Functions","title":"ConleyDynamics.conley_index","text":"conley_index(lc::LefschetzComplex, subcomp::Vector{String};\n             p::Int)\n\nDetermine the Conley index of a Lefschetz complex subset.\n\nThe function raises an error if the subset subcomp is not locally closed. The optional parameter p specifies the field characteristic for the homology computation.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#Connection-Matrix-Computation","page":"Conley Theory Functions","title":"Connection Matrix Computation","text":"","category":"section"},{"location":"apicore/cmcore/","page":"Conley Theory Functions","title":"Conley Theory Functions","text":"connection_matrix(::LefschetzComplex,::MultiVectorField;::Int,::Bool)\ncm_reduce!(::SparseMatrix,::Vector{Int};::Bool)","category":"page"},{"location":"apicore/cmcore/#ConleyDynamics.connection_matrix-Tuple{LefschetzComplex, Union{Vector{Vector{Int64}}, Vector{Vector{String}}}}","page":"Conley Theory Functions","title":"ConleyDynamics.connection_matrix","text":"connection_matrix(lc::LefschetzComplex, mvf::MultiVectorField;\n                  [p::Int,] [returnbasis::Bool])\n\nCompute a connection matrix for the multivector field mvf on the Lefschetz complex lc over a finite field with p elements, or  over the rationals.\n\nThe function returns an object of type ConleyMorseCM. If the optional argument returnbasis::Bool=true is given, then the function also returns a dictionary which gives the basis for the connection matrix columns in terms of the original labels. If p is omitted, then the Lefschetz complex boundary has to has been specified over a field. If the boundary matrix is an integer matrix, p has to be chosen.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.cm_reduce!-Tuple{SparseMatrix, Vector{Int64}}","page":"Conley Theory Functions","title":"ConleyDynamics.cm_reduce!","text":"cm_reduce!(matrix::SparseMatrix, psetvec::Vector{Int};\n           [returnbasis::Bool])\n\nCompute the connection matrix.\n\nAssumes that matrix is upper triangular and filtered according to psetvec. Modifies the argument matrix.\n\nReturn values:\n\ncmatrix: Connection matrix\ncmatrix_cols: Columns of the connection matrix in the boundary\nbasisvecs (optional): If the argument returnbasis=true is given, this returns information about the computed basis. The k-th entry of basisvecs is a vector containing the columns making up the k-th basis vector, which corresponds to column cmatrix_cols[k].\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#Poset-Order-Functions","page":"Conley Theory Functions","title":"Poset Order Functions","text":"","category":"section"},{"location":"apicore/cmcore/","page":"Conley Theory Functions","title":"Conley Theory Functions","text":"admissible_order(bndmatrix::SparseMatrix, mvf::Vector{Vector{Int}})\nrenumber_poset!(poset::Vector{Int})","category":"page"},{"location":"apicore/cmcore/#ConleyDynamics.admissible_order-Tuple{SparseMatrix, Vector{Vector{Int64}}}","page":"Conley Theory Functions","title":"ConleyDynamics.admissible_order","text":"admissible_order(bndmatrix::SparseMatrix, mvf::Vector{Vector{Int}})\n\nFind an admissible order based on the boundary matrix and the multivector field.\n\nThe vector sccnumber contains the strongly connected component for each column, and the matrix admibnd is the reordered boundary matrix corresponding to the order given by admiorder.\n\nReturn values:\n\nadmiorder: Admissible order\nadmibnd: Reordered boundary matrix\nsccnumber: Strongly connected component index of column\nscc: Strongly connected components\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.renumber_poset!-Tuple{Vector{Int64}}","page":"Conley Theory Functions","title":"ConleyDynamics.renumber_poset!","text":"renumber_poset!(poset::Vector{Int})\n\nRenumber the poset given by the increasing integer vector poset.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#Matrix-Helper-Functions","page":"Conley Theory Functions","title":"Matrix Helper Functions","text":"","category":"section"},{"location":"apicore/cmcore/","page":"Conley Theory Functions","title":"Conley Theory Functions","text":"cm_columns(matrix::SparseMatrix, psetvec::Vector{Int})\nhomogeneous_columns(::SparseMatrix,::Vector{Int})\nis_homogeneous(::SparseMatrix,::Vector{Int},::Int)\ntarget_columns(matrix::SparseMatrix, psetvec::Vector{Int})","category":"page"},{"location":"apicore/cmcore/#ConleyDynamics.cm_columns-Tuple{SparseMatrix, Vector{Int64}}","page":"Conley Theory Functions","title":"ConleyDynamics.cm_columns","text":"cm_columns(matrix::SparseMatrix, psetvec::Vector{Int})\n\nCreate a vector of column indices for the connection matrix.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.homogeneous_columns-Tuple{SparseMatrix, Vector{Int64}}","page":"Conley Theory Functions","title":"ConleyDynamics.homogeneous_columns","text":"homogeneous_columns(matrix::SparseMatrix, psetvec::Vector{Int})\n\nDetermine which columns of matrix are homogenenous columns.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.is_homogeneous-Tuple{SparseMatrix, Vector{Int64}, Int64}","page":"Conley Theory Functions","title":"ConleyDynamics.is_homogeneous","text":"is_homogeneous(matrix::SparseMatrix, psetvec::Vector{Int}, cindex::Int)\n\nDecide whether a column of matrix is homogeneous.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.target_columns-Tuple{SparseMatrix, Vector{Int64}}","page":"Conley Theory Functions","title":"ConleyDynamics.target_columns","text":"target_columns(matrix::SparseMatrix, psetvec::Vector{Int})\n\nDetermine which columns of matrix are target columns.\n\n\n\n\n\n","category":"method"}]
}
