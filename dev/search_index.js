var documenterSearchIndex = {"docs":
[{"location":"apicore/apiindex/#Complete-API-Index","page":"Complete API Index","title":"Complete API Index","text":"","category":"section"},{"location":"apicore/apiindex/#indexdata","page":"Complete API Index","title":"Composite Data Structures","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"datastruct.md\"]","category":"page"},{"location":"apicore/apiindex/#indexlefschetz","page":"Complete API Index","title":"Lefschetz Complex Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"lefschetz.md\"]","category":"page"},{"location":"apicore/apiindex/#indexhomology","page":"Complete API Index","title":"Homology Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"homology.md\"]","category":"page"},{"location":"apicore/apiindex/#indexconley","page":"Complete API Index","title":"Conley Theory Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"conley.md\"]","category":"page"},{"location":"apicore/apiindex/#indexexample","page":"Complete API Index","title":"Example Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"examples.md\"]","category":"page"},{"location":"apicore/apiindex/#indexplot","page":"Complete API Index","title":"Plotting Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"plots.md\"]","category":"page"},{"location":"apicore/apiindex/#indexsparse","page":"Complete API Index","title":"Sparse Matrix Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"sparse.md\"]","category":"page"},{"location":"apicore/homology/#Homology-Functions","page":"Homology Functions","title":"Homology Functions","text":"","category":"section"},{"location":"apicore/homology/#Regular-Homology","page":"Homology Functions","title":"Regular Homology","text":"","category":"section"},{"location":"apicore/homology/#ConleyDynamics.homology","page":"Homology Functions","title":"ConleyDynamics.homology","text":"homology(lc::LefschetzComplex)\n\nCompute the homology of a Lefschetz complex.\n\nThe homology is returned as a vector betti of Betti numbers, where betti[k] is the Betti number in dimension k-1. The computations are performed over the field associated with the Lefschetz complex boundary matrix.\n\n\n\n\n\n","category":"function"},{"location":"apicore/homology/#ConleyDynamics.relative_homology","page":"Homology Functions","title":"ConleyDynamics.relative_homology","text":"relative_homology(lc::LefschetzComplex,subc::Cells)\n\nCompute the relative homology of a Lefschetz complex with respect to a subcomplex. The computation is performed over the field associated with the Lefschetz boundary matrix.\n\nThe subcomplex is the closure of the cells in subc, which can be given either as indices or labels. The homology is returned as a vector betti of Betti numbers, where betti[k] is the Betti number in dimension k-1.\n\n\n\n\n\nrelative_homology(lc::LefschetzComplex,subc::Cells,subc0::Cells)\n\nCompute the relative homology of a Lefschetz complex with respect to a subcomplex. The computation is performed over the field associated with the Lefschetz boundary matrix.\n\nIn this implementation, relative homology of the pair cl(subc), cl(subc0)) is computed. An error is raised if cl(subc0) is not a subset of cl(subc). The homology is returned as a vector betti of Betti numbers, where betti[k] is the Betti number in dimension k-1.\n\n\n\n\n\n","category":"function"},{"location":"apicore/homology/#Persistent-Homology","page":"Homology Functions","title":"Persistent Homology","text":"","category":"section"},{"location":"apicore/homology/#ConleyDynamics.persistent_homology","page":"Homology Functions","title":"ConleyDynamics.persistent_homology","text":"persistent_homology(lc::LefschetzComplex, filtration::Vector{Int})\n\nComplete the persistent homology of a Lefschetz complex filtration over the field associated with the Lefschetz complex boundary matrix.\n\nThe function returns the two values\n\nphsingles::Vector{Vector{Int}}\nphpairs::Vector{Vector{Tuple{Int,Int}}}\n\nIt assumes that the order given by the filtration values is admissible, i.e., the permuted boundary matrix is strictly upper triangular. The function returns the starting filtration values for infinite length persistence intervals in phsingles, and the birth- and death-filtration values for finite length persistence intervals in phpairs.\n\n\n\n\n\n","category":"function"},{"location":"apicore/homology/#Reduction-Algorithm","page":"Homology Functions","title":"Reduction Algorithm","text":"","category":"section"},{"location":"apicore/homology/#ConleyDynamics.ph_reduce!","page":"Homology Functions","title":"ConleyDynamics.ph_reduce!","text":"ph_reduce!(matrix::SparseMatrix; [returnbasis=true])\n\nApply the persistence reduction algorithm to the matrix.\n\nThe function returns the values\n\nphsingles::Vector{Vector{Int}}\nphpairs::Vector{Vector{Tuple{Int,Int}}}\nbasis::SparseMatrix (if returnbasis=true)\n\nIt assumes that matrix is strictly upper triangular. The function returns the starting columns for infinite length persistence intervals in phsingles, and the birth- and death-columns for finite length persistence intervals in phpairs. If the optional argument returnbasis=true is given, then the function also returns the computed basis matrix B with reduced = matrix * B.\n\n\n\n\n\n","category":"function"},{"location":"man/lefschetz/#Lefschetz-Complexes","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The fundamental structure underlying the functionality of ConleyDynamics.jl is a Lefschetz complex. It provides us with the basic model of phase space for combinatorial topological dynamics. In view of the combinatorial, and therefore discrete, character of the dynamical behavior, a Lefschetz complex is not a typical phase space in the sense of classical dynamics. While the latter one is usually a Euclidean space, a Lefschetz complex is basically a combinatorial model of it. In the following, we provide its precise mathematical definition, and explain how it can be created and modified within the package. We also discuss two important special cases, namely simplicial complexes and cubical complexes.","category":"page"},{"location":"man/lefschetz/#Basic-Lefschetz-Terminology","page":"Lefschetz Complexes","title":"Basic Lefschetz Terminology","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The original definition of a Lefschetz complex can be found in [Lef42], where it was simply referred to as a complex.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"tip: Definition: Lefschetz complex\nLet F denote an arbitrary field. Then a pair (Xkappa) is called a Lefschetz complex over F if X = (X_k)_k in mathbbN_0 is a finite set with mathbbN_0-gradation, and kappa  X times X to F is a mapping such that   kappa(xy) neq 0\n   quadmathrm implies quad\n   x in X_k\n   quadmathrm and quad y in X_k-1and such that for any xz in X one has   sum_y in X kappa(xy) kappa(yz) = 0  The elements of X are referred to as cells, the value kappa(xy) in F is called the incidence coefficient of the cells x and y, and the map kappa is the incidence coefficient map. In addition, one defines the dimension of a cell xin X_k as the integer k, and denotes it by k = dim x. Whenever the incidence coefficient map is clear from context, we often just refer to X as the Lefschetz complex.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"At first glance the above definition can seem daunting. However, it is based on a straightforward geometric idea. A Lefschetz  complex is a structure that is built from elementary building blocks called cells. Each cell has a dimension associated with it, and it is topologically an open ball of this dimension. Thus, cells of dimension zero are points, also called vertices. Cells of dimension one are open curve segments, which we call edges, and two-dimensional cells are called faces and take the form of open two-dimensional membranes.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The incidence coefficient map encodes how these cells are glued together to form the Lefschetz complex X. In order to shed more light on this, consider the boundary map partial which is defined on cells via","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   partial x = sum_y in X kappa(xy) y  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"This map sends a cell x of dimension k to a specific  linear combination of cells of dimension k-1, called the boundary of x. By using ideas from linear algebra, the boundary map can be extended to map a general linear combination of k-dimensional cells to the corresponding linear combination of the separate boundaries. For example, if one chooses the field F = mathbbQ of rationals, one has partial  (x_1 - 2x_2) = partial x_1 - 2 partial x_2. Notice that using this extended definition of the boundary map, one can rewrite the summation condition in the definition of a Lefschetz complex in the equivalent form","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   partial( partial x) = 0\n   quadtext for all cells quad\n   x in X  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"In other words, the boundary of any cell is itself boundaryless.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"With the help of the boundary map, one can often infer the overall geometric structure of a Lefschetz complex X. For this, think of a Lefschetz complex as being build from the ground up in the following way. First, start by putting down all vertices of X at different locations in some ambient space. Since the boundary of each one-dimensional cell is made up of a linear combination of vertices, one can then add a curve segment for each one-dimensional cell, which connects the vertices in its boundary. Note that in the general version of a Lefschetz complex it is possible that an edge has only one vertex in its boundary, or maybe even none, and in these cases the edge is either only connected to the one boundary vertex, or it is an open curve segment connected to no vertex at all, respectively. Continue in this fashion to add two-dimensional faces to fill in the space between the edges in its boundary, and so on for higher dimensions. Needless to say, in the case of a general complicated Lefschetz complex this procedure is of limited use, since the boundary of a cell can be an arbitrary linear combination of cells, with coefficients that can be any nonzero numbers in the field F. Yet, in many simple cases the above intuition is sufficient.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"In addition to the Lefschetz complex definition, there are a handful of other concepts which will be important for our discussion of Lefschetz complexes. Specifically, the following notions are important:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"A facet of a cell x in X is any cell y which satisfies kappa(xy) neq 0.\nOne can define a partial order on the cells of X by letting x le y if and only if for some integer n in mathbbN there exist cells x = x_1 ldots x_n = y such that x_k is a facet of x_k+1 for all k = 1 ldots n-1. It is not difficult to show that this defines a partial order on X, i.e., this relation is reflexive, antisymmetric, and transitive. We call this partial order the face relation.  Moreover, if x le y then x is called a face of y.\nA subset C subset X of a Lefschetz complex is called closed, if for every x in C all the faces of the cell x are also contained in the subset C.\nThe closure of a subset C subset X is the collection of all faces of all cells in C, and it is denoted by mathrmcl C. Thus, a subset of a Lefschetz complex is closed if and only if it equals its closure.\nA subset S subset X is called locally closed, if its mouth mathrmmo S = mathrmcl S setminus S is closed. Note that every closed set is automatically locally closed, but the reverse implication is usually false.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"While the first two points merely introduce notation for describing the combinatorial boundary of cells, the remaining three points establish important topological concepts. In fact, the above definition of closedness defines a topology on the Lefschetz complex X, which is the so-called Alexandrov topology from [Ale37]. As usual in the field of topology, a subset of a Lefschetz complex will be called open, if and only if its complement is closed.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"We would like to point out that while the concept of local closedness is rarely considered in standard topology courses, it is of utmost important for the study of combinatorial topological dynamics. For the moment, we just mention the following result:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"danger: Theorem: Lefschetz subcomplexes\nLet X be a Lefschetz complex over a field F, and let kappa  X times X to F denote its incidence coefficient map. Then a subset S subset X is again a Lefschetz complex, with respect to the restriction of kappa to S times S, if the subset S is locally closed.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"This result goes back to [MB09, Theorem 3.1]. In other words, in the category of Lefschetz complexes local closedness arises naturally. Due to its importance, we also mention the following two equivalent formulations:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"A subset S subset X is locally closed, if and only if it is the difference of two closed subsets of X.\nA subset S subset X is locally closed, if and only if it is an interval with respect to the face relation on X, i.e., whenever we have three cells with S ni x le y le z in S, then one has to have y in S as well.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The proof of these characterizations can be found in [MW25, Proposition 3.2.1] and [LKMW23, Proposition 3.10], respectively.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Lefschetz complexes are a very general mathematical concept, and they can be rather confusing at first sight. Nevertheless, they do encompass other complex types, which are more geometric in nature. As we already saw in the tutorial, every simplicial complex is automatically a Lefschetz complex, and we will further elaborate on this connection below. In addition, we will also demonstrate that cubical complexes are Lefschetz complexes. More general, any regular CW complex is  a Lefschetz complex as well. For more details on this, we refer to the definition in [Mas91] and the discussion in [DKMW11].","category":"page"},{"location":"man/lefschetz/#Lefschetz-Complex-Data-Structure","page":"Lefschetz Complexes","title":"Lefschetz Complex Data Structure","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"For the efficient and easy manipulation of Lefschetz complexes in ConleyDynamics.jl we make use of a specific composite data type:","category":"page"},{"location":"man/lefschetz/#ConleyDynamics.LefschetzComplex-man-lefschetz","page":"Lefschetz Complexes","title":"ConleyDynamics.LefschetzComplex","text":"LefschetzComplex\n\nCollect the Lefschetz complex information in a struct.\n\nThe struct is created via the following fields:\n\nlabels::Vector{String}: Vector of labels associated with cell indices\ndimensions::Vector{Int}: Vector cell dimensions\nboundary::SparseMatrix: Boundary matrix, columns give the cell boundaries\n\nIt is expected that the dimensions are given in increasing order, and that the square of the boundary matrix is zero. Otherwise, exceptions are raised. In addition, the following fields are created during initialization:\n\nncells::Int: Number of cells\ndim::Int: Dimension of the complex\nindices::Dict{String,Int}: Dictionary for finding cell index from label\n\nThe coefficient field is specified by the boundary matrix.\n\nwarning: Warning\nNote that the constructor does not check whether the boundary matrix squares to zero. It is the responsibility of the user to ensure that!\n\n\n\n\n\n","category":"type"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The fields of this struct relate to the mathematical definition of a Lefschetz complex X in the following way:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Internally, every cell of the Lefschetz complex is represented by an integer between 1 and the total number of cells. However, in order to make it easier to interpret the results of computations, each cell in a Lefschetz complex has to also be given a label. These labels are contained in the field labels::Vector{String}, where labels[k] gives the label of cell k.\nThe vector dimensions is a Vector{Int} and collects the  dimensions of the cells. In other words, the cell which is indexed by the integer k has dimension dimensions[k]. It is expected that the dimension vector is increasing, and the constructor method will verify this. Otherwise, an error is triggered.\nThe incidence coefficient map kappa is encoded in the sparse matrix boundary. This matrix is a square matrix with ncells  rows and columns. The k-th column contains the incidence coefficients kappa(kcdot) in the sense that the entry in row m and column k equals the value kappa(km). Since for most Lefschetz complexes the majority of the incidence coefficients is zero, the matrix is represented using the sparse format SparseMatrix, which is described in more detail in Sparse Matrices. An exception is raised if the square of the boundary matrix is not zero.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"When creating a Lefschetz complex, only the above three items have to be specified, as they define a unique Lefschetz complex X. In other words, a Lefschetz complex is generally created via the command","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   lc = LefschetzComplex(labels, dimensions, boundary)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"During the construction of the Julia object, additional fields are initialized which simplify working with a Lefschetz complex:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The integer ncells gives the total number of cells in X. Internally, these cells are numbered by integers ranging from 1 to ncells.\nThe integer dim describes the overall dimension of the Lefschetz complex, which is the largest dimension of a cell.\nIn order to easily determine the integer index for a cell with a specific label, the field indices contains a dictionary of type Dict{String,Int} which maps labels to indices. For  example, if a cell has the label \"124.010\", then the associated integer index is given by indices[\"124.010\"].","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"As mentioned above, note however that an object of type LefschetzComplex is created by passing only the first three the field items in the order given in LefschetzComplex. Consider for example the Lefschetz complex from Figure 2.4 in [MW25], see also the left complex in the next image. This complex consists of six cells with labels A,  B, a, b, c, and alpha, and we initialize the vector of labels, the cell index dictionary, and the cell dimensions via the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"ncL = 6\nlabelsL = Vector{String}([\"A\",\"B\",\"a\",\"b\",\"c\",\"alpha\"])\ncdimsL  = [0, 0, 1, 1, 1, 2]","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The boundary matrix can then be defined using","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"bndmatrixL = zeros(Int, ncL, ncL)\nbndmatrixL[[1,2],3] = [1; 1]     # a\nbndmatrixL[[1,2],4] = [1; 1]     # b\nbndmatrixL[[1,2],5] = [1; 1]     # c\nbndmatrixL[[3,4],6] = [1; 1]     # alpha\nbndsparseL = sparse_from_full(bndmatrixL, p=2)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Notice that we first create the matrix as a regular integer  matrix, and then use the function sparse_from_full  to turn it into sparse format over the field GF(2) with characteristic p = 2. This is the most convenient method for small boundary matrices, yet for larger ones it is better to use the function sparse_from_lists. Finally, the Lefschetz complex is created using","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"lcL = LefschetzComplex(labelsL, cdimsL, bndsparseL)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"(Image: Two sample Lefschetz complexes)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Lefschetz complexes do not always have to contain cells of all dimensions. For example, the Lefschetz complex shown on the right side of the figure has no vertices, and it can be created using the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"ncR = 4\nlabelsR  = Vector{String}([\"a\",\"b\",\"c\",\"alpha\"])\ncdimsR   = [1, 1, 1, 2]\nbndmatrixR = zeros(Int, ncR, ncR)\nbndmatrixR[[1,2,3],4] = [1; 1; 1]     # alpha\nbndsparseR = sparse_from_full(bndmatrixR, p=2)\nlcR = LefschetzComplex(labelsR, cdimsR, bndsparseR)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"While Lefschetz complexes can always be created in ConleyDynamics.jl in this direct way, it is often more convenient to make use of special types, such as simplicial and cubical complexes, and then restrict the complex to a locally closed set using the function lefschetz_subcomplex. As an alternative, if one is  interested in a fairly small Lefschetz complex over the field GF(2), then the following special function can be used:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"create_lefschetz_gf2 creates a Lefschetz complex over the two-element field GF(2) by specifying its essential cells and boundaries. The input argument defcellbnd of the function has to be a vector of vectors. Each entry defcellbnd[k] then has to be of one of the following two forms:\n[String, Int, String, String, ...]: The first String contains  the label for the cell k, followed by its dimension in the second  entry. The remaining entries are for the labels of the cells which  make up the boundary.\n[String, Int]: This shorther form is for cells with empty boundary. The first entry denotes the cell label, and the second its dimension.\nThe cells of the resulting Lefschetz complex correspond to the union of all occurring labels. Cell labels that only occur in the boundary specification are assumed to have empty boundary, and they do not have to be specified separately in the second form above. However, if their boundary is not empty, they have to be listed via the above first form as well.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Using this function, our earlier Lefschetz complex lcL can be created using the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"defcellbndL = [[\"a\",1,\"A\",\"B\"], [\"b\",1,\"A\",\"B\"], [\"c\",1,\"A\",\"B\"], [\"alpha\",2,\"a\",\"b\"]]\nlcL = create_lefschetz_gf2(defcellbndL)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"while the Lefschetz complex lcR is defined via","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"defcellbndR = [[\"alpha\",2,\"a\",\"b\",\"c\"], [\"a\",1], [\"b\",1], [\"c\",1]]\nlcR = create_lefschetz_gf2(defcellbndR)","category":"page"},{"location":"man/lefschetz/#Simplicial-Complexes","page":"Lefschetz Complexes","title":"Simplicial Complexes","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"One of the earliest types of complexes that have been studied in  topology are simplicial complexes. As already mentioned in the tutorial, an abstract simplicial complex X is a finite collection of finite sets, called simplices, which is closed under taking subsets. Each simplex sigma has a dimension dimsigma, which is one less than the number of its elements.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"In order to see why every simplicial complex is automatically a  Lefschetz complex, we need to be able to define the incidence  coefficient map kappa. For this, we make use of some notions from [Mun84]. Let X_0 denote the collection of all vertices of the simplicial complex X. Then we use the notation","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   sigma = left v_0 v_1 ldots v_d right\n   quadtext with quad\n   v_k in X_0","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"to describe a d-dimensional simplex. Note that even though every simplex in X is just the set of its vertices, in the above  representation we pick an order of the vertices, called an orientation of the simplex. This orientation can be chosen arbitrarily, and there are two equivalence classes of orientations. To get from one orientation to the other, one just has to exchange two vertices, and we write","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   left ldots v_i ldots v_j ldots right  = \n   -left ldots v_j ldots v_i ldots right  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"For more complicated reorderings, one has to represent the corresponding vertex permutation as a sequence of such exchanges. Using these oriented simplices we can define the boundary operator","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   partial sigma  = \n   partial left v_0 ldots v_d right  = \n   sum_i=0^d (-1)^i left v_0 ldots hatv_i\n     ldots v_d right  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"where the notation hatv_i means that in the simplex behind the summation sign on the right-hand side the vertex v_i is omitted. For example, for a two-dimensional simplex one obtains","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   partial left v_0 v_1 v_2 right  = \n   left v_1 v_2 right - \n   left v_0 v_2 right + \n   left v_0 v_1 right  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Thus, if one chooses a total order of all the vertices in the simplicial complex, and orients the individual simplices in such a way that their vertices are arranged using this overall order, then the incidence coefficient map is given by","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   kappa left( left v_0 ldots v_i ldots v_d right \n     left v_0 ldots hatv_i ldots v_d right right)\n    =  (-1)^i  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"If some or all of the simplices are represented by different orientations, one simply has to multiply the value (-1)^i by the sign of a suitable vertex permutation. In either case, one can show that the so-defined map kappa does indeed satisfy the definition of a Lefschetz complex. For more details, see [Mun84, Lemma 5.3].","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"In ConleyDynamics.jl there are three basic commands for defining a simplicial complex:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"create_simplicial_complex is the most general method, and it expects two input arguments. The first is usually called labels, and  it has to have the data type Vector{String}. This vector lists the labels for each vertex. It is important that all of these labels have exactly the same number of characters. The second argument is usually called simplices, and it lists as many simplices as necessary for defining the underlying simplicial complex. This means that in practice one only needs to include the simplices which are not faces of higher-dimensional ones, see also the example below. The variable simplices can either be of type Vector{Vector{String}} or Vector{Vector{Int}}, depending on whether the vertices are identified via their labels or integer indices, respectively. Finally, the optional parameter p can be used to specify the underlying field for the  boundary matrix. If p is a prime, then F = GF(p), while for p = 0 the function uses F = mathbbQ. If the argument p is ommitted, the function defaults to p = 2.\ncreate_simplicial_rectangle expects two integer arguments nx and ny, and then creates a triangulation of the square 0nx times 0ny by subdividing every unit square into four triangles which meet at the center of the square. As before, the optional parameter p specifies the underlying field.\ncreate_simplicial_delaunay creates a planar Delaunay triangulation inside a planar rectangle. The function selects a random sample of points inside the box, while either trying to maintain a minimum distance between the points, or just using a prespecified number of points. More details on these two options can be found in the documentation for the function.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"To illustrate the first of these functions, consider the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"labels = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\"]\nsimplices = [[\"A\",\"B\"],[\"A\",\"F\"],[\"B\",\"F\"],[\"B\",\"C\",\"G\"],[\"D\",\"E\",\"H\"],[\"C\",\"D\"],[\"G\",\"H\"]]\nsc = create_simplicial_complex(labels,simplices)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"These create the simplicial complex sc, in the form of a  Lefschetz complex. Note that the above commands only specify the labels for the vertices. The labels for simplices of dimension at least one are automatically generated by concatenating the labels for their vertices, sorted in lexicographic order. This can be seen in the following Julia output:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"julia> sc.labels[end-4:end]\n5-element Vector{String}:\n \"DH\"\n \"EH\"\n \"GH\"\n \"BCG\"\n \"DEH\"","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The simplicial complex sc can be visualized using the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"coords = [[0,0],[2,0],[4,0],[6,0],[8,0],[1,2],[4,2],[6,2]]\nldir   = [3,3,3,3,3,1,1,1]\nfname  = \"lefschetzex2.pdf\"\nplot_planar_simplicial(sc,coords,fname,labeldir=ldir,labeldis=10,hfac=2,vfac=1.5,sfac=50)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"(Image: First sample simplicial complex)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Similarly, the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"sc2, coords2 = create_simplicial_rectangle(5,2)\nfname2 = \"lefschetzex3.pdf\"\nplot_planar_simplicial(sc2,coords2,fname2,hfac=2.0,vfac=1.2,sfac=75)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"define and illustrate a second simplicial complex, which triangularizes a rectangle in the plane.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"(Image: Second sample simplicial complex)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"For a demonstration of the Delaunay triangulation approach, please see Analyzing Planar Vector Fields.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"In addition to the above methods, ConleyDynamics.jl also provides a few special simplicial complexes for illustration purposes:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"simplicial_torus constructs a triangulation of the two-dimensional torus.\nsimplicial_klein_bottle returns a triangulation of the two-dimensional Klein bottle.\nsimplicial_projective_plane constructs a triangulation of the projective plane.\nsimplicial_torsion_space returns a simplicial complex K with the integer homology groups H_0(K) cong mathbb Z, as well as H_1(K) cong mathbb Z_n and H_2(K) cong 0. In other words, this simplicial complex has nontrivial torsion in dimension 1. For n = 3 and n = 4 these triangulations are shown in the following figure. Notice that points with the same label have to be identified. This vertex naming scheme is the same as is used in the function.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"(Image: Simplicial torsion space)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"These examples can be used to illustrate homology over different fields.","category":"page"},{"location":"man/lefschetz/#Cubical-Complexes","page":"Lefschetz Complexes","title":"Cubical Complexes","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The second important special case of a Lefschetz complex is called cubical complex, and it has been discussed in detail in [KMM04]. In the following, we only present the definitions that are essential for our purposes.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Loosely speaking, a cubical complex is a collection of cubes of varying dimensions in some Euclidean space mathbbR^d. More precisely, we say that an interval I subset mathbbR is an elementary interval if it is of the form","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   I = ell ell+1\n   quadtext or quad\n   I = ell ell\n   quadtext for some integer quad\n   ell in mathbbZ  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"If the elementary interval I consists of only one point, then it is called degenerate, and it is nondegenerate if it is of length one. Elementary intervals are the building blocks for the cubes in a cubical complex. For a complex in mathbbR^d, an elementary cube Q is of the form","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   Q  = \n   I_1 times I_2 times ldots times I_d  subset \n   mathbbR^d  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"where I_1 ldots I_d are elementary intervals. The dimension dim Q of an elementary cube is given by the number of nondegenerate intervals in its representation. For example, the cube Q = 00  times 11 is a zero-dimensional elementary cube in mathbbR^2 which contains only the point (01), while the elementary cube R = 22 times 34 is one-dimensional, and consists of the  closed vertical line segment between the points (23) and (24).","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"After these preparations, the definition of a cubical complex is now straightforward. A cubical complex X in mathbbR^d is a finite collection of elementary cubes in mathbbR^d which is closed under the inclusion of elementary subcubes. More precisely, if Q in X is an elementary cube in the cubical complex, and if R subset Q is any elementary cube contained in Q, then one also has R in X.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The definition of a cubical complex is reminiscent of that of a simplicial complex. It is therefore not surprising that also in the cubical case one can describe the incidence coefficient map kappa explicitly, and thus recognize a cubical complex as a Lefschetz complex. For this, we need more notation.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Let Q = I_1 times I_2 times ldots times I_d denote an elementary cube, and let the nondegenerate elementary intervals in this decomposition be given by I_i_1 ldots I_i_n, where I_i_j = k_j k_j + 1 and j = 1ldotsn = dim Q. For every index j, we further define the two (n-1)-dimensional elementary cubes","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   beginarrayccccccc\n   Q_j^-  =  I_1 times ldots times I_i_j - 1  times \n           k_j k_j  times  I_i_j + 1 times ldots\n           times I_d   2ex\n   Q_j^+  =  I_1 times ldots times I_i_j - 1  times \n           k_j + 1 k_j + 1  times  I_i_j + 1 times\n           ldots times I_d  \n   endarray","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Geometrically, the two elementary cubes Q_j^- and Q_j^+ are directly opposite sides of the elementary cube Q. Using them, one can define the algebraic boundary of the cube as","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   partial Q  = \n   sum_j=1^n (-1)^j-1 left( Q_j^+ - Q_j^- right) ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"This formula is the cubical analogue of the boundary operator in a simplicial complex, and it allows us to define the incidence coefficient map via","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   kappaleft( Q  Q_j^+ right)  =  (-1)^j-1\n   quadtext and quad\n   kappaleft( Q  Q_j^- right)  =  (-1)^j  \n   quadtext for all quad\n   j = 1 ldots n  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"For all remaining pairs of elementary cubes in X we let kappa = 0. Then it was shown in [KMM04, Proposition 2.37] that the so-defined incidence coefficient map satisfies the summation condition in the definition of a Lefschetz complex, i.e., we have partial(partial Q) = 0 for every Q in X. This in turn implies that every cubical complex is indeed a Lefschetz complex.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Cubical complexes in ConleyDynamics.jl are a little more restricted. Since a cubical complex in the above sense is always finite, one can assume without loss of generality that the left endpoints of all involved elementary intervals are nonnegative. In other words, we always assume that the cubical complex only contains elementary cubes from the set (mathbbR_0^+)^d. This allows for a simple encoding of elementary cubes via labels of a fixed length, and without having to worry about the sign of an integer.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"To describe this, fix a dimension d of the ambient space. Then every elementary cube in (mathbbR_0^+)^d has the following label, which depends on a coordinate width L:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The first d cdot L characters of the label encode the  starting points of the elementary intervals I_1 ldots I_d in the standard representation of the elementary cube. For this, the starting points, which are nonnegative integers, are concatenated without spaces, but with leading zeros. For example, with L = 2 the string \"010203\" would correspond to the starting points 1, 2, and 3. Note that for given coordinate width L, one can only encode starting points between 0 and 10^L-1.\nThe next entry in the label string is a period ..\nThe remaining d characters of the string are integers 0 or 1, which give the interval lengths of I_1 ldots I_d.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"For example, for L = 2 the string \"030600.000\" corresponds to the point (360) in three dimensions. Similarly, the label \"030600.101\" represents the two-dimensional elementary cube 34 times 66 times 01 subset mathbbR^3. Note, however, that the label representation is not unique, since it depends on the coordinate width L. Thus, with L = 1 the latter cube could also be written as \"360.101\", or with L = 3 as \"003006000.101\". As we will see in a moment, though, within a given cubical complex all labels have to use the same coordinate width L! This implies in particular that for a given coordinate width L one can only represent bounded cubical complexes which are contained in the d-dimensional box 010^L-1^d.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The following three helper functions simplify the work with these types of cube labels:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"cube_field_size determines the field sizes of a given cube label. The first return value gives the dimension d of the ambient space, while the second value returns the coordinate width L.\ncube_information returns all information encoded in the cube label. The function returns an integer vector of length 2d+1, where d is the dimension of the ambient space. The first d entries give the vector of elementary interval starting points, while the next d values yield the corresponding interval lengths. The last entry specifies the dimension of the cube.\ncube_label creates a label from a cube's coordinate information. As function parameters, one has to specify d and L, and then pass an integer vector of length six which specifies the coordinates of the starting points and the interval lengths as in the previous item.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"In ConleyDynamics.jl there are four basic commands for defining a cubical complex and working with it:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"create_cubical_complex creates a cubical complex in the Lefschetz complex data format. The complex is specified via a list of all the highest-dimensional cubes which are necessary to define the cubical complex. For this, every cube has to be given using the above-described special label format, with the same coordinate width L. In other words, all label strings have to be of the same length! If the optional parameter p is specified, the complex will be defined over a field with characteristic p, analogous to the case of a simplicial complex. If the characteristic is not specified, then the function defaults to the field GF(2).\nget_cubical_coords determines the coordinates of all  vertices of a given cubical complex from the cube labels. This vector can then be used for plotting purposes, see below.\ncreate_cubical_rectangle creates a cubical complex covering a rectangle in the plane. The rectangle is given by the subset 0nx times 0ny of the plane, where the nonnegative integers nx and ny have to be passed as arguments to the function. The function returns the cubical complex, and a vector of coordinates for the vertices. The latter can also be randomly perturbed as described in more detail in the function documentation.\ncreate_cubical_box creates a cubical complex covering a box in three-dimensional Euclidean space. The box is given by the subset 0nx times 0ny times 0nz of space, where the nonnegative integers nx, ny, and nz have to be passed as arguments to the function. The optional parameters are the same as in the planar version.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"To illustrate the first of these functions, consider the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"cubes = [\"00.11\", \"01.01\", \"02.10\", \"11.10\", \"11.01\", \"22.00\", \"20.11\", \"31.01\"]\ncc = create_cubical_complex(cubes)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"These create the cubical complex cc, in the form of a  Lefschetz complex. It can be visualized using the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"coords = get_cubical_coords(cc)\nfname  = \"lefschetzex4.pdf\"\nplot_planar_cubical(cc,coords,fname,hfac=2.2,vfac=1.1,cubefac=60)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"(Image: First sample cubical complex)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Similarly, the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"cc2, coords2 = create_cubical_rectangle(5,2)\nfname2 = \"lefschetzex5.pdf\"\nplot_planar_cubical(cc2,coords2,fname2,hfac=1.7,vfac=1.2,cubefac=75)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"define and illustrate a second cubical complex.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"(Image: Second sample cubical complex)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Finally, it is also possible to perturb the vertices in a cubical rectangle to obtain a Lefschetz complex consisting of quadrilaterals in the plane. This can be accomplied as follows:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"cc3, coords3 = create_cubical_rectangle(5,2,randomize=0.2)\nfname3 = \"lefschetzex6.pdf\"\nplot_planar_cubical(cc3,coords3,fname3,hfac=1.7,vfac=1.2,cubefac=75)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The resulting Lefschetz complex is visualized in the last figure of this section.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"(Image: A randomly perturbed cubical complex)","category":"page"},{"location":"man/lefschetz/#Lefschetz-Complex-Operations","page":"Lefschetz Complexes","title":"Lefschetz Complex Operations","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Once a Lefschetz complex has been created, there are a number of manipulations and queries that one has to be able to perform on the complex. At the moment, ConleyDynamics.jl supplies a number of functions for this. The following four functions  provide basic information:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"lefschetz_information provides basic information about the Lefschetz complex, including its Euler characteristic and homology, as well as cell counts by dimension and sparsity percentage of the boundary matrix.\nlefschetz_field returns the field F over which the Lefschetz complex is defined as a String.\nlefschetz_is_closed determines whether a given Lefschetz complex cell subset is closed or not.\nlefschetz_is_locally_closed checks whether a given Lefschetz complex cell subset is locally closed or not.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The next set of functions can be used to extract certain topological features from a Lefschetz complex:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"lefschetz_boundary computes the support of the boundary partialsigma of a Lefschetz complex cell sigma. In other words, it returns the vector of all facets of sigma. The cell can either be specified via its index or its label, and the return format corresponds to the input format.\nlefschetz_coboundary returns all cells which lie in the coboundary of the specified cell sigma, i.e., it returns all cells which have sigma as a facet.\nlefschetz_closure determines the closure of a  given cell subset, i.e., the union of all faces of cells in the cell subset.\nlefschetz_interior determines the interior of a  given cell subset. For this, the Lefschetz complex is interpreted as a finite topological space, where a set A is open if and only if for every cell sigma in A all of its cofaces are also contained in the set A.\nlefschetz_openhull computes the open hull of a cell subset, i.e., the smallest open set which contains the given cell subset. For this, we again interpret a Lefschetz complex as a finite topological space as above.\nlefschetz_topboundary computes the topological boundary of a cell subset, i.e., the set difference of the closure and the interior of the set. Note that this usually differs from the (algebraic) boundary mentioned above.\nlefschetz_lchull finds the locally closed hull of a Lefschetz complex subset. This is the smallest locally closed set which contains the given cell subset. One can show that  it is the intersection of the closure and the open hull of the cell subset.\nlefschetz_clomo_pair determines the closure-mouth-pair associated with a Lefschetz complex subset.\nlefschetz_skeleton computes the k-dimensional skeleton of a Lefschetz complex or of a given Lefschetz complex subset. While in the first case the k-skeleton of the full Lefschetz complex is returned, in the second case it returns the k-skeleton of the closure of the given subset.\nmanifold_boundary returns a list of cells which form the \"manifold boundary\" of the given Lefschetz complex. More  precisely, if the complex has dimension d, then it determines all cells of dimension d-1 which have at most one cell in their coboundary, as well as all cells of dimensions less than d-1 which have no cell in their coboundary, and finally returns the closure of the resulting cell subset.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The following functions create Lefschetz subcomplexes from a Lefschetz complex:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"lefschetz_subcomplex determines a Lefschetz subcomplex from a given Lefschetz complex. The subcomplex has to be locally closed, and it is given by a collection of cells.\nlefschetz_closed_subcomplex extracts a closed Lefschetz subcomplex from the given Lefschetz complex. The subcomplex is the closure of the specified collection of cells.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"In addition, it is possible to create a new Lefschetz complex from an existing one using the following functions:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"permute_lefschetz_complex determines a new Lefschetz complex which is obtained from the original one by a permutation of the cells. Note that the permutation has to respect the ordering of the cells by dimension, otherwise an error is raised. In other words, the permutation has to decompose into permutations within each dimension. This is automatically done if no permutation is explicitly specified and the function creates a random one.\nlefschetz_reduction uses elementary reductions to transform a Lefschetz complex into a smaller one while preserving homology. In fact, the new complex is chain homotopic to the  original one. For this, one has to specify a sequence of reduction pairs, which are disjoint pairs of cells whose dimensions differ by one, and such that one cell is a face of the other, once the earlier reductions have been performed. This function is based on [KMS98]. It returns a new Lefschetz complex which no longer contains the cells contained in the reduction  pairs.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"It was shown in [EM23] that suitable reduction pairs for lefschetz_reduction can be found easily via the concept of filters. A filter on a Lefschetz complex is a function varphi  X to mathbb R which has the property that varphi(x) le varphi(y) if x is a face of y. Every such filter induces shallow pairs, which in the case of an injective filter generate a gradient Forman vector field on the Lefschetz complex. It turns out that these shallow pairs can be used to reduce the complex. In ConleyDynamics.jl there are three functions for working with filters:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"create_random_filter creates a random injective filter on a Lefschetz complex. The filter is created by assigning integers to cell groups, increasing with dimension. Within each dimension the assignment is random, but all filter values of cells of dimension k are less than all filter values of cells with dimension k+1. The function returns the filter as Vector{Int}, with indices corresponding to the cell indices in the Lefschetz complex.\nfilter_shallow_pairs finds all shallow pairs for the filter varphi. These are face-coface pairs (xy) whose dimensions differ by one, and such that y has the smallest filter value on the coboundary of x, and x has the largest filter value on the boundary of y. For injective filters, these pairs give rise to a Forman vector field on the underlying Lefschetz complex. For noninjective filters this is not true in general.\nfilter_induced_mvf returns the smallest multivector field which has the property that every shallow pair is contained in a multivector. For injective filters this is a Forman vector field, but in the noninjective case it can be a general multivector field.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"There are also two helper functions which can sometimes  be useful:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"lefschetz_gfp_conversion changes the base field of the given Lefschetz complex from the rationals mathbbQ to a finite field GF(p). Note that it is not possible to perform the reverse conversion.\nlefschetz_filtration computes a filtration on a Lefschetz subset. Based on integer filtration values assigned to some cells of the given Lefschetz complex, it determines the smallest closed subcomplex lcsub which contains all cells with nonzero filtration values, as well as filtration values fvalsub on this subcomplex, which give rise to a filtration of closed subcomplexes, and which can be used to compute persistent homology.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"In addition, ConleyDynamics.jl provides the following helper functions for the fundamental objects of cells and cell subsets, which can be represented either by integer cell indices or by cell labels:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"convert_cells converts a vector of cells from integer to label format, or vice versa.\nconvert_cellsubsets converts a vector of cell subsets from integer to label format, and vice versa.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Finally, there are a couple of ccordinate helper functions which allow for the transformation of vertex coordinates in a Lefschetz complex:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"convert_planar_coordinates transforms a given collection of planar coordinates in such a way that the extreme coordinates fit precisely in a given rectangle in the plane.\nconvert_spatial_coordinates transforms a given collection of spatial coordinates in such a way that the extreme coordinates fit precisely in a given rectangular box in space.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"For more details on the usage of any of these functions, please see their documentation in the API section of the manual. ","category":"page"},{"location":"man/lefschetz/#reflefschetz","page":"Lefschetz Complexes","title":"References","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"P. Alexandrov. Diskrete Räume. Mathematiceskii Sbornik (N.S.) 2, 501–518 (1937).\n\n\n\nP. Dłotko, T. Kaczynski, M. Mrozek and T. Wanner. Coreduction homology algorithm for regular CW-complexes. Discrete & Computational Geometry 46, 361–388 (2011).\n\n\n\nH. Edelsbrunner and M. Mrozek. The depth poset of a filtered Lefschetz complex (2023), arXiv:2311.14364v2 [math.AT].\n\n\n\nT. Kaczynski, K. Mischaikow and M. Mrozek. Computational Homology. Vol. 157 of Applied Mathematical Sciences (Springer-Verlag, New York, 2004).\n\n\n\nT. Kaczynski, M. Mrozek and M. Slusarek. Homology computation by reduction of chain complexes. Computers & Mathematics with Applications 35, 59–70 (1998).\n\n\n\nS. Lefschetz. Algebraic Topology. Vol. 27 of American Mathematical Society Colloquium Publications (American Mathematical Society, New York, 1942).\n\n\n\nM. Lipinski, J. Kubica, M. Mrozek and T. Wanner. Conley-Morse-Forman theory for generalized combinatorial             multivector fields on finite topological spaces. Journal of Applied and Computational Topology 7, 139–184 (2023).\n\n\n\nW. S. Massey. A Basic Course in Algebraic Topology. Vol. 127 of Graduate Texts in Mathematics (Springer-Verlag, New York, 1991).\n\n\n\nM. Mrozek and B. Batko. Coreduction homology algorithm. Discrete & Computational Geometry 41, 96–118 (2009).\n\n\n\nM. Mrozek and T. Wanner. Connection Matrices in Combinatorial Topological Dynamics. SpringerBriefs in Mathematics (Springer-Verlag, Cham, 2025).\n\n\n\nJ. R. Munkres. Elements of Algebraic Topology. SpringerBriefs in Mathematics (Addison-Wesley, Menlo Park, 1984).\n\n\n\n","category":"page"},{"location":"man/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"In order to illustrate the basic functionality of ConleyDynamics.jl,  this section collects a number of examples. Many of these are taken  from the paper [BKMW20] and the book [MW25], and they consider both Forman vector fields and general multivector fields on a variety of Lefschetz complexes. Each example has its own associated function, so that users can quickly create examples on their own by taking the respective source files as templates.","category":"page"},{"location":"man/examples/#A-One-Dimensional-Forman-Field","page":"Examples","title":"A One-Dimensional Forman Field","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Our first example is taken from [BKMW20, Figure 1], and it is a Forman vector field on a one-dimensional simplicial complex as shown in the figure.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: A one-dimensional simplicial complex flow)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The simplicial complex and Forman vector field can be created using the function example_forman1d:","category":"page"},{"location":"man/examples/#ConleyDynamics.example_forman1d-Tuple{}-man-examples","page":"Examples","title":"ConleyDynamics.example_forman1d","text":"lc, mvf, coords = example_forman1d()\n\nCreate the simplicial complex and multivector field for the example from Figure 1 in the FoCM 2020 paper by Batko, Kaczynski, Mrozek, and Wanner.\n\nThe function returns the Lefschetz complex lc and the  multivector field mvf. If desired for plotting, the third return value coords gives a vector of coordinates for the vertices. The Lefschetz complex is defined over the finite field GF(2).\n\nExamples\n\njulia> lc, mvf = example_forman1d();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0   0   1]\n[0   0   0   0   0]\n[0   0   0   0   1]\n[0   0   0   0   0]\n[0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"A\", \"AD\", \"F\", \"BF\", \"DE\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The commands from the docstring show that the connection matrix has five rows and columns. The last three of these correspond to the critical cells mathrmF, mathrmBF, and mathrmDE, while the first two correspond to the two generators of the homological Conley index of the periodic orbit, given by mathrmA and mathrmAD.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: Morse decomposition of the one-dimensional example)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The full Morse decomposition of this combinatorial dynamical system is depicted in the second figure, and all four Morse set are indicated in the simplicial complex by different colors. They are also listed, together with their Conley indices, in the following Julia output:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> cm.morse\n4-element Vector{Vector{String}}:\n [\"A\", \"C\", \"D\", \"AC\", \"AD\", \"CD\"]\n [\"F\"]\n [\"BF\"]\n [\"DE\"]\n\njulia> cm.conley\n4-element Vector{Vector{Int64}}:\n [1, 1]\n [1, 0]\n [0, 1]\n [0, 1]","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Notice that only two heteroclinic orbits are reflected in the connection matrix. These are the connections between the unstable cell mathrmDE and both the equilibrium mathrmF and the periodic orbit. In contrast, the two heteroclinics between the index one cell mathrmBF and mathrmF cancel algebraically.","category":"page"},{"location":"man/examples/#A-Planar-Forman-Vector-Field","page":"Examples","title":"A Planar Forman Vector Field","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Our second example was originally discussed in the context of  [BKMW20, Figure 3], and it consists of a Forman  vector field on a topological disk, as shown in the associated figure.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: A planar simplicial complex flow)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The disk is represented as a simplicial complex with 10 vertices, 19 edges, and 10 triangles. The Forman vector field has 7 critical cells, and 16 arrows. Both the simplicial complex and the Forman vector field can be defined using the function example_forman2d:","category":"page"},{"location":"man/examples/#ConleyDynamics.example_forman2d-Tuple{}-man-examples","page":"Examples","title":"ConleyDynamics.example_forman2d","text":"lc, mvf, coords = example_forman2d()\n\nCreate the simplicial complex and multivector field for the example from Figure 3 in the FoCM 2020 paper by Batko, Kaczynski, Mrozek, and Wanner.\n\nThe function returns the Lefschetz complex lc over the finite field GF(2) and the multivector field mvf. If desired for plotting, the third return value coords gives a vector of coordinates for the vertices.\n\nExamples\n\njulia> lc, mvf = example_forman2d();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0   0   1   0   1   0   0]\n[0   0   0   0   0   1   0   0   0]\n[0   0   0   0   1   1   1   0   0]\n[0   0   0   0   0   0   0   0   1]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"D\", \"E\", \"F\", \"GJ\", \"BF\", \"EF\", \"HI\", \"ADE\", \"FGJ\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: Morse decomposition of the planar flow)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The Morse decomposition of this example is shown in the second figure. Its eight Morse sets and associated Conley indices are given by","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> cm.morse\n8-element Vector{Vector{String}}:\n [\"D\"]\n [\"E\"]\n [\"F\", \"G\", \"I\", \"J\", \"FG\", \"FI\", \"GJ\", \"IJ\"]\n [\"BF\"]\n [\"EF\"]\n [\"HI\"]\n [\"ADE\"]\n [\"FGJ\"]\n\njulia> cm.conley\n8-element Vector{Vector{Int64}}:\n [1, 0, 0]\n [1, 0, 0]\n [1, 1, 0]\n [0, 1, 0]\n [0, 1, 0]\n [0, 1, 0]\n [0, 0, 1]\n [0, 0, 1]","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We would like to point out that the collection of Morse sets does not in general encompass all possible isolated invariant sets for the combinatorial dynamical system. Consider for  example the set S shown in light blue in the next figure.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: A nontrivial isolated invariant set)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Its mouth is depicted in dark blue, and it is clearly closed. In addition, the set S decomposes into arrows and critical cells, and one can show that it is invariant. Thus, it is in  fact an isolated invariant set for this Forman vector field. Note also that this cell does not correspond to an interval in the Conley-Morse graph either, and this is indicated via gray shading in the above image of the graph. The set S, together with its closure and its mouth, can be generated using the  following commands:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"S = [\"ADE\",\"DEH\",\"EFI\",\"EHI\",\n     \"DE\",\"EF\",\"EH\",\"EI\",\"FG\",\"FI\",\"GJ\",\"HI\",\"IJ\",\n     \"F\",\"G\",\"I\",\"J\"]\nclS, moS = lefschetz_clomo_pair(lc,S)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Then the Conley index of S is given by","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> conley_index(lc,S)\n3-element Vector{Int64}:\n 0\n 1\n 0\n\njulia> relative_homology(lc,clS,moS)\n3-element Vector{Int64}:\n 0\n 1\n 0","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Notice that this is the same as the relative homology of the pair (mathrmcl S mathrmmo S), as expected.","category":"page"},{"location":"man/examples/#The-Multivector-Field-from-the-Logo","page":"Examples","title":"The Multivector Field from the Logo","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"This example is taken from [MW25, Figure 2.1], and it is visualized in the accompanying figure.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: The logo multivector field)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Clearly, this is the multivector field from the ConleyDynamics.jl logo. Since it was already discussed in detail in the Tutorial, we only show how the underlying simplicial complex and the multivector field can be created quickly using the function example_julia_logo:","category":"page"},{"location":"man/examples/#ConleyDynamics.example_julia_logo-Tuple{}-man-examples","page":"Examples","title":"ConleyDynamics.example_julia_logo","text":"lc, mvf = example_julia_logo()\n\nCreate the simplicial complex and multivector field for the example from Figure 1 in the connection matrix paper by Mrozek & Wanner.\n\nThe function returns the Lefschetz complex lc over GF(2) and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_julia_logo();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0]\n[0   0   1]\n[0   0   0]\n\njulia> print(cm.labels)\n[\"D\", \"AC\", \"ABC\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The Morse sets and associated Conley indices can be accessed using the commands:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> cm.morse\n3-element Vector{Vector{String}}:\n [\"D\"]\n [\"A\", \"B\", \"C\", \"AB\", \"AC\", \"BC\", \"BD\", \"CD\", \"BCD\"]\n [\"ABC\"]\n\njulia> cm.conley\n3-element Vector{Vector{Int64}}:\n [1, 0, 0]\n [0, 1, 0]\n [0, 0, 1]","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Notice that in this example, every simplex of the underlying simplicial complex is contained in one of the Morse sets.","category":"page"},{"location":"man/examples/#Critical-Flow-on-a-Simplex","page":"Examples","title":"Critical Flow on a Simplex","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The next example considers the arguably simplest situation of a Forman vector field on a simplicial complex. The simplicial complex X is given by a single simplex of dimension n, together with all its faces, while the Forman vector field on X contains only singletons. In other words, every simplex in the complex is a critical cell. Thus, this combinatorial dynamical system has one equilibrium of index n, and n+1 stable equilibria. In addition, there are 2^n+1 - n - 3 additional stationary states whose indices lie strictly between 0 and n, as well as a  wealth of algebraically induced heteroclinic orbits. All of these can be found by using the connection matrix for the problem, as outlined in the following description for the function example_critical_simplex.","category":"page"},{"location":"man/examples/#ConleyDynamics.example_critical_simplex-Tuple{Int64}-man-examples","page":"Examples","title":"ConleyDynamics.example_critical_simplex","text":"lc, mvf = example_critical_simplex(dim)\n\nCreate a simplicial complex of dimension dim as well as a multivector field on it in which every cell is critical.\n\nThe function returns the Lefschetz complex lc over GF(2) and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_critical_simplex(2);\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0   1   1   0   0]\n[0   0   0   1   0   1   0]\n[0   0   0   0   1   1   0]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"A\", \"B\", \"C\", \"AB\", \"AC\", \"BC\", \"ABC\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#Flow-on-a-Cylinder-and-a-Moebius-Strip","page":"Examples","title":"Flow on a Cylinder and a Moebius Strip","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The next example considers again Forman vector fields, but this time on a cylinder and on a Moebius strip. The underlying simplicial complexes are given by a horizontal strip of eight triangles, whose left and right vertical edges are identified. For the first complex lc1 these edges are identified without twist, while for the complex lc2 they are twisted. See also the labels in the figure.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: Combinatorial flow on cylinder and Moebius strip)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Both complexes consist of eight vertices, sixteen edges, and eight triangles. The two complexes and Forman vector fields can be generated using the function example_critical_simplex, whose usage can be described as follows.","category":"page"},{"location":"man/examples/#ConleyDynamics.example_moebius-man-examples","page":"Examples","title":"ConleyDynamics.example_moebius","text":"lc1, mvf1, lc2, mvf2 = example_moebius(p)\n\nCreate two simplicial complexes for a cylinder and Moebius strip, respectively, together with associated multivector fields on them.\n\nThe function returns the Lefschetz complexes lc1 and lc2, as well as the multivector fields mvf1 and mvf2. Both complexes are over a field with characteristic p. Positive  prime characteristic uses the finite field GF(p), while zero characteristic gives the rationals.\n\nThe multivector field is the same, and it has one critical  cell each in dimension 1 and 2 in the interior of the strip. The boundary consists of two periodic orbits for lc1 and mvf1, and of one periodic orbit in the Moebius case lc2 and mvf2. The latter case leads to different connection matrices for the fields GF(2) and GF(7), for example.\n\nExamples\n\njulia> lc1, mvf1, lc2, mvf2 = example_moebius(0);\n\njulia> lc2p2 = lefschetz_gfp_conversion(lc2,2);\n\njulia> lc2p7 = lefschetz_gfp_conversion(lc2,7);\n\njulia> cmp2 = connection_matrix(lc2p2, mvf2);\n\njulia> cmp7 = connection_matrix(lc2p7, mvf2);\n\njulia> sparse_show(cmp2.matrix)\n[0   0   0   0]\n[0   0   0   1]\n[0   0   0   0]\n[0   0   0   0]\n\njulia> sparse_show(cmp7.matrix)\n[0   0   0   0]\n[0   0   0   1]\n[0   0   0   2]\n[0   0   0   0]\n\n\n\n\n\n","category":"function"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Note that for the combinatorial flow on the Moebius strip lc2 the choice of field characteristic p leads to potentially different  connection matrices. While for characteristic p=2 the connection matrix has only one nontrivial entry, it has two for p=7.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We only briefly include some sample computations for the latter case. One can create the complexes, Forman vector fields, and associated connection matrices for p=7 using the following commands:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"lc1, mvf1, lc2, mvf2 = example_moebius(7)\ncm1 = connection_matrix(lc1,mvf1)\ncm2 = connection_matrix(lc2,mvf2)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"For the first example, the combinatorial flow on the cylinder has four Morse sets. Two critical equilibria of indices 1 and 2, as well as two periodic orbits. This can be shown as follows:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> cm1.morse\n4-element Vector{Vector{String}}:\n [\"A\", \"C\", \"E\", \"G\", \"AC\", \"AG\", \"CE\", \"EG\"]\n [\"B\", \"D\", \"F\", \"H\", \"BD\", \"BH\", \"DF\", \"FH\"]\n [\"AB\"]\n [\"EFG\"]\n\njulia> cm1.conley\n4-element Vector{Vector{Int64}}:\n [1, 1, 0]\n [1, 1, 0]\n [0, 1, 0]\n [0, 0, 1]\n\njulia> sparse_show(cm1.matrix)\n[0   0   0   0   6   0]\n[0   0   0   0   0   1]\n[0   0   0   0   1   0]\n[0   0   0   0   0   6]\n[0   0   0   0   0   0]\n[0   0   0   0   0   0]\n\njulia> print(cm1.labels)\n[\"A\", \"AG\", \"B\", \"BH\", \"AB\", \"EFG\"]","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"In fact, the connection matrix implies the existence of connecting orbits from both the index 2 and the index 1 equilibrium to the two periodic orbits. The connections between the stationary states cannot be detected  algebraically.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"For the second example, the combinatorial flow on the Moebius strip, one only obtains three Morse sets. This time, there is only one periodic orbit which loops around both the top and bottom edges in the figure. This is confirmed by the commands","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> cm2.morse\n3-element Vector{Vector{String}}:\n [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"AC\", \"AH\", \"BD\", \"BG\", \"CE\", \"DF\", \"EG\", \"FH\"]\n [\"AB\"]\n [\"EFG\"]\n\njulia> cm2.conley\n3-element Vector{Vector{Int64}}:\n [1, 1, 0]\n [0, 1, 0]\n [0, 0, 1]\n\njulia> sparse_show(cm2.matrix)\n[0   0   0   0]\n[0   0   0   1]\n[0   0   0   2]\n[0   0   0   0]\n\njulia> print(cm2.labels)\n[\"A\", \"BG\", \"AB\", \"EFG\"]","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"In this case, the connection matrix is able to identify the connecting orbits between the index 2 stationary state and both the periodic orbit and the index 1 equilibrium. The  latter one is not recognized over the field GF(2).","category":"page"},{"location":"man/examples/#Nonunique-Connection-Matrices","page":"Examples","title":"Nonunique Connection Matrices","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Our next example is concerned with another Forman vector field, but this time on a larger simplicial complex, as shown in the figure.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: An example with nonunique connection matrices)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The simplicial complex is topologically a disk, and it consists of 9 vertices, 18 edges, and 10 triangles. The Forman vector field has 1 critical vertex, 3 critical edges, and 3 critical triangles, as well as 15 Forman arrows. The following example shows that for this combinatorial dynamical system, there are two fundamentally different connection matrices.","category":"page"},{"location":"man/examples/#ConleyDynamics.example_nonunique-Tuple{}-man-examples","page":"Examples","title":"ConleyDynamics.example_nonunique","text":"lc1, lc2, mvf, coords1, coords2 = example_nonunique()\n\nCreate two representations of a simplicial complex and one multivector field which illustrates nonunique connection matrices.\n\nThe two complexes lc1 and lc2 represent the same simplicial complex over GF(2), but differ in the ordering of the labels.\n\nThe function returns the Lefschetz complexes lc1 and lc2, as well as the multivector field mvf. If desired for plotting, the fourth and fifth return values coords1 and coords2 give vectors of coordinates for the vertices of the two complexes.\n\nExamples\n\njulia> lc1, lc2, mvf = example_nonunique();\n\njulia> cm1 = connection_matrix(lc1, mvf);\n\njulia> cm2 = connection_matrix(lc2, mvf);\n\njulia> sparse_show(cm1.matrix)\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   0   0   0   0   1   1]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm1.labels)\n[\"2\", \"7\", \"79\", \"29\", \"45\", \"67\", \"168\", \"349\", \"789\"]\njulia> sparse_show(cm2.matrix)\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   0   0   0   1   0   1]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm2.labels)\n[\"2\", \"8\", \"78\", \"29\", \"45\", \"67\", \"168\", \"349\", \"789\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"As mentioned in the docstring for the function example_nonunique, the two Lefschetz complexes lc1 and lc2 both represent the above simplicial complex. However, they differ in the ordering of the vertex labels. This can be seen from the commands","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> print(lc1.labels[1:9])\n[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\njulia> print(lc2.labels[1:9])\n[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"8\", \"9\", \"7\"]","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"In other words, lc1 and lc2 are different representations of the same complex. Nevertheless, computing the connection matrices as in the example gives two distinct connection matrices. This is purely a consequence of the different ordering of the rows and  columns in the boundary matrix.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"To shed further light on this issue, notice that the triangle at the center of the complex forms an attracting periodic orbit,  whose Conley index has Betti numbers 1 in dimensions 0 and 1. One can break this periodic orbit by removing one of its three arrows, and replacing it with two critical cells of dimensions 0 and 1. The next image shows two different ways of doing this.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: Forcing different connection matrices)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"In the image on the left, the vector [\"7\", \"79\"] is removed, while the one on the right breaks up [\"8\", \"78\"]. The corresponding modified Forman vector fields, and their connection matrices, can be created as follows:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"mvf1 = deepcopy(mvf);\nmvf2 = deepcopy(mvf);\ndeleteat!(mvf1,6);\ndeleteat!(mvf2,8);\ncm1mod = connection_matrix(lc1, mvf1);\ncm2mod = connection_matrix(lc2, mvf2);","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Both of the new Forman vector fields are gradient vector fields, and in view of a result in [MW25], their connection matrices are therefore uniquely determined. The connection matrix for the vector field mvf1 is of the form","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> sparse_show(cm1mod.matrix)\n[0   0   1   0   1   0   0   0   0]\n[0   0   1   0   1   0   0   0   0]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   1   1]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm1mod.labels)\n[\"2\", \"7\", \"29\", \"45\", \"67\", \"79\", \"168\", \"349\", \"789\"]","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Notice that this matrix shows that there is a connection from the triangle 349 to the edge 79, but there are no connections from the triangle 168 to the critical edge on the center triangle. In fact, up to reordering the columns and rows, this connection  matrix is the same as cm1 in the example.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Similarly, the connection matrix for the second modified Forman vector field mvf2 is uniquely determined, and it is given by","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> sparse_show(cm2mod.matrix)\n[0   0   1   0   1   0   0   0   0]\n[0   0   1   0   1   0   0   0   0]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   1   0   1]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm2mod.labels)\n[\"2\", \"8\", \"29\", \"45\", \"67\", \"78\", \"168\", \"349\", \"789\"]","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Now there is a connection from the triangle 168 to the edge 78, but there are no connections from the triangle 349 to the critical edge on the center triangle. This time, up to a permutation of the columns and the rows, this connection matrix is the same as cm2 in the example.","category":"page"},{"location":"man/examples/#Forcing-Three-Connection-Matrices","page":"Examples","title":"Forcing Three Connection Matrices","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The next example is taken from [MW25, Figure 2.2], and it revolves around the combinatorial vector field on a simplicial  complex shown in the top left part of the figure.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: An example with three connection matrices)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"This combinatorial vector field is again of Forman type. It has  a periodic orbit, which is shown in yellow in the top right part of the figure. In addition to three index 1 equilibria, there are two of index 2. The top right part shows that from these two index 2 cells there are a combined total of five connecting orbits to the index 1 cells and to the periodic orbit. Its Morse decomposition is shown in the lower part of the figure. While the Morse sets are indicated by different colors, the Conley-Morse graph is shown on the lower right.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"As the following docstring for example_three_cm demonstrates, the connection matrix, which this time is computed over the rationals mathbbQ, only identifies three of the five connecting orbits between index 2 invariant sets and index 1 sets.","category":"page"},{"location":"man/examples/#ConleyDynamics.example_three_cm-Tuple{}-man-examples","page":"Examples","title":"ConleyDynamics.example_three_cm","text":"lc, mvf, coords = example_three_cm(mvftype)\n\nCreate the simplicial complex and multivector field for the example from Figure 2 in the connection matrix paper by Mrozek & Wanner.\n\nDepending on the value of mvftype, return the periodic orbit (0=default) or one of the three gradient (1,2,3) examples.\n\nThe function returns the Lefschetz complex lc over the rational field and the multivector field mvf. If desired for plotting, the third return value coords gives a vector of coordinates for the vertices.\n\nExamples\n\njulia> lc, mvf = example_three_cm(0);\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> print(cm.labels)\n[\"A\", \"C\", \"CE\", \"AC\", \"BD\", \"DF\", \"ABC\", \"EFG\"]\n\njulia> full_from_sparse(cm.matrix)\n8×8 Matrix{Rational{Int64}}:\n 0  0  0  -1  -1  0   0  0\n 0  0  0   1   1  0   0  0\n 0  0  0   0   0  0   0  0\n 0  0  0   0   0  0  -1  0\n 0  0  0   0   0  0   1  0\n 0  0  0   0   0  0   0  1\n 0  0  0   0   0  0   0  0\n 0  0  0   0   0  0   0  0\n\n\n\n\n\n","category":"method"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"It turns out that this combinatorial dynamical system has multiple possible connection matrices as well. In fact, it has three. In order to find them we use the same approach as in the last example, and  break the periodic orbit by turning one of its arrows into two critical cells. Since there are three arrows in the periodic  orbit, this can be accomplished in three different ways. They are indicated in the next figure.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: Three different ways to break up the periodic orbit)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The resulting Forman vector fields are all of gradient type, and therefore have a unique connection matrix. These three vector fields can be obtained via the function example_three_cm by specifying the integer argument as 1, 2, or 3. For the first vector field one obtains the following connection matrix:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> lc1, mvf1 = example_three_cm(1);\n\njulia> cm1 = connection_matrix(lc1, mvf1);\n\njulia> print(cm1.labels)\n[\"A\", \"C\", \"AC\", \"BD\", \"CD\", \"DF\", \"ABC\", \"EFG\"]\n\njulia> full_from_sparse(cm1.matrix)\n8×8 Matrix{Rational{Int64}}:\n 0  0  -1  -1  0  0   0  0\n 0  0   1   1  0  0   0  0\n 0  0   0   0  0  0  -1  0\n 0  0   0   0  0  0   1  0\n 0  0   0   0  0  0  -1  0\n 0  0   0   0  0  0   0  1\n 0  0   0   0  0  0   0  0\n 0  0   0   0  0  0   0  0","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"In contrast, the second vector field leads to:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> lc2, mvf2 = example_three_cm(2);\n\njulia> cm2 = connection_matrix(lc2, mvf2);\n\njulia> print(cm2.labels)\n[\"A\", \"D\", \"AC\", \"BD\", \"DE\", \"DF\", \"ABC\", \"EFG\"]\n\njulia> full_from_sparse(cm2.matrix)\n8×8 Matrix{Rational{Int64}}:\n 0  0  -1  -1  0  0   0   0\n 0  0   1   1  0  0   0   0\n 0  0   0   0  0  0  -1   0\n 0  0   0   0  0  0   1   0\n 0  0   0   0  0  0   0  -1\n 0  0   0   0  0  0   0   1\n 0  0   0   0  0  0   0   0\n 0  0   0   0  0  0   0   0","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Finally, the third gradient vector field gives:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> lc3, mvf3 = example_three_cm(3);\n\njulia> cm3 = connection_matrix(lc3, mvf3);\n\njulia> print(cm3.labels)\n[\"A\", \"E\", \"AC\", \"BD\", \"CE\", \"DF\", \"ABC\", \"EFG\"]\n\njulia> full_from_sparse(cm3.matrix)\n8×8 Matrix{Rational{Int64}}:\n 0  0  -1  -1  0  0   0  0\n 0  0   1   1  0  0   0  0\n 0  0   0   0  0  0  -1  0\n 0  0   0   0  0  0   1  0\n 0  0   0   0  0  0   0  0\n 0  0   0   0  0  0   0  1\n 0  0   0   0  0  0   0  0\n 0  0   0   0  0  0   0  0","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"This is finally the connection matrix that was originally returned for the Forman vector field with periodic orbit. One could have obtained the remaining two also through cell permutations.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Notice that these three matrices combined do identify all of the above connections. It was shown in [MW25] that these matrices are different connection matrices for the original Forman vector field with periodic orbit, as long as the newly introduced index 1 and 0 equilibria are identified with the Conley index of the periodic solution. For the sake of completeness, the next figure shows the Morse decompositions for all three combinatorial gradient flows. In the Conley-Morse graphs, blue arrows correspond to the heteroclinic orbits that are identified by the associated connection matrix.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: Morse decompositions for the three gradient vector fields)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"In the Conley-Morse graphs, we used the same color yellow for the two Morse sets that are generated by breaking the periodic orbit through the introduction of two critical cells. It can be seen from the images that while the actual Morse set structure stays fixed, the poset order in the Conley-Morse graphs changes from case to case.","category":"page"},{"location":"man/examples/#A-Lefschetz-Multiflow-Example","page":"Examples","title":"A Lefschetz Multiflow Example","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The next example is taken from [MW25, Figure 2.3], and it is a combinatorial multivector field on a true Lefschetz  complex, as shown in the left panel of the associated figure.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: A multiflow example with trivial connection matrix)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The example is a combinatorial representation of the multiflow shown on the right, which features nonunique forward dynamics at the point labeled 5. Note that the underlying Lefschetz complex is defined as the subset of the depicted simplicial complex, where the vertices mathrmA, mathrmB, mathrmD, mathrmE, and mathrmF have been removed. This Lefschetz complex lc and  the depicted multivector field mvf can be created using the function example_multiflow:","category":"page"},{"location":"man/examples/#ConleyDynamics.example_multiflow-Tuple{}-man-examples","page":"Examples","title":"ConleyDynamics.example_multiflow","text":"lc, mvf = example_multiflow()\n\nCreate the Lefschetz complex and multivector field for the example from Figure 3 in the connection matrix paper by Mrozek & Wanner.\n\nThe function returns the Lefschetz complex lc over GF(2) and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_multiflow();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0   0]\n[0   0   0   0]\n[0   0   0   0]\n[0   0   0   0]\n\njulia> print(cm.labels)\n[\"BD\", \"DF\", \"AC\", \"CE\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"As the docstring shows, this example has a trivial connection matrix. In other words, there are no connecting orbits in this combinatorial dynamical system that are forced by topology. In fact, one can easily see that due to the multivalued nature of the dynamical system, one cannot expect any particular  heteroclinic to be present.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The Morse decomposition of the system, and the associated  Conley indices encompass precisely the four critical edges:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> cm.morse\n4-element Vector{Vector{String}}:\n [\"BD\"]\n [\"DF\"]\n [\"AC\"]\n [\"CE\"]\n\njulia> cm.conley\n4-element Vector{Vector{Int64}}:\n [0, 1, 0]\n [0, 1, 0]\n [0, 1, 0]\n [0, 1, 0]","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Combined with the fact that the connection matrix is trivial, this means that the homology of the underlying Lefschetz complex lc is the sum of the Conley indices of the Morse sets. This can be confirmed using the function homology:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> homology(lc)\n3-element Vector{Int64}:\n 0\n 4\n 0","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"As we mentioned earlier, this is the same as the relative homology of the full simplicial complex with respect to the union of the five removed vertices.","category":"page"},{"location":"man/examples/#Small-Complex-with-Periodicity","page":"Examples","title":"Small Complex with Periodicity","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"In [MW25, Figure 2.4] we introduced a small Lefschetz complex with periodic orbit and nonunique connection matrices. This complex consists of one 2-cell, three 1-cells, and two 0-cells, and it is shown in the leftmost panel of the figure.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: A small Lefschetz complex with periodic orbit)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"On the complex, consider the multivector field depicted in the middle of the figure, which consists of the critical  cells alpha and b, as well as the two regular multivectors  A a  and  B c . For this small example, one can easily determine the Morse decomposition, and it is shown in the rightmost panel. The example can be generated in ConleyDynamics.jl using the function example_small_periodicity:","category":"page"},{"location":"man/examples/#ConleyDynamics.example_small_periodicity-Tuple{}-man-examples","page":"Examples","title":"ConleyDynamics.example_small_periodicity","text":"lc1, lc2, mvf = example_small_periodicity()\n\nCreate two representations of the Lefschetz complex and the multivector field for the example from Figure 4 in the connection matrix paper by Mrozek & Wanner.\n\nThe complexes lc1 and lc2 are just two representations of the same complex, but they lead to different connection matrices. Both Lefschetz complexes are defined over the finite field GF(2).\n\nThe function returns the Lefschetz complexes lc1 and lc2, as well as the multivector field mvf.\n\nExamples\n\njulia> lc1, lc2, mvf = example_small_periodicity();\n\njulia> cm1 = connection_matrix(lc1, mvf);\n\njulia> cm2 = connection_matrix(lc2, mvf);\n\njulia> full_from_sparse(cm1.matrix)\n4×4 Matrix{Int64}:\n 0  0  0  0\n 0  0  0  1\n 0  0  0  1\n 0  0  0  0\n\njulia> print(cm1.labels)\n[\"A\", \"a\", \"b\", \"alpha\"]\n\njulia> full_from_sparse(cm2.matrix)\n4×4 Matrix{Int64}:\n 0  0  0  0\n 0  0  0  0\n 0  0  0  1\n 0  0  0  0\n\njulia> print(cm2.labels)\n[\"A\", \"c\", \"b\", \"alpha\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The function provides two different representations of the same Lefschetz complex, which only differ in the ordering of the 1-cells. This can be seen from the commands:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> print(lc1.labels)\n[\"A\", \"B\", \"a\", \"b\", \"c\", \"alpha\"]\n\njulia> print(lc2.labels)\n[\"A\", \"B\", \"c\", \"a\", \"b\", \"alpha\"]","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"As the above docstring shows, these different versions lead to  two different connection matrices cm1 and cm2.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: Direct derivation of connection matrices)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"In this small example, one can easily determine the connection matrices directly, as illustrated in the second figure. While the detailed explanation can be found in [MW25], this is basically accomplished by contracting one of the two regular multivectors in a process called elementary reduction. While the details of this approach are described in [KMS98], it relies on identifying a reduction pair, which contains a cell and one of its faces of one dimension less. These two cells are then removed from the Lefschetz complex and the boundary is modified in such a way that the new smaller complex still has the same homology as the previous one. If in our above example one uses the reduction pair  B c , then the boundary matrix of the reduced Lefschetz complex is the connection matrix cm1, while cm2 is the result of using the reduction pair  A a . These manipulations can be done in ConleyDynamics.jl using the function lefschetz_reduction:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> rc1 = lefschetz_reduction(lc1, \"B\", \"c\");\n\njulia> rc2 = lefschetz_reduction(lc1, \"A\", \"a\");","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"These two commands compute the reduced Lefschetz complexes rc1 and rc2 for the respective elementary reduction pairs  B c  and  A a . As the following commands show, the first one leads to our earlier connection matrix cm1:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> full_from_sparse(rc1.boundary)\n4×4 Matrix{Int64}:\n 0  0  0  0\n 0  0  0  1\n 0  0  0  1\n 0  0  0  0\n\njulia> println(rc1.labels)\n[\"A\", \"a\", \"b\", \"alpha\"]","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Similarly, the connection matrix cm2 is the result of the second reduction:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> full_from_sparse(rc2.boundary)\n4×4 Matrix{Int64}:\n 0  0  0  0\n 0  0  0  1\n 0  0  0  0\n 0  0  0  0\n\njulia> println(rc2.labels)\n[\"B\", \"b\", \"c\", \"alpha\"]","category":"page"},{"location":"man/examples/#Subdividing-a-Multivector","page":"Examples","title":"Subdividing a Multivector","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Our next example taken from [MW25] is concerned with turning a given multivector field into a Forman vector field by further subdividing the multivectors. For this, consider the three complexes and combinatorial vector fields shown in the associated figure, see also [MW25, Figure 7.1].","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: Subdividing a multivector)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The depicted combinatorial dynamical systems all use the same Lefschetz complex, which is obtained from a simplicial complex by removing two vertices. In addition to the multivector field shown in the leftmost panel, we also consider two Forman vector fields. Notice that the multivector field has one multivector of size four, which is given by  mathrmC mathrmAC  mathrmBC mathrmABC . This vector can be split into two Forman arrows, and in view of the required local closedness this can be achieved in precisely two ways. The splitting into the arrows  mathrmC mathrmAC  and  mathrmBC mathrmABC  gives the Forman vector field shown in the middle panel, while the one depicted in the rightmost panel uses the arrows  mathrmC mathrmBC  and  mathrmAC mathrmABC . These fields can be created using the function example_subdivision:","category":"page"},{"location":"man/examples/#ConleyDynamics.example_subdivision-Tuple{}-man-examples","page":"Examples","title":"ConleyDynamics.example_subdivision","text":"lc, mvf = example_subdivision(mvftype)\n\nCreate the Lefschetz complex and multivector field for the example from Figure 11 in the connection matrix paper by Mrozek & Wanner.\n\nDepending on the value of mvftype, return the multivector (0=default) or one of the two combinatorial vector field (1,2) examples.\n\nThe function returns the Lefschetz complex lc over the rationals and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_subdivision(1);\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> full_from_sparse(cm.matrix)\n5×5 Matrix{Rational{Int64}}:\n 0  0  -1  -1  -1\n 0  0   1   0   0\n 0  0   0   0   0\n 0  0   0   0   0\n 0  0   0   0   0\n\n\n\n\n\n","category":"method"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The different combinatorial vector fields can be selected via the function argument, which is an integer between 0 and 2, from left to right in the figure. Thus, all fields and connection matrices can be computed using the commands","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"lc0, mvf0 = example_subdivision(0)\nlc1, mvf1 = example_subdivision(1)\nlc2, mvf2 = example_subdivision(2)\ncm0 = connection_matrix(lc0,mvf0)\ncm1 = connection_matrix(lc1,mvf1)\ncm2 = connection_matrix(lc2,mvf2)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"All three vector fields give rise to the same Morse decomposition, since in each case the vectors of length at least two are regular. This can be seen for the multivector field below, and is analogous for the two Forman vector fields.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> cm0.morse\n5-element Vector{Vector{String}}:\n [\"A\"]\n [\"B\"]\n [\"AB\"]\n [\"CD\"]\n [\"CE\"]\n\njulia> cm0.conley\n5-element Vector{Vector{Int64}}:\n [1, 0, 0]\n [1, 0, 0]\n [0, 1, 0]\n [0, 1, 0]\n [0, 1, 0]","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The three connection matrices are as follows:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"julia> full_from_sparse(cm0.matrix)\n5×5 Matrix{Rational{Int64}}:\n 0  0  -1   0   0\n 0  0   1  -1  -1\n 0  0   0   0   0\n 0  0   0   0   0\n 0  0   0   0   0\n\njulia> full_from_sparse(cm1.matrix)\n5×5 Matrix{Rational{Int64}}:\n 0  0  -1  -1  -1\n 0  0   1   0   0\n 0  0   0   0   0\n 0  0   0   0   0\n 0  0   0   0   0\n\njulia> full_from_sparse(cm2.matrix)\n5×5 Matrix{Rational{Int64}}:\n 0  0  -1   0   0\n 0  0   1  -1  -1\n 0  0   0   0   0\n 0  0   0   0   0\n 0  0   0   0   0","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Notice that the connection matrices for the two Forman vector fields are uniquely determined, since both are gradient vector fields. The matrices are, however, different. At first glance, the connection matrix for mvf0 is equal to the one for mvf2. Yet, this is another example of nonuniqueness, and one could produce also the connection matrix for mvf1 through a reordering of the cells in the Lefschetz complex.","category":"page"},{"location":"man/examples/#A-Combinatorial-Lorenz-System","page":"Examples","title":"A Combinatorial Lorenz System","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Our next example is taken from [KMW16, Figure 3]. It is a Forman vector field on a two-dimensional simplicial complex, as shown in the accompanying figure.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: A combinatorial Lorenz system)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Notice that the underlying simplicial complex does not represent a manifold in this case, but rather a branched manifold. As indicated in the figure, the two triangles mathbfhin and mathbfhio only intersect in the edge mathbfhi, and this edge is also contained in the third triangle mathbfchi. This system is a combinatorial version of the famous Lorenz butterfly, which is well-known for its chaotic behavior. The simplicial complex and the Forman vector field can be created using the function example_clorenz:","category":"page"},{"location":"man/examples/#ConleyDynamics.example_clorenz-Tuple{}-man-examples","page":"Examples","title":"ConleyDynamics.example_clorenz","text":"lc, mvf = example_clorenz()\n\nCreate the simplicial complex and multivector field for the example from Figure 3 in the JCD 2016 paper by Kaczynski, Mrozek, and Wanner.\n\nThe function returns the Lefschetz complex lc over the finite field GF(2) and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_clorenz();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0   0   1]\n[0   0   0   0   0]\n[0   0   0   0   1]\n[0   0   0   0   0]\n[0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"i\", \"ip\", \"g\", \"gm\", \"bc\"]\n\njulia> ms, ps = morse_sets(lc, mvf, poset=true);\n\njulia> [conley_index(lc, mset) for mset in ms]\n4-element Vector{Vector{Int64}}:\n [1, 1, 0]\n [1, 1, 0]\n [0, 1, 0]\n [0, 0, 0]\n\njulia> ps\n4×4 Matrix{Bool}:\n 0  0  1  0\n 0  0  1  0\n 0  0  0  1\n 0  0  0  0\n\n\n\n\n\n","category":"method"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The first of the above commands creates the simplicial complex lc and the Forman vector field mvf. These are then analyzed using the following commands:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Using cm = connection_matrix(lc, mvf) one can compute the  connection matrix of the example. This connection matrix has two nonzero entries, which indicate connecting orbits from the index 1 critical cell mathbfbc to each of the stable periodic orbits spanned by the vertices mathbfh, mathbfg, mathbfm and mathbfi, mathbfj, mathbfp, respectively.\nThe command ms, ps = morse_sets(lc, mvf, poset=true) shows, however, that there is more to this example. While the above connection matrix indicates only three isolated invariant sets, there is actually a fourth one. In view of the  Conley index computation for these sets, the additional Morse set has trivial index, and therefore does not show up in the connection matrix. Notice that the partial order given by the flow, which is indicated by the matrix ps, implies that the Morse set with trivial index has a connection to the index 1 critical cell.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Upon closer inspection one can see that the last Morse set is comprised of all triangles, as well as all edges which are contained in at least two triangles. This set contains infinitely many periodic orbits. For any bi-infinite sequence of symbols L and R there is a periodic orbit which loops around the left hole for L and around the right hole for R, as one traverses the symbol sequence from left to right. Such behavior is one potential indicator for chaos. In fact, it was shown in [MW21] that it is possible to define a classical semiflow on the branched manifold defined by lc which mimics the behavior of the Forman vector field. And according to [MSTW22], any such admissible semiflow does indeed have infinitely many periodic orbits in the set determined by the triangles.","category":"page"},{"location":"man/examples/#Chaos-in-a-Space-with-Torsion","page":"Examples","title":"Chaos in a Space with Torsion","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Our next example describes gradient Forman vector fields on simplicial complexes with torsion whose connection matrices can have large entries, as long as the underlying field has a large enough characteristic. In addition, by merging two critical cells in the Forman gradient vector field into an arrow, once obtains a Forman vector field with chaotic behavior. The simplicial complexes are based on the function simplicial_torsion_space, and the Forman vector fields can be seen in the associated figure for the cases n=3 and n=4.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: Forman chaos in a space with torsion)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"After specifying the torsion coefficient n and the field characteristic p, the underlying simplicial complex and the two Forman vector fields can be created using the function example_torsion_chaos:","category":"page"},{"location":"man/examples/#ConleyDynamics.example_torsion_chaos-man-examples","page":"Examples","title":"ConleyDynamics.example_torsion_chaos","text":"sc, vfG, vfC = example_torsion_chaos(n::Int, p::Int)\n\nCreate a triangulation of a space with 1-dimensional torsion, as well as two Forman vectr fields on this complex.\n\nThe function returns a simplicial complex sc which has the following integer homology groups:\n\nIn dimension 0 it is the group of integers.\nIn dimension 1 it is the integers modulo n.\nIn dimension 2 it is the trivial group.\n\nIn other words, the simplicial complex has nontrivial torsion in dimension 1. It is a triangulation of an n-gon, in which all boundary edges are oriented counterclockwise, and all of these edges are identified. The parameter p specifies the characteristic of the underlying field.\n\nIn addition, two Forman vector fields vfG and vfC are returned. The first one is a gradient vector field whose connection matrix has a large connection matrix entry. In fact, if p is any prime larger than n then there will be an entry n in the matrix. The scond Forman vector field contains a chaotic Morse set. This Morse set will have trivial Morse index for most p. On the other hand, for prime p = n the set has the Morse index of an unstable  periodic orbit.\n\nExamples\n\njulia> sc, vfG, vfC = example_torsion_chaos(3,7);\n\njulia> homology(sc)\n3-element Vector{Int64}:\n 1\n 0\n 0\n\njulia> cmG = connection_matrix(sc, vfG);\n\njulia> sparse_show(cmG.matrix)\n[0   0   0]\n[0   0   3]\n[0   0   0]\n\njulia> print(cmG.labels)\n[\"0w\", \"0w0x\", \"0w0x1s\"]\n\njulia> cmC = connection_matrix(sc, vfC);\n\njulia> sparse_show(cmC.matrix)\n[0]\n\njulia> print(cmC.labels)\n[\"0w\"]\n\njulia> msC, psC = morse_sets(sc, vfC, poset=true);\n\njulia> [conley_index(sc, mset) for mset in msC]\n2-element Vector{Vector{Int64}}:\n [1, 0, 0]\n [0, 0, 0]\n\njulia> psC\n2×2 Matrix{Bool}:\n 0  1\n 0  0\n\njulia> length.(msC)\n2-element Vector{Int64}:\n  1\n 26\n\n\n\n\n\n","category":"function"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The first of the above commands creates the simplicial complex sc and the two Forman vector fields. The gradient vector field is returned in vfG, and it corresponds to the Forman vector fields shown in red  in the accompanying figure. The return variable vfC gives the chaotic Forman vector field. Is it obtained from the gradient field by combining the two critical cells mathrm0w0x and mathrm0w0x1s into a Forman arrow, which is indicated in green in the figure. Note that this reverses the flow between these two simplices. In the above example, we use n=3 and p=7.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The gradient Forman vector field vfG is then analyzed using the following commands:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The command homology(sc) shows that in the field GF(7),  the space has the homology of a point.\nThe next command cmG = connection_matrix(sc, vfG) determines the connection matrix for the gradient system. As the entry cmG.labels shows, the Morse sets are the three simplices mathrm0w, mathrm0w0x, and mathrm0w0x1s, and the nontrivial entry in the connection matrix indicates three connections between the index 2 critical cell and the index 1 critical cell.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The next commands analyze the chaotic Forman vector field vfC:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"As before, the command cmC = connection_matrix(sc, vfC)  computes the connection matrix. This time, the matrix is the zero matrix with one row and column, which correspond to the stable critical cell mathrm0w.\nBut there is nontrivial dynamics, as the command msC, psC = morse_sets(sc, vfC, poset=true) demonstrates. It produces two Morse sets. In addition to the stable critical cell, one also obtains an isolated invariant set with trivial index. This set exhibits chaotic behavior, and is shown in purple in the accompanying figure. In  the case n = 3, it consists of 26 simplices. In the general case, it will have 12n - 10 simplices.\nThe return variable psC gives the flow-induced order between the Morse sets, which shows that there are  heteroclinic orbits between the chaotic Morse set and the stable equilibrium.","category":"page"},{"location":"man/examples/#refexamples","page":"Examples","title":"References","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"B. Batko, T. Kaczynski, M. Mrozek and T. Wanner. Linking combinatorial and classical dynamics: Conley             index and Morse decompositions. Foundations of Computational Mathematics 20, 967–1012 (2020).\n\n\n\nT. Kaczynski, M. Mrozek and M. Slusarek. Homology computation by reduction of chain complexes. Computers & Mathematics with Applications 35, 59–70 (1998).\n\n\n\nT. Kaczynski, M. Mrozek and T. Wanner. Towards a formal tie between combinatorial and classical             vector field dynamics. Journal of Computational Dynamics 3, 17–50 (2016).\n\n\n\nM. Mrozek, R. Srzednicki, J. Thorpe and T. Wanner. Combinatorial vs. classical dynamics: Recurrence. Communications in Nonlinear Science and Numerical Simulation 108, Paper No. 106226, 30 pages (2022).\n\n\n\nM. Mrozek and T. Wanner. Creating semiflows on simplicial complexes from combinatorial vector fields. Journal of Differential Equations 304, 375–434 (2021).\n\n\n\nM. Mrozek and T. Wanner. Connection Matrices in Combinatorial Topological Dynamics. SpringerBriefs in Mathematics (Springer-Verlag, Cham, 2025).\n\n\n\n","category":"page"},{"location":"man/conley/#Conley-Theory","page":"Conley Theory","title":"Conley Theory","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The main motivation for ConleyDynamics.jl is the development of an accessible tool for studying the global dynamics of multivector fields on Lefschetz complexes. Having already discussed the latter, we now turn our attention to multivector fields and their global dynamics. This involves a detailed discussion of multivector fields, isolated invariant sets, their Conley index, as well as Morse decompositions and connection matrices. We also describe how a variety of isolated invariant sets can be constructed using Morse decomposition intervals, and apply these tools to the analysis of simple planar and three-dimensional ordinary differential equations.","category":"page"},{"location":"man/conley/#Multivector-Fields","page":"Conley Theory","title":"Multivector Fields","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Suppose that X is a Lefschetz complex as described in Lefschetz Complexes, see in particular the definition in Basic Lefschetz Terminology. Assume further that the Lefschetz complex is defined over a field F, which is either the rational numbers mathbbQ or a finite field of prime order. Then a multivector field on X is defined as follows.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"tip: Definition: Multivector field\nA multivector field mathcalV on a Lefschetz complex X is a partition of X into locally closed sets.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Recall from our detailed discussion in Basic Lefschetz Terminology that a set V subset X is called locally closed if its mouth mathrmmo V = mathrmcl V setminus V is closed, where closedness in turn is defined via the face relation in a Lefschetz complex. This implies that for each multivector V in mathcalV the relative homology H_*(mathrmcl V mathrmmo V) is well-defined, and it allows for the following classification of multivectors:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"A critical multivector is a multivector for which H_*(mathrmcl V mathrmmo V) neq 0.\nA regular multivector is a multivector for which H_*(mathrmcl V mathrmmo V) = 0.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Since a multivector is locally closed, it is a Lefschetz subcomplex of X as well, and we have already seen that its Lefschetz homology satisfies H_*(V) cong H_*(mathrmcl V mathrmmo V). For more details, see Relative Homology.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The above classification of multivectors is motivated by the case of classical Forman vector fields. These are a special  case of multivector fields, in that they also form a partition of the underlying Lefschetz complex. This time, however, there  are only two types of multivectors:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"A critical cell is a multivector consisting of exactly one cell of the Lefschetz complex. One can easily see that in this case the k-th homology group is isomorphic to F, as long as the cell has dimension k. All other homology groups vanish. Thus, every critical cell  is a critical multivector.\nA Forman arrow is a multivector consisting of two cells sigma^- and sigma^+, where sigma^- is a facet of sigma^+. In other words, one has to have kappa(sigma^+ sigma^-) neq 0, which also implies that 1 + dimsigma^- = dimsigma^+. One can show that all homology groups of a Forman arrow are zero, and therefore it is a regular multivector.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In ConleyDynamics.jl, multivector fields can be created in two different ways. The direct method is to specify all multivectors of length larger than one in an array of type Vector{Vector{Int}} or Vector{Vector{String}}, depending on whether the involved cells are referenced via their indices or labels. Recall that it is easy to convert between these two forms using the command convert_cellsubsets. The subsets specified by the vector entries have to be disjoint. They do not, however, have to exhaust  the underlying Lefschetz complex X. Any cells that are not part of a specified multivector will be considered as one-element critical cells. This reduces the size of the representation in many situations.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"For large Lefschetz complexes, the above method becomes quickly  impractical. In such a case it is easier to determine a multivector field indirectly, through a mechanism involving dynamical  transitions. This is based on the following result.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"danger: Theorem: Multivector fields via dynamical transitions\nLet X be a Lefschetz complex and let mathcalD denote an arbitrary collection of subsets of X. Then there exists a uniquely determined minimal multivector field mathcalV which satisfies the following:For every D in mathcalD there exists a V in mathcalV such that D subset V.Note that the sets in mathcalD do not have to be disjoint, and their union does not have to exhaust X. One can think of the sets in mathcalD as all allowable dynamical transitions.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The above result shows that as long as one has an idea about the  transitions that a system has to be allowed to do, one can always find a smallest multivector field which realizes them. Needless to say, if too many transitions are specified, then it is possible that the result leads to the trivial multivector field mathcalV =  X . In most cases, however, the resulting multivector field is more useful. See also the examples later in this section of the manual.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The package ConleyDynamics.jl provides a number of functions for creating and manipulating multivector fields on Lefschetz complexes:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The function create_mvf_hull implements the above theorem on dynamical transitions. It expects two input arguments: A Lefschetz complex lc, as well as a vector mvfbase that defines the dynamical transitions in mathcalD. The latter has to have type Vector{Vector{Int}} or Vector{Vector{String}}.\nThe function mvf_information displays basic information about a given multivector field. It expects both a Lefschetz complex and a multivector field as arguments, and returns a Dict{String,Any} with the information. The keys of this dictionary are as follows:\n\"N mv\": Number of multivectors\n\"N critical\": Number of critcal multivectors\n\"N regular\": Number of regular multivectors\n\"Lengths critical\": Length distribution of critical multivectors\n\"Lengths regular\": Length distribution of regular multivectors\nIn the last two cases, the dictionary entries are vectors of pairs (length,frequency), where each pair indicates that there are frequency multivectors of length length.\nThe function extract_multivectors expects as input arguments a Lefschetz complex and a multivector field, as well as a list of cells specified as a Vector{Int} or a Vector{String}. It returns a list of all multivectors that contain the specified cells.\nThe function create_planar_mvf creates a multivector field which approximates the dynamics of a given planar vector field. It expects as arguments a two-dimensional Lefschetz complex, a vector of planar coordinates for the vertices of the complex, as well as a function which implements the vector field. It returns a multivector field based on the dynamical transitions induced by the vector field directions on the vertices and edges of the Lefschetz complex. While the complex does not have to be a triangulation, it is  expected that the one-dimensional cells are straight line segments between the two boundary vertices.\nThe utility function planar_nontransverse_edges expects the same arguments as the previous one, and returns a list of nontransverse edges as Vector{Int}, which contains the corresponding edge indices. The optional parameter npts determines how many points along an edge are evaluated for the transversality check.\nThe function create_spatial_mvf creates a multivector field which approximates the dynamics of a given spatial vector field. While it expects the same arguments as its planar counterpart, the Lefschetz complex has to be of one of the following two types:\nThe Lefschetz complex is a tetrahedral mesh of a region in three dimensions, i.e., it is a simplicial complex.\nThe Lefschetz complex is a three-dimensional cubical complex, i.e., it is the closure of a collection of three-dimensional cubes in space.\nIn the second case, the vertex coordinates can be slightly perturbed from the original position in the cubical lattice, as long as the overall structure of the complex stays intact. In that case, the faces are interpreted as Bezier surfaces with straight edges.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"All of these functions will be illustrated in more detail in the examples which are presented later in this section. See also the Tutorial for another planar vector field analysis.","category":"page"},{"location":"man/conley/#Invariance-and-Conley-Index","page":"Conley Theory","title":"Invariance and Conley Index","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"A multivector field induces dynamics on the underlying Lefschetz complex through the iteration of a multivalued map. This flow map is given by","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   Pi_mathcal V(x) = mathrmcl x cup x_mathcal V\n   qquadtext for all qquad\n   x in X","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"where x_mathcal V denotes the unique multivector in mathcal V which contains x. The definition of the flow map shows that the induced dynamics combines two types of behavior:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"From a cell x, it is always possible to flow towards the boundary of the cell, i.e., to any one of its faces.\nIn addition, it is always possible to move freely within a multivector.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The multivalued map Pi_mathcal V  X multimap X naturally leads to a solution concept for multivector fields. A path is a sequence x_0 x_1 ldots x_n in X such that x_k in Pi_mathcalV(x_k-1) for all indices k = 1ldotsn. Paths of bi-infinite length are called solutions. More precisely, a solution of the combinatorial dynamical system induced by the multivector field is then a map rho  mathbbZ to X which satisfies rho(k+1) in Pi_mathcal V(rho(k)) for all k in mathbbZ. We say that this solution passes through the cell x in X if in addition one has rho(0) = x. It is clear from the definition of the flow map that every constant map is a solution, since we have the inclusion x in Pi_mathcal V(x). Thus, rather than considering solutions in the above (classical) sense, we focus on a more restrictive notion.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"tip: Definition: Essential solution\nLet rho  mathbbZ to X be a solution for the multivector field mathcalV. Then rho is an essential solution, if the following holds:If for k in mathbbZ the cell rho(k) lies in a regular multivector V in mathcalV, then there exist integers ell_1  k  ell_2 for which we have rho(ell_i) notin V for i = 12.In other words, an essential solution has to leave a regular multivector both in forward and in backward time. It can, however, stay in a critical multivector for as long as it wants.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The notion of essential solution has its origin in the distinction between critical and regular multivectors. In Forman's theory,  which is based on classical Morse theory, critical cells correspond to stationary solutions or equilibria of the underlying flow. Thus, it has to be possible to stay in a critical multivector for all times, whether in forward or backward time, or even for all times. On the other hand, a Forman arrow indicates prescribed non-negotiable motion, and therefore a regular multivector corresponds to motion which goes from the multivector to its mouth.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The multivector field from the package logo, which is shown in the accompanying image, consists of three critical cells, two Forman arrows, as well as one multivector which consists of four cells. Beyond the constant essenetial solutions in each of the three critical cells, another essential solution is the periodic orbit","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   rho_P text given by \n   ldots to mathbfA to mathbfAB to mathbfB\n     to mathbfBCD to mathbfC to mathbfAC\n     to mathbfA to ldots","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Notice that this is just one of many realizations of this particular periodic motion, since an essential solution can take many different paths through a multivector.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: The logo multivector field)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Using the concept of essential solutions we can now introduce the notion of invariance. Informally, we say that a subset of a Lefschetz complex is invariant if through every cell in the set there exists an essential solution which stays in the set. In other words, we have the choice of staying in the set, even though there might be other solutions that do leave. More generally, for every subset A subset X one can ask whether there are elements x in A for which there exists an essential solution which passes through x and stays in A for all times. This leads to the definition of the invariant part of A as","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   mathrmInv_mathcalV(A) =\n   left x in A   \n      textthere exists an essential solution \n      rho  mathbbZ to A text through  x\n      right","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"It is certainly possible that the invariant part of a set is  empty. If, however, the invariant part of A is all of A, i.e., if we have mathrmInv_mathcalV(A) = A, then the set A is called invariant. In the context of our above logo example, the image of the essential solution rho_P is clearly an invariant set.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Invariant sets are the fundamental building blocks for the global dynamics of a dynamical system. Yet, in general they are difficult to study. Conley realized in [Con78] that if one  restricts the attention to a more specialized notion of invariance, then topological methods can be used to formulate a coherent  general theory. For this, we need to introduce the notion of  isolated invariant set:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"tip: Definition: Isolated invariant set\nA closed set N subset X isolates an invariant set S subset N, if the following two conditions are satisfied:Every path in N with endpoints in S is a path in S.\nWe have Pi_mathcalV(S) subset N.An invariant set S is an isolated invariant set, if there exists a closed set N which isolates S.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"It is clear that the whole Lefschetz complex X isolates its invariant part. Therefore, the set mathrmInv_mathcalV(X) is an isolated invariant set. Moreover, one can readily show that if N is an isolating set for an isolated invariant set S, then any closed set S subset M subset N also isolates S. Thus, the closure mathrmcl S is the smallest isolating set for S. With these observations in mind, one obtains the following result from [LKMW23]:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"danger: Theorem: Characterization of isolated invariant sets\nAn invariant set S subset X is an isolated invariant set, if and only if the following two conditions hold:S is mathcalV-compatible, i.e., it is the union of multivectors.\nS is locally closed.In this case, the isolated invariant set S is isolated by its closure mathrmcl S.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Returning to our earlier logo example, notice that the cells visited by the periodic essential solution rho_P do not form an isolated invariant set, but rather just an invariant set. However, if we consider the larger set S_P which consists of all cells except for the cells mathbfABC and mathbfD, then we do obtain an isolated invariant set which contains the periodic orbit rho_P.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"With this characterization at hand, identifying isolated invariant sets becomes straightforward. In addition, since isolated invariant sets are locally closed, we can now also define their Conley index:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"tip: Definition: Conley index\nLet S subset X be an isolated invariant set the multivalued flow map Pi_mathcalV. Then the Conley index of S is the relative (or Lefschetz) homology   CH_*(S) = H_*( mathrmcl S mathrmmo S)\n           cong H_*(S)In addition, the Poincare polynomial of S is defined as   p_S(t) = sum_k=0^infty beta_k(S) t^k  \n   quadtextwherequad\n   beta_k(S) = dim CH_k(S)  The Poincare polynomial is a concise way to encode the homology information.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Since the Conley index is nothing more than the relative homology of the closure-mouth-pair associated with a locally closed set, one could easily use the homology functions described in Homology for its computation. However, we have included a wrapper function to keep the notation uniform. In addition, ConleyDynamics.jl contains a function which provides basic information about an isolated invariant set. These two functions can be described as follows:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The function conley_index determines the Conley index of an isolated invariant set. It expects a Lefschetz complex as its first argument, while the second one has to be a list of cells which specifies the isolated invariant  set, and which is either of type Vector{Vector{Int}} or Vector{Vector{String}}. An error is raised if the second argument does not specify a locally closed set.\nThe function isoinvset_information expects a Lefschetz complex lc::LefschetzComplex, a multivector field mvf::CellSubsets, as well as an isolated invariant set iis::Cells as its three arguments. Itreturns a Dict{String,Any} with the information. The keys of this dictionary are as follows:\n\"Conley index\" contains the Conley index of the  isolated invariant set.\n\"N multivectors\" contains the number of multivectors in the isolated invariant set.","category":"page"},{"location":"man/conley/#Morse-Decompositions","page":"Conley Theory","title":"Morse Decompositions","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"We now turn our attention to the global dynamics of a combinatorial dynamical system. This is accomplished through the notion of Morse decomposition, and it requires some auxilliary definitions:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Suppose we are given a solution varphi  mathbbZ to X for the multivector field mathcalV. Then the long-term limiting behavior of varphi can be described using the ultimate backward and forward images\n   mathrmuim^- varphi =\n   bigcap_t in mathbbZ^- varphileft( (-inftyt right)\n   qquadtextandqquad\n   mathrmuim^+ varphi =\n   bigcap_t in mathbbZ^+ varphileft( t+infty) right) \nNotice that since X is finite, there has to exist a k in mathbbN such that\n   mathrmuim^- varphi =\n   varphileft( (-infty-k right) neq emptyset\n   qquadtextandqquad\n   mathrmuim^+ varphi =\n   varphileft( k+infty) right) neq emptyset \nThe mathcalV-hull of a set A subset X is the intersection of all mathcalV-compatible and locally closed sets containing A. It is denoted by langle A rangle_mathcalV, and is the smallest  candidate for an isolated invariant set which contains A.\nThe alpha- and omega-limit sets of varphi are then defined as\n   alpha(varphi) =\n   leftlangle mathrmuim^- varphi rightrangle_mathcalV\n   qquadtextandqquad\n   omega(varphi) =\n   leftlangle mathrmuim^+ varphi rightrangle_mathcalV","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"While in general the mathcalV-hull of a set does not have to be invariant, the following result shows that for every  essential solution both of its limit sets are in fact isolated invariant sets.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"danger: Theorem: Limit sets are nontrivial\nLet varphi be an essential solution in X. Then both limit sets alpha(varphi) and omega(varphi) are nonempty isolated invariant sets.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"We briefly pause to illustrate these concepts in the context of the above logo example. For the periodic essential solution rho_P, both its ultimate backward and forward images  are precisely the cells visited by the solution. The mathcalV-hull of mathrmim rho_P is the set S_P which consists of all cells except the index 0 and 2 critical cells. It was already mentioned earlier that this indeed defines an isolated invariant set.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The above notions allow us to decompose the global dynamics of a multivector field. Loosely speaking, this is accomplished by separating the dynamics into a recurrent part given by an indexed collection of isolated invariant sets, and the gradient dynamics between them. This can be abstracted through the concept of a Morse decomposition.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"tip: Definition: Morse decomposition\nAssume that X is an invariant set for the multivector field mathcalV and that (mathbbPleq) is a finite poset. Then an indexed collection mathcalM = left M_p    p in mathbbP right is called a Morse decomposition of X if the following conditions are satisfied:The indexed family mathcalM is a family of mutually disjoint, isolated invariant subsets of X.\nFor every essential solution varphi in X either one has mathrmim  varphi subset M_r for an r in mathbbP or there exist two poset elements pq in mathbbP such that q  p and\n   alpha(varphi) subset M_q\n   qquadtextandqquad\n   omega(varphi) subset M_p \nThe elements of mathcalM are called Morse sets. We would like to point out that some of the Morse sets could be empty.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Given a combinatorial multivector field mathcalV on an arbitrary Lefschetz complex X, there always exists a finest Morse decomposition mathcalM. It can be found by determining those strongly connected components of the digraph associated with the multivalued flow map Pi_mathcalV  X multimap X which contain essential solutions. The associated Conley-Morse graph is the partial order induced on mathcalM by the existence of connections, and represented as a directed graph labelled with the Conley indices of the isolated invariant sets in mathcalM in terms of their Poincare polynomials.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In order to capture the dynamics between two subsets AB subset X one can define the connection set from A to B as the cell collection","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   mathcalC(AB) =\n   left x in X   \n     exists  text essential solution \n     varphi text through  x text with \n     alpha(varphi) subset A text and \n     omega(varphi) subset B right ","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Then mathcalC(AB) is an isolated invariant set. We would  like to point out, however, that the connection set can be, and in fact will be, empty in many cases.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"While the Morse sets of a Morse decomposition are the fundamental building blocks for the global dynamics, there usually are many additional isolated invariant sets for the multivector field mathcalV. Of particular interest are Morse intervals. To define them, let I subset mathbbP denote an interval in the index poset. Then","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   M_I  =  bigcup_p in I M_p  cup \n               bigcup_pq in I mathcalC( M_q M_p )","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"is always an isolated invariant set. Nevertheless, not every isolated invariant set is of this form. For example, the figure contains the multivector field which was discussed in [BKMW20, Figure 3]. While the underlying simplicial complex and the Forman vector field are depicted in the left panel, the associated Conley-Morse graph is shown on the right. For this combinatorial dynamical system, there exists an isolated invariant set which contains only the four Morse sets within the gray region under the graph. More details can be found in A Planar Forman Vector Field.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Morse decomposition of the planar flow)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Morse decompositions and intervals can be easily computed  and manipulated in ConleyDynamics.jl using the following commands:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The function morse_sets expects a Lefschetz complex and a multivector field as arguments, and returns the Morse sets of the finest Morse decomposition as a Vector{Vector{Int}} or Vector{Vector{String}}, matching the format used for the multivector field. If the optional argument poset=true is added, then the function also returns a matrix which encodes the Hasse diagram of the poset mathbbP. Note that this is the transitive reduction of the full poset,  i.e., it only contains necessary relations.\nThe function morse_interval computes the isolated invariant set for a Morse set interval. The three input arguments are the underlying Lefschetz complex, a multivector field, and a collection of Morse sets. The latter should be determined using the function morse_sets. The function returns the smallest isolated invariant set which contains the Morse sets and their connections as a Vector{Int}. The result can be converted to label form using convert_cells.\nThe function restrict_dynamics restricts a multivector field to a Lefschetz subcomplex. The function expects three arguments: A Lefschetz complex lc, a multivector field mvf, and a subcomplex of the Lefschetz complex which is given by the locally closed set represented by lcsub. It returns the associated Lefschetz subcomplex lcreduced and the induced multivector field mvfreduced on the subcomplex. The multivectors of the new multivector field are the intersections of the original multivectors and the subcomplex.\nFinally, the function remove_exit_set removes the exit set for a multivector field on a Lefschetz subcomplex. It is assumed that the Lefschetz complex lc is a topological manifold and that mvf contains a multivector field that is created via either create_planar_mvf or create_spatial_mvf. The function identifies cells on the boundary at which the flows exits the region covered by the Lefschetz complex. If this exit set is closed, one has found an isolated invariant set and the function returns a Lefschetz complex lcr restricted to it, as well as the restricted multivector field mvfr. If the exit set is not closed, a warning is displayed and the function returns the restricted Lefschetz complex and multivector field obtained by removing the closure of the exit set. In the latter case, unexpected results might be obtained.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The first two of these functions rely heavily on the Julia package Graphs.jl.","category":"page"},{"location":"man/conley/#Connection-Matrices","page":"Conley Theory","title":"Connection Matrices","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"While a Morse decomposition represents the basic structure of the global dynamics of a combinatorial dynamical system, it does not directly provide more detailed information about the dynamics between them – except for the poset order on the Morse sets. But which of the associated connecting sets actually have to be nonempty? The algebra behind this question is captured by the connection matrix. The precise notion of connection matrix was introduced in [Fra89], see also [HMS21], as well as the book [MW25] which treats connection matrices specifically in the setting of multivector fields and provides a precise definition of connection matrix equivalence, even  across varying posets.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Since the precise definition of a connection matrix is  beyond the scope of this manual, we only state what it is as an object, what its main properties are, and how it can be computed in ConleyDynamics.jl. Assume therefore that we are given a Morse decomposition mathcalM of an isolated invariant set S. Then the connection matrix is a linear map","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   Delta    bigoplus_q in mathbbP CH_*(M_q)\n   to bigoplus_p in mathbbP CH_*(M_p) ","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"i.e., it is a linear map which is defined on the direct sum of all Conley indices of the Morse sets in the Morse decomposition. One usually writes the connection matrix Delta as a matrix in the form Delta = (Delta(pq))_pq in mathbbP, which is indexed by the poset mathbbP, and where the entries Delta(pq)  CH_*(M_q) to CH_*(M_p) are linear maps between homological Conley indices. If I denotes an interval in the poset mathbbP, then one further defines the restricted connection matrix","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   Delta(I)  =  left( Delta(pq) right)_pq in I\n        bigoplus_p in I CH_*(M_p) to\n     bigoplus_p in I CH_*(M_p) ","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Any connection matrix Delta has the following fundamental properties:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The matrix Delta is strictly upper triangular, i.e., if Delta(pq) not= 0 then p  q.\nThe matrix Delta is a boundary operator, i.e., we have Delta circ Delta = 0, and Delta maps k-th level homology to (k-1)-st level homology for all k in mathbbZ.\nFor every interval I in mathbbP we have\n   H_*Delta(I)  = \n   mathrmker Delta(I)  mathrmim Delta(I)\n    cong  CH_*(M_I) \nIn other words, the Conley index of a Morse interval can be determined via the homology of the associated connection matrix minor Delta(I).\nIf  p q  is an interval in mathbbP and Delta(pq) neq 0, then the connection set mathcalC(M_qM_p) is not empty.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"We would like to point out that these properties do not characterize connection matrices. In practice, a given multivector field can have several different connection matrices. These in some sense encode different types of dynamical behavior that can occur in the system. Nonuniqueness, however, cannot be observed if the underlying system is a gradient combinatorial Forman vector field on a Lefschetz complex. These are multivector fields in which every multivector is either a singleton, and therefore a critical cell, or a two-element Forman arrow. In addition, a gradient combinatorial Forman vector field cannot have any nontrivial periodic solutions, i.e.,  periodic solutions which are not constant and therefore critical cells. For such combinatorial vector fields, the following result was shown in [MW25].","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"danger: Theorem: Uniqueness of connection matrices\nIf mathcalV is a gradient combinatorial Forman vector field and mathcalM its finest Morse decomposition, then the connection matrix is uniquely determined.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In ConleyDynamics.jl connection matrices can be computed over arbitrary finite fields or the rationals, using the persistence-like algorithm introduced in [DLMS24]:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The function connection_matrix computes a connection matrix for the multivector field mvf on the Lefschetz complex lc over the field associated with the Lefschetz complex boundary matrix. The function returns an object of type ConleyMorseCM, which is further described below. If the optional argument returnbasis=true is given, then the function also returns a dictionary which gives the basis for the connection matrix columns in terms of the original cell labels.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The connection matrix is returned in an object with the composite data type ConleyMorseCM. Its docstring is as follows:","category":"page"},{"location":"man/conley/#ConleyDynamics.ConleyMorseCM-man-conley","page":"Conley Theory","title":"ConleyDynamics.ConleyMorseCM","text":"ConleyMorseCM{T}\n\nCollect the connection matrix information in a struct.\n\nThe struct has the following fields:\n\nmatrix::SparseMatrix{T}: Connection matrix\ncolumns::Vector{Int}: Corresponding columns in the boundary matrix\nposet::Vector{Int}: Poset indices for the connection matrix columns\nlabels::Vector{String}: Labels for the connection matrix columns\nmorse::Vector{Vector{String}}: Vector of Morse sets in original complex\nconley::Vector{Vector{Int}}: Vector of Conley indices for the Morse sets\ncomplex::LefschetzComplex: The Conley complex as a Lefschetz complex\n\n\n\n\n\n","category":"type"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"To illustrate these fields further, we briefly illustrate them for the example associated with the last figure, see again A Planar Forman Vector Field. For reference, the  underlying simplicial complex and Forman vector field are shown in the next figure.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: A planar simplicial complex flow)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The underlying Lefschetz complex, multivector field, and connection matrix can be computed over the field GF(2) as follows:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"using ..ConleyDynamics # hide\nlc, mvf, coords = example_forman2d()\ncm = connection_matrix(lc, mvf)\nsparse_show(cm.matrix)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The field cm.poset indicates which Morse set each column belongs to, while the field cm.labels shows which cell label the column corresponds to. For the example one obtains:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"print(cm.poset)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"print(cm.labels)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Note that except for the third and fourth column, all columns belong to unique Morse sets whose Conley index is a one-dimensional vector space. The third and fourth column correspond to the  periodic orbit, whose Conley index is a two-dimensional vector  space. The Conley indices for all eight Morse sets can be seen in the field cm.conley:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"cm.conley","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The full associated Morse sets are list in cm.morse:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"cm.morse","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"As the final struct field, the entry cm.complex returns the connection matrix as a Lefschetz complex in its own right. This is useful for determining the Conley indices of Morse intervals. In our example, the cells of the new Lefschetz complex are given by","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"cm.complex.labels","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The Morse interval consisting of the two index 2 critical cells mathbfADE and mathbfFGJ should have as Conley index the sum of the two individual indices, and the following computation demonstrates this:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"conley_index(cm.complex, [\"ADE\", \"FGJ\"])","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In contrast, since there is exactly one connecting orbit between mathbfADE and mathbfBF, the Conley index of this interval should be trivial:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"conley_index(cm.complex, [\"ADE\", \"BF\"])","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Finally, there are exactly two connecting orbits between the Morse sets mathbfADE and mathbfEF, and therefore the Conley index of this last interval is again the sum of the separate indices:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"conley_index(cm.complex, [\"ADE\", \"EF\"])","category":"page"},{"location":"man/conley/#Extracting-Subsystems","page":"Conley Theory","title":"Extracting Subsystems","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"We briefly return to one of the examples in the tutorial. More precisely, we consider the planar ordinary differential equation given by","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   beginarrayrcl\n     dotx_1  =  x_1 left( 1 - x_1^2 - 3 x_2^2 right) 1ex\n     dotx_2  =  x_2 left( 1 - 3 x_1^2 - x_2^2 right)\n   endarray","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The dynamics of this system is characterized by the existence of a global attractor in the shape of a closed disk. Inside the attractor, there are nine different Morse sets:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The origin is an equilibrium of index 2, i.e., it is an unstable stationary state with a two-dimensional unstable manifold.\nThe four points (pm 12 pm 12) are unstable equilibria of index 1, i.e., with a one-dimensional unstable manifold.\nFinally, the four points (pm 1 0) and (0 pm 1) are asymptotically stable stationary states.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"We saw in the tutorial that the Morse decomposition of this system can easily be found using ConleyDynamics.jl, as well as the associated connection matrix. Yet, in certain situations one might only be interested in part of the dynamics on the attractor. Moreover, while the Morse sets describe the recurrent part of the dynamics, they do not provide information on the geometry of the connecting sets between the Morse sets. In the following, we illustrate how this can be analyzed further.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The right-hand side of the above vector field can be implemented using the Julia function","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"using ..ConleyDynamics # hide\nusing Random # hide\nRandom.seed!(1234) # hide\nfunction planarvf(x::Vector{Float64})\n    #\n    # Sample planar vector field with nontrivial Morse decomposition\n    #\n    x1, x2 = x\n    y1 = x1 * (1.0 - x1*x1 - 3.0*x2*x2)\n    y2 = x2 * (1.0 - 3.0*x1*x1 - x2*x2)\n    return [y1, y2]\nend","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"To analyze the resulting global dynamical behavior, we first create a simplicial mesh covering the square -65 65^2 using the commands","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"lc, coords = create_simplicial_delaunay(300, 300, 5, 50);\ncoordsN = convert_planar_coordinates(coords,[-1.2,-1.2], [1.2,1.2]);\nlc.ncells","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The integer in the output gives the number of cells in the created Lefschetz complex X. Note that we are using a Delaunay triangulation over an initial box of size 300 times 300, where the target triangle size is about 5. This box is then rescaled to cover the above square. We can then create a  multivector field on the simplicial complex lc and find its Morse decomposition using the commands","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"mvf = create_planar_mvf(lc, coordsN, planarvf);\nmorsedecomp = morse_sets(lc, mvf);\nlength(morsedecomp)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"As expected, ConleyDynamics.jl finds exactly nine Morse sets. Their Conley indices can be computed and stored in a Vector{Vector{Int}} using the command","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"conleyindices = [conley_index(lc, mset) for mset in morsedecomp]","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"These Conley indices correspond to the dynamical behavior near the equilibrium solutions described above.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Suppose now that rather than finding the connection matrix for the complete Morse decomposition, we would only like to consider a  part of it. This can be done as long as we restrict our attention to an interval in the Morse decomposition. Such an interval mathcalI can be created from a selection mathcalS of the Morse sets in the following way:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In addition to the Morse sets in mathcalS, the interval mathcalI contains all Morse sets that lie between two Morse sets in mathcalS with respect to the poset order underlying the Morse decomposition. Recall that this poset order can be computed via morse_sets by activating the extra return object hasse, which describes the Hasse diagram of the poset.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"With every interval mathcalI of the Morse decomposition one can assign a smallest isolated invariant set X_mathcalI subset X which describes the complete dynamics within and between the Morse sets in mathcalI. In fact, in can be characterized as follows:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The set X_mathcalI consists of all cells in the  underlying Lefschetz complex X through which one can find a solution which originates in one Morse set of mathcalI and ends in another Morse set of mathcalI, where the two involved Morse sets can be the same. In other words, one needs to combine the interval Morse sets with all connecting orbits between them.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The two above steps can be performed in ConleyDynamics.jl using the function morse_interval.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In our example, we consider two intervals. The first interval consists of the five Morse sets corresponding to all unstable equilibrium solutions, while the second one considers the four index 1 and the four stable stationary states. The associated isolated invariant sets for these two intervals can be computed as follows:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"subset1 = findall(x -> x[2]+x[3]>0, conleyindices);\nsubset2 = findall(x -> x[1]+x[2]>0, conleyindices);\nlcsub1 = morse_interval(lc, mvf, morsedecomp[subset1]);\nlcsub2 = morse_interval(lc, mvf, morsedecomp[subset2]);\n[length(subset1), length(subset2), length(lcsub1), length(lcsub2)]","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The output shows that we have in fact extracted five and eight Morse sets, respectively. It also shows that the Lefschetz complexes corresponding to these two isolated invariant sets are much smaller than X.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"So far, we have just determined the collections of cells that  correspond to the two isolated invariant sets for these intervals. We can now restrict the combinatorial dynamics to these subsets.  Note that since they are both isolated invariant sets, they are locally closed in X, and therefore the restrictions provide us with two new Lefschetz complexes lcr1 and lcr2, along with induced multivector fields mvfr1 and mvfr2, respectively. In ConleyDynamics.jl, this is achieved using the commands","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"lcr1, mvfr1 = restrict_dynamics(lc, mvf, lcsub1);\nlcr2, mvfr2 = restrict_dynamics(lc, mvf, lcsub2);\n[lcr1.ncells, lcr2.ncells]","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"It is now easy to find the connection matrices for these two intervals. The first connection matrix is given by","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"cmr1 = connection_matrix(lcr1, mvfr1);\ncmr1.conley","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"full_from_sparse(cmr1.matrix)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"It clearly shows that the unstable index 2 Morse set has connecting orbits to every one of the four index 1  equilibria. Similarly, the second connection matrix can be determined as","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"cmr2 = connection_matrix(lcr2, mvfr2);\ncmr2.conley","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"full_from_sparse(cmr2.matrix)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In this case, every index 1 equilibrium is connected  two its two neighboring stable stationary states via heteroclinics that are detected by the connection matrix.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The Lefschetz complexes associated with the two Morse decomposition intervals can also be visualized in ConleyDynamics.jl. For this, recall that the function plot_planar_simplicial_morse can plot an underlying simplicial complex together with any collection of cell subsets. For our purposes, we use the following commands:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"show1 = [[lcr1.labels]; cmr1.morse];\nshow2 = [[lcr2.labels]; cmr2.morse];\nfname1 = \"/Users/wanner/Desktop/invariantinterval2d1.png\"\nfname2 = \"/Users/wanner/Desktop/invariantinterval2d2.png\"\nplot_planar_simplicial_morse(lc, coordsN, fname1, show1, vfac=1.1, hfac=2.0)\nplot_planar_simplicial_morse(lc, coordsN, fname2, show2, vfac=1.1, hfac=2.0)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The variable show1 collects not only the Morse sets that are part of the first connection matrix cmr1, but also the support of the Lefschetz complex lcr1. This support is accessed via [lcr1.labels], and we add it as a first vector of cells in show1. Similarly, we determine the support of the second  isolated invariant set, together with the Morse sets of cmr2. The remaining four commands create two images.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Interval support for the first interval)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The first image shows the five Morse sets surrounding the stationary states at the origin and at (pm 12 pm 12). In addition, it highlights the support of the isolated invariant set associated with this Morse decomposition interval. One can clearly see rough outer approximations for the four heteroclinics which start at the origin and end at the index 1 equilibria. These approximations are necessarily coarse, since we are not working with a very fine triangulation.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Interval support for the second interval)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Finally, the second image depicts the eight Morse sets enclosing the index 1 and the stable stationary states. It also shows the support of the Lefschetz complex lcr2 which is associated with this Morse decomposition interval. In this case, it covers eight different heteroclinic orbits, which are in fact better approximated than the four in the previous image.","category":"page"},{"location":"man/conley/#Analysis-of-a-Planar-System","page":"Conley Theory","title":"Analysis of a Planar System","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Our next example illustrates how ConleyDynamics.jl can be used to analyze the global dynamics of a planar ordinary differential equations. For this, consider the planar system","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   beginarrayrcl\n     dotx_1  =   x_2 - x_1 left( x_1^2 + x_2^2 - 4 right)\n       left( x_1^2 + x_2^2 - 1 right) 1ex\n     dotx_2  =  -x_1 - x_2 left( x_1^2 + x_2^2 - 4 right)\n       left( x_1^2 + x_2^2 - 1 right)\n   endarray","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"This system has already been considered in [MSTW22]. The right-hand side of this vector field can be implemented using the Julia function","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"using ..ConleyDynamics # hide\nfunction circlevf(x::Vector{Float64})\n    #\n    # Sample vector field with nontrivial Morse decomposition\n    #\n    x1, x2 = x\n    c0 = x1*x1 + x2*x2\n    c1 = (c0 - 4.0) * (c0 - 1.0)\n    y1 =  x2 - x1 * c1\n    y2 = -x1 - x2 * c1\n    return [y1, y2]\nend","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"To analyze the global dynamics of this vector field, we first create a cubical complex covering the square -3 3^2 using the commands","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"n = 51\nlc, coords = create_cubical_rectangle(n,n,p=2);\ncoordsN = convert_planar_coordinates(coords,[-3.0,-3.0],[3.0,3.0]);\nlc.ncells","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"As the last result shows, this gives a Lefschetz complex with 10609 cells. The multivector field can be generated using","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"mvf = create_planar_mvf(lc, coordsN, circlevf);\nlength(mvf)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"This multivector field consists of 2437 multivectors. Finally, the  connection matrix can be determined using the command","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"cm = connection_matrix(lc, mvf);\ncm.conley","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Therefore, the above planar system has three isolated invariant sets. One has the Conley index of a stable equilibrium, while the other two have that of a stable and an unstable periodic orbit. The columns of the connection matrix correspond to these invariant sets as follows","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"cm.poset","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The connection matrix itself is given by","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"full_from_sparse(cm.matrix)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"This implies that there are connecting orbits from the unstable  periodic orbit to both the stable equilibrium, and the stable periodic orbit. To visualize these Morse sets, we employ the  commands","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"fname = \"cubicalcircles.pdf\"\nplot_planar_cubical_morse(lc, fname, cm.morse, pv=true)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Morse sets of the planar circles vector field)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In the above example we used the original fixed cubical grid, which is just a scaled version of the grid on the integer lattice. It is also possible to work with a randomized grid, in which the coordinates of the vertices are randomly perturbed. This can be achieved with the following commands:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"nR = 75\nlcR, coordsR = create_cubical_rectangle(nR,nR,p=2,randomize=0.33);\ncoordsRN = convert_planar_coordinates(coordsR,[-3.0,-3.0],[3.0,3.0]);\nmvfR = create_planar_mvf(lcR, coordsRN, circlevf);\ncmR = connection_matrix(lcR, mvfR);\nfnameR = \"cubicalcirclesR.pdf\"\nplot_planar_cubical_morse(lcR, coordsRN, fnameR, cmR.morse, pv=true, vfac=1.1, hfac=2.0)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Morse sets of the planar circles vector field via randomized cubes)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"To constrast the above example with the use of a Delaunay triangulation, we reanalyze the vector field in the following way:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"lc2, coords2 = create_simplicial_delaunay(400, 400, 10, 30, p=2)\ncoords2N = convert_planar_coordinates(coords2,[-3.0,-3.0], [3.0,3.0])\nmvf2 = create_planar_mvf(lc2, coords2N, circlevf)\ncm2 = connection_matrix(lc2, mvf2)\n\nfname2 = \"cubicalcircles2.pdf\"\nplot_planar_simplicial_morse(lc2, coords2N, fname2, cm2.morse, pv=true)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In this case, the Morse sets can be visualized as in the figure.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Morse sets of the planar circles vector field via Delaunay)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Notice that we can also show the individual multivectors in more detail. For the above example, we can plot all multivectors of the multivector field mvf2 which consist of at least 10 cells using the commands","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"mv_indices = findall(x -> (length(x)>9), mvf2)\nlarge_mv = mvf2[mv_indices]\n\nfname3 = \"cubicalcircles3.pdf\"\nplot_planar_simplicial_morse(lc2, coords2N, fname3, large_mv, pv=true)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Large multivectors in the Delaunay multivector field)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Note that in this example, there are only 20 large multivectors.","category":"page"},{"location":"man/conley/#Analysis-of-a-Spatial-System","page":"Conley Theory","title":"Analysis of a Spatial System","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"It is also possible to analyze simple three-dimensional ordinary differential equations in ConleyDynamics.jl. To provide one such example, consider the system","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   beginarrayrcl\n     dotx_1  =  (lambda-1) x_1 - frac3lambda2pi\n       left( (x_1^3 - x_1^2 x_3 + x_2^2 x_3 + 2 x_1\n       left( x_2^2 + x_3^2 right) right) 1ex\n     dotx_2  =  (lambda-4) x_2 - frac3lambda2pi \n       x_2 left( 2 x_1^2 + x_2^2 + 2 x_1 x_3 + 2 x_3^2 right) 1ex\n     dotx_3  =  (lambda-9) x_3 + fraclambda2pi\n       left( x_1 left( x_1^2 - 3 x_2^2 right) - 3 x_3\n       left( 2 x_1^2 + 2 x_2^2 + x_3^2 right) right)\n   endarray","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"This system arises in the study of the so-called Allen-Cahn equation, which is the parabolic partial differential equation given by","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   u_t = Delta u + lambda left( u - u^3 right)\n   text in  Omega = (0pi)\n   quadtext with quad\n   u = 0 text on  partialOmega  ","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"This partial differential equation can be interpreted as an infinite-dimensional system of ordinary differential equations, see for example [SW24, Section 6.1]. For this, one has to expand the unknown function u(tcdot) as a generalized Fourier series with respect to the basis functions","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   varphi_k(x) = sqrtfrac2pi  sin(k pi x)\n   quadtext for quad\n   k in mathbbN  ","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"If one truncates this series representation after three terms, and projects the right-hand side of the partial differential equation onto the linear space spanned by the first three basis functions, then the three coefficients of the approximating sum satisfy the above three-dimensional ordinary differential equation. Thus, this system provides a model for the dynamics of the partial differential equation, at least for sufficiently small values of the parameter lambda. It can be implemented in Julia using the following commands:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"function allencahn3d(x::Vector{Float64})\n    #\n    # Allen-Cahn projection\n    #\n    lambda = 3.0 * pi\n    c      = lambda / pi\n    x1, x2, x3 = x\n    y1 = (lambda-1)*x1 - 1.5*c * (x1*x1*x1-x1*x1*x3+x2*x2*x3+2*x1*(x2*x2+x3*x3))\n    y2 = (lambda-4)*x2 - 1.5*c * x2 * (2*x1*x1+x2*x2+2*x1*x3+2*x3*x3)\n    y3 = (lambda-9)*x3 + 0.5*c * (x1*(x1*x1-3*x2*x2)-3*x3*(2*x1*x1+2*x2*x2+x3*x3))\n    return [y1, y2, y3]\nend","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Notice that for our example we use the parameter value lambda = 3pi. In this particular case, one can show numerically that the system has seven equilibrium solutions. These are approximately given as follows:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Two equilibria pm(145165  0  024396) of index 0.\nTwo equilibria pm(0  109796  0) of index 1.\nTwo equilibria pm(0  0  0307238) of index 2.\nOne equilibrium (0  0  0) of index 3.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In order to find the associated Morse decomposition, one can use the commands","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"N = 25\nbmax = [1.8, 1.5, 1.0]\nlc, coordsI = create_cubical_box(N,N,N);\ncoordsN = convert_spatial_coordinates(coordsI, -bmax, bmax);\nmvf = create_spatial_mvf(lc, coordsN, allencahn3d);","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"These commands create a cubical box of size 25 times 25 times 25 which covers the region -1818 times -1515 times -1010. In addition, we construct a multivector field mvf which encapsulates the possible dynamics of the system. After these preparations, the Morse decomposition can be computed via","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"morsedecomp = morse_sets(lc, mvf);\nmorseinterval = morse_interval(lc, mvf, morsedecomp);\nlci, mvfi = restrict_dynamics(lc, mvf, morseinterval);\ncmi = connection_matrix(lci, mvfi);","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"While the first command finds the actual Morse decomposition, the second one restricts the Lefschetz complex and the multivector field to the smallest isolated invariant set which contains all Morse sets and  connecting orbits between them. The last command finds the connection matrix.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"To see whether the above commands did indeed find the correct dynamical behavior, we first inspect the computed Conley indices of the Morse sets:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"julia> cmi.conley\n7-element Vector{Vector{Int64}}:\n [1, 0, 0, 0]\n [1, 0, 0, 0]\n [0, 1, 0, 0]\n [0, 1, 0, 0]\n [0, 0, 1, 0]\n [0, 0, 1, 0]\n [0, 0, 0, 1]","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Clearly, these are the correct indices based on our numerical information  concerning the stationary states of the system. The connection matrix  is given by:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"julia> full_from_sparse(cmi.matrix)\n7×7 Matrix{Int64}:\n 0  0  1  1  0  0  0\n 0  0  1  1  0  0  0\n 0  0  0  0  1  1  0\n 0  0  0  0  1  1  0\n 0  0  0  0  0  0  1\n 0  0  0  0  0  0  1\n 0  0  0  0  0  0  0","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Thus, there are a total of ten connecting orbits that are induced through algebraic topology. The index 3 equilibrium at the origin has connections to each of the index 2 solutions, which lie above and below the origin in the direction of the x_3-axis. Each of the latter two stationary states has connections to both index 1 equilibria. Finally, each of these is connected to both stable states.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: The dynamics of an Allen-Cahn model)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The location of the computed Morse sets is illustrated in the accompanying figure, which uses x, y, and z instead of the variable names x_1, x_2, and x_3, respectively. Notice that while the stationary states of index 0, 2, and 3 are all well-localized, this cannot be said about the two equilibria of index 1. The computed enclosures for the latter two are elongated cubical sets which are shown along the upper left and lower right of the figure. This overestimation is a result of the use of a strict cubical grid, combined with the small discretization size N = 25. Nevertheless, the above simple code does reproduce the overall global dynamical behavior of the ordinary differential equation correctly.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"One can also compute over Morse intervals, rather than the complete Morse decomposition. The final two images show two views of the  Morse interval which corresponds to one of the index 1 equilibria, and the two stable stationary states. These computations were  performed with the finer resolution N = 51.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Allen-Cahn Morse interval, View 1)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Allen-Cahn Morse interval, View 2)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"We would like to emphasize that there are many techniques in the literature that can be used to identify isolated invariant sets and their Conley indices. Rather than giving a detailed list, we refer to [SW14b] and the references  therein. For example, in [SW14b] ideas from computational topology were used to rigorously establish candidate sets in three dimensions as an isolating block. The associated Matlab code can be found at [SW14a].","category":"page"},{"location":"man/conley/#refconley","page":"Conley Theory","title":"References","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"B. Batko, T. Kaczynski, M. Mrozek and T. Wanner. Linking combinatorial and classical dynamics: Conley             index and Morse decompositions. Foundations of Computational Mathematics 20, 967–1012 (2020).\n\n\n\nC. Conley. Isolated Invariant Sets and the Morse Index (American Mathematical Society, Providence, R.I., 1978).\n\n\n\nT. K. Dey, M. Lipiński, M. Mrozek and R. Slechta. Computing connection matrices via persistence-like reductions. SIAM Journal on Applied Dynamical Systems 23, 81–97 (2024).\n\n\n\nR. Franzosa. The connection matrix theory for Morse decompositions. Transactions of the American Mathematical Society 311, 561–592 (1989).\n\n\n\nS. Harker, K. Mischaikow and K. Spendlove. A computational framework for connection matrix theory. Journal of Applied and Computational Topology 5, 459–529 (2021).\n\n\n\nM. Lipinski, J. Kubica, M. Mrozek and T. Wanner. Conley-Morse-Forman theory for generalized combinatorial             multivector fields on finite topological spaces. Journal of Applied and Computational Topology 7, 139–184 (2023).\n\n\n\nM. Mrozek, R. Srzednicki, J. Thorpe and T. Wanner. Combinatorial vs. classical dynamics: Recurrence. Communications in Nonlinear Science and Numerical Simulation 108, Paper No. 106226, 30 pages (2022).\n\n\n\nM. Mrozek and T. Wanner. Connection Matrices in Combinatorial Topological Dynamics. SpringerBriefs in Mathematics (Springer-Verlag, Cham, 2025).\n\n\n\nE. Sander and T. Wanner. Theory and Numerics of Partial Differential Equations (SIAM, Philadelphia, 2024). In preparation, 1007 pages.\n\n\n\nT. Stephens and T. Wanner. Isolating block validation in Matlab, https://github.com/almost6heads/isoblockval (2014).\n\n\n\nT. Stephens and T. Wanner. Rigorous validation of isolating blocks for flows and               their Conley indices. SIAM Journal on Applied Dynamical Systems 13, 1847–1878 (2014).\n\n\n\n","category":"page"},{"location":"man/references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"man/references/","page":"References","title":"References","text":"P. Alexandrov. Diskrete Räume. Mathematiceskii Sbornik (N.S.) 2, 501–518 (1937).\n\n\n\nB. Batko, T. Kaczynski, M. Mrozek and T. Wanner. Linking combinatorial and classical dynamics: Conley             index and Morse decompositions. Foundations of Computational Mathematics 20, 967–1012 (2020).\n\n\n\nC. Conley. Isolated Invariant Sets and the Morse Index (American Mathematical Society, Providence, R.I., 1978).\n\n\n\nP. Dłotko, T. Kaczynski, M. Mrozek and T. Wanner. Coreduction homology algorithm for regular CW-complexes. Discrete & Computational Geometry 46, 361–388 (2011).\n\n\n\nT. K. Dey, M. Lipiński, M. Mrozek and R. Slechta. Computing connection matrices via persistence-like reductions. SIAM Journal on Applied Dynamical Systems 23, 81–97 (2024).\n\n\n\nP. Dłotko and T. Wanner. Rigorous cubical approximation and persistent homology of             continuous functions. Computers & Mathematics with Applications 75, 1648–1666 (2018).\n\n\n\nH. Edelsbrunner and J. L. Harer. Computational Topology (American Mathematical Society, Providence, 2010).\n\n\n\nH. Edelsbrunner and M. Mrozek. The depth poset of a filtered Lefschetz complex (2023), arXiv:2311.14364v2 [math.AT].\n\n\n\nR. Forman. Combinatorial vector fields and dynamical systems. Mathematische Zeitschrift 228, 629–681 (1998).\n\n\n\nR. Forman. Morse theory for cell complexes. Advances in Mathematics 134, 90–145 (1998).\n\n\n\nR. Franzosa. The connection matrix theory for Morse decompositions. Transactions of the American Mathematical Society 311, 561–592 (1989).\n\n\n\nM. Gameiro, K. Mischaikow and T. Wanner. Evolution of pattern complexity in the Cahn-Hilliard             theory of phase separation. Acta Materialia 53, 693–704 (2005).\n\n\n\nS. Harker, K. Mischaikow and K. Spendlove. A computational framework for connection matrix theory. Journal of Applied and Computational Topology 5, 459–529 (2021).\n\n\n\nT. Kaczynski, K. Mischaikow and M. Mrozek. Computational Homology. Vol. 157 of Applied Mathematical Sciences (Springer-Verlag, New York, 2004).\n\n\n\nT. Kaczynski, M. Mrozek and M. Slusarek. Homology computation by reduction of chain complexes. Computers & Mathematics with Applications 35, 59–70 (1998).\n\n\n\nT. Kaczynski, M. Mrozek and T. Wanner. Towards a formal tie between combinatorial and classical             vector field dynamics. Journal of Computational Dynamics 3, 17–50 (2016).\n\n\n\nS. Lefschetz. Algebraic Topology. Vol. 27 of American Mathematical Society Colloquium Publications (American Mathematical Society, New York, 1942).\n\n\n\nM. Lipinski, J. Kubica, M. Mrozek and T. Wanner. Conley-Morse-Forman theory for generalized combinatorial             multivector fields on finite topological spaces. Journal of Applied and Computational Topology 7, 139–184 (2023).\n\n\n\nW. S. Massey. A Basic Course in Algebraic Topology. Vol. 127 of Graduate Texts in Mathematics (Springer-Verlag, New York, 1991).\n\n\n\nM. Mrozek and B. Batko. Coreduction homology algorithm. Discrete & Computational Geometry 41, 96–118 (2009).\n\n\n\nM. Mrozek, R. Srzednicki, J. Thorpe and T. Wanner. Combinatorial vs. classical dynamics: Recurrence. Communications in Nonlinear Science and Numerical Simulation 108, Paper No. 106226, 30 pages (2022).\n\n\n\nM. Mrozek and T. Wanner. Creating semiflows on simplicial complexes from combinatorial vector fields. Journal of Differential Equations 304, 375–434 (2021).\n\n\n\nM. Mrozek and T. Wanner. Connection Matrices in Combinatorial Topological Dynamics. SpringerBriefs in Mathematics (Springer-Verlag, Cham, 2025).\n\n\n\nJ. R. Munkres. Elements of Algebraic Topology. SpringerBriefs in Mathematics (Addison-Wesley, Menlo Park, 1984).\n\n\n\nE. Sander and T. Wanner. Theory and Numerics of Partial Differential Equations (SIAM, Philadelphia, 2024). In preparation, 1007 pages.\n\n\n\nT. Stephens and T. Wanner. Isolating block validation in Matlab, https://github.com/almost6heads/isoblockval (2014).\n\n\n\nT. Stephens and T. Wanner. Rigorous validation of isolating blocks for flows and               their Conley indices. SIAM Journal on Applied Dynamical Systems 13, 1847–1878 (2014).\n\n\n\nGUDHI Project. GUDHI User and Reference Manual. 3.10.1 Edition (GUDHI Editorial Board, 2024).\n\n\n\n","category":"page"},{"location":"man/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial explains the basic usage of the main components of ConleyDynamics.jl. It is not meant to be exhaustive, and more details will be provided in the more individualized sections. Also, precise mathematical definitions will be delayed until then. The presented examples are taken from the paper [BKMW20] and the book [MW25], with minor modifications.","category":"page"},{"location":"man/tutorial/#Creating-Simplicial-Complexes","page":"Tutorial","title":"Creating Simplicial Complexes","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The fundamental mathematical object for ConleyDynamics.jl is a Lefschetz complex [Lef42]. For now we note that both simplicial complexes and cubical complexes are special cases, and ConleyDynamics.jl provides convenient interfaces for generating them.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"For the sake of simplicity, this tutorial only considers the case of a simplicial complex. Recall that an abstract simplicial complex K is just a collection of finite sets, called simplices, which is closed under taking subsets. In other words, every subset of a simplex is again a simplex. Each simplex sigma has an associated dimension dimsigma, which is one less than the number of its elements. One usually calls simplices of dimension 0 vertices, edges have dimension 1, and simplices of dimension 2 are triangles. It follows easily from these definitions that every simplex is the union of its vertices.  The following notions associated with simplicial complexes are important for this introduction:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A face of a simplex is any of its subsets. Notice that every simplex is a face of itself, and it is the only face that has the same dimension as the simplex. Faces whose dimension is strictly smaller are referred to as proper faces.\nThe boundary of a simplex sigma is the collection of all proper faces of sigma. For a triangle, this amounts to all three edges and all three vertices which are part of it.\nA facet of a simplex sigma is any face tau with dimension dimtau = dimsigma - 1. Notice that the facets of a simplex are the faces in its boundary of maximal dimension.\nThe closure of a subset K_0 of a simplicial complex K consists of the collection of all faces of simplices in K_0, and we denote the closure by mathrmcl K_0.\nA subset K_0 of a simplicial complex K is called closed, if it equals its closure. In other words, K_0 is closed if and only if for every simplex sigma in K_0 all of its boundary simplices are part of K_0 as well. Thus, a closed subset of a simplicial complex is a simplicial complex in its own right.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In ConleyDynamics.jl it is easy to generate a simplicial complex. This requires two objects:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The vertices are described by a vector labels of string labels for the vertices of the simplicial complex. Thus, the length of the vector equals the number of vertices, and the k-th entry is the label for the k-th vertex.\nIn addition, a second vector simplices has to describe enough simplices so that the simplicial complex is determined. This object is a vector of vectors, and the vector simplices[k] describes the index values of all the vertices in the k-th simplex. These indices are precisely the corresponding locations of the vertices in labels.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Simplices via labels\nIt is also possible to specify the list of simplices using a Vector{Vector{String}}, i.e., as a vector of string vectors. In this case, the entry simplices[k] is a list of the labels of the vertices.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Watch the label length\nIt is expected that the labels in labels all have the same number of characters. This is due to the fact that when creating the simplicial complex, ConleyDynamics.jl automatically creates  labels for each of the simplices in K, by concatenating the vertex labels. Not using a fixed label size could lead to  ambiguities, and will therefore raise an error message.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: A first simplicial complex)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The following first example creates a simple simplicial complex.  The complex is shown in the above figure, and it has six vertices which we label by the first six letters.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"using ..ConleyDynamics # hide\nlabels = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\nsimplices = [[\"A\",\"B\"],[\"A\",\"C\"],[\"B\",\"C\"],[\"B\",\"D\"],[\"D\",\"E\",\"F\"]]\nsc = create_simplicial_complex(labels,simplices)\nfieldnames(typeof(sc))","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Based on the simplex specifications, the generated simplicial complex K consists of three edges connecting each of the vertices A, B, and C, a two-dimensional triangle DEF, as well as the edge BD which connects the triangle boundary and the filled triangle. The created struct sc is of type LefschetzComplex, with fieldnames as indicated in the above output. The number of cells in the complex can be seen as follows:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(sc.ncells)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the final simplicial complex has a total of seven edges, since also the edges of DEF are part of the simplicial complex. They are automatically generated by create_simplicial_complex. The dimension of K is the largest simplex dimensions, and can be recalled via","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(sc.dim)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The sc struct contains a vector of labels, which in this case takes the form","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(sc.labels)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, the Lefschetz complex data structure for our simplicial complex K includes the dimensions for the corresponding cells in the integer vector sc.dimensions, a dictionary sc.indices which associates each simplex label with its integer index, and the boundary map sc.boundary which will be described in more detail in Lefschetz Complexes. The latter map is internally stored as a sparse matrix over either a finite field or over the rationals. See also the discussion of Sparse Matrices.","category":"page"},{"location":"man/tutorial/#Computing-Homology-and-Persistence","page":"Tutorial","title":"Computing Homology and Persistence","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Any simplicial complex, and in fact any Lefschetz complex, has an associated homology. Informally, homology describes the connectivity structure of the simplicial complex. More precisely, the homology consists of a sequence of integers, called the Betti numbers, which are indexed by dimension. There are Betti numbers beta_k(K) for every k = 0ldotsdim K. The zero-dimensional Betti number beta_0(K) gives the number of connected components of K, while beta_1(K) counts the number of independent loops that can be found in K. Finally, beta_2(K) equals the number of cavities. In our case, we have","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"homology(sc)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This means that the simplicial complex K has one component, as well as one loop, and no cavities. The function homology returns a vector of integers, whose k-th entry is beta_k-1(K). We would like to point out that in ConleyDynamics.jl all homology computations are performed over fields, and  therefore homology is completely described by the Betti numbers. Two types of fields are supported, and they are selected by the characteristic p in the sparse boundary matrix:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"If p=0, then the homology computation uses the field of rational numbers.\nFor any prime number p, homology is determined over the finite field GF(p) with p elements. ","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"ConleyDynamics.jl also allows for the computation of relative homology. In the case of relative homology, together with the simplicial complex K one has to specify a closed subcomplex K_0. Intuitively, the relative homology H_*(KK_0) is the homology of a new space, which is obtained from K by identifying K_0 to a single point, and then decreasing the zero-dimensional Betti number by 1. Consider for example the following command:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"relative_homology(sc, [1,6])","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In this case, the subcomplex K_0 consists of the two vertices A and F, which are therefore glued together. This leads to zero Betti numbers in dimension 0 and 2 (remember that the zero-dimensional Betti number is decreased by 1!), and a one-dimensional Betti number of 2. The latter is increased by one since we obtain a second loop by moving from A to F = A along the edges AB, BD, and DF.  Another example is the following:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"relative_homology(sc, [\"DE\",\"DF\",\"EF\"])","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Now the subcomplex K_0 consists of the edges DE, DF, and EF – together with the three vertices D, E, and F which are automatically added by relative_homology. Identifying them all to one point creates a hollow two-dimensional sphere, and the relative Betti numbers reflect that fact.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As the above two examples demonstrate, the subcomplex can be specified either as a list of simplex indices, or through the simplex labels.  Moreover, the specfied subspace simplex list is automatically extended by relative_homology to include all simplex faces, i.e., it computes the simplicial closure to arrive at a closed subcomplex. Finally, note that the subcomplex can be empty:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"relative_homology(sc, [])","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected, in this case one obtains the standard homology of sc.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In addition to regular and relative homology, ConleyDynamics.jl can also compute persistent homology. For this, one has to specify a filtration of closed Lefschetz complexes","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"  K_1 subset K_2 subset ldots subset K_m ","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Persistent homology tracks the appearance and disappearance (also often called the birth and death) of topological features as one moves through the complexes in the filtration. In ConleyDynamics.jl, one can specify a Lefschetz complex filtration by assigning the integer k to each simplex that first appears in K_k. Moreover, it is expected that K_m = K. Then the persistent homology is computed via the following command:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"filtration = [1,1,1,2,2,2,1,1,1,3,2,2,2,4]\nphsingles, phpairs = persistent_homology(sc, filtration)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The function returns the persistence intervals, which give the birth and death indices of each topological feature in each dimension. There are two types of intervals:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Intervals of the form ainfty) correspond to topological features that first appear in K_a and are still present in the final complex. The starting indices of such features in dimension k are contained in the list phsingles[k+1].\nIntervals of the form ab) correspond to topological features that first appear in K_a and first disappear in K_b. The corresponding pairs (a,b) in dimension k are contained in the list phpairs[k+1].","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In our above example, one observes intervals 1infty) in dimensions zero and one – and these correspond to a connected component and the loop generated by the edges AB, AC, and BC. These appear first in K_1 and are still present in K_4. The interval 23) in dimension zero represents the new component created by K_2, and it disappears through merging with the older component from K_1 when the edge BD is introduced with K_3. Similarly, the interval 24) in dimension one is the loop created by the triangle DE, DF, and EF in K_2, which disappears with the introduction of the triangle DEF in K_4. Note that the interval death times respect the elder rule: When for example a component disappears through merging, the younger interval gets killed, and the older one continues to live. Similarly in higher dimensions.","category":"page"},{"location":"man/tutorial/#Forman-Vector-Fields","page":"Tutorial","title":"Forman Vector Fields","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The main focus of ConleyDynamics.jl is on the study of combinatorial topological dynamics on Lefschetz complexes. While the phase space as Lefschetz complex has been discussed above, albeit only for the special case of a simplicial complex, the dynamics part can be given in the simplest form by a combinatorial vector field, also called a Forman vector field [For98a, For98b]. We will soon see that such vector fields are a more restrictive version of multivector fields, but they are easier to start with.  The following command defines a simple Forman vector field on our sample simplicial complex K from above:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"formanvf = [[\"A\",\"AC\"],[\"B\",\"AB\"],[\"C\",\"BC\"],[\"D\",\"BD\"],[\"E\",\"DE\"]]","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The Forman vector field formanvf is viualized in the accompanying figure.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: A first Forman vector field)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"According to the figure, a Forman vector field is comprised of arrows, as well as critical cells which are indicated by red dots. Every simplex of the underlying simplicial complex is either critical, or it is contained in a unique arrow. In other words, the collection of critical cells and arrows forms a partition of the simplicial complex K. Arrows always have to consist of precisely two simplices: The source of the arrow is a simplex sigma^-, while its target is a second simplex sigma^+. These two simplices have to be related in the sense that sigma^- is a facet of sigma^+.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As the above Julia code shows, a forman vector field is described by a vector of string vectors, where each of the latter contains the labels of the two simplices making up an arrow. Note that the critical cells are not explicitly listed, as any simplex of K that is not part of a vector is automatically assumed to be critical. Alternatively, one could define the Forman vector field as a Vector{Vector{Int}}, if the labels are replaced by the corresponding indices in sc.indices.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Intuitively, the visualization of our sample Forman vector field formanvf induces the following dynamical behavior on the simplicial complex sc:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Critical cells can be though of as equilibrium states for the dynamics, i.e., they contain a stationary solution. However, depending on their dimension they can also exhibit nonconstant dynamics – which in backward time converges to the equilibrium, and in forward time flows towards the boundary of the simplex.\nArrow sources always lead to flow into the interior of their target simplex sigma^+.\nArrow targets create flow towards the boundary of sigma^+, except towards the source facet sigma^-.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In the above figure, for example, the simplex EF is a critical cell, so it contains an equilibrium. At the same time, it also allows for flow towards the boundary, which consists of the vertices E and F.  A solution flowing to the former then has to enter DE, flow through D to BD, before entering the periodic orbit given by","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"   B to AB to A to AC to C to BC to B to AB to ldots","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This heuristic description can be made precise. It was shown in [MW21] that for every Forman vector field on a simplicial complex there exists a classical dynamical system which exhibits dynamics consistent with the above interpretation.","category":"page"},{"location":"man/tutorial/#Isolated-Invariant-Sets","page":"Tutorial","title":"Isolated Invariant Sets","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The global dynamical behavior of a Forman vector field on a simplicial complex can be described by first decomposing it into smaller building blocks. An invariant set is a subset S subset K of the simplicial complex such that for every simplex sigma in S there exists a solution through sigma which is contained in S and which exists for all forward and backward time. In our example the following are sample invariant sets:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Every critical cell sigma by itself is an invariant set, since we can choose the constant solution sigma in the above definition. Thus, also every union of critical cells is invariant.\nThe periodic orbit S_P =  A B C AB AC BC  is an invariant set, since the periodic orbit mentioned earlier exists for all forward and backward time in S_P and passes through every simplex of the orbit.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"While it is tempting to try to decompose the dynamics into invariant sets and \"everything else\", Conley realized that a better theory can be built around invariant sets which are isolated [Con78]. In our combinatorial setting, an isolated invariant set is an invariant set S subset K with the following two additional properties:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The set S is locally closed, i.e., the associated set mathrmmo S = mathrmcl S setminus S is closed in the simplicial complex. Recall that the closure mathrmcl A of a set A subset K consists of all simplices which are subsets of simplices in A, and a set is closed if it equals its closure. The set mathrmmo S is called the mouth of S.\nThe set S is compatible with the Forman vector field, i.e., the set is the union of critical cells and arrows. In other words, if one of the  arrow ends is contained in S, then so is the other.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"One can easily see that the periodic orbit S_P is an isolated invariant set, since it is compatible and closed – and therefore mathrmmo S_P = emptyset is closed. Similarly, the single critical simplex S_1 =  DEF  is an isolated invariant set, since in this case the set mathrmmo S_1 =  D E F DE DF EF  is closed, and S_1 is compatible. On the other hand, the invariant set S_2 =  DEF F  is not an isolated invariant set, since the mouth mathrmmo S_2 =  D E DE DF EF  is not closed – despite the fact that S_2 is compatible.  For an example of an invariant set which has a closed mouth but is not compatible, see [KMW16, Figure 5].","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"It follows from the definition of isolation that for every isolated invariant set S subset K the two sets mathrmcl S and mathrmmo S are closed, and that the latter is a (possibly empty) subset of the former. Thus, the relative homology of this pair is defined and we let","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"  CH_*(S) = H_*(mathrmcl S mathrmmo S)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"denote the Conley index of the isolated invariant set. The Conley index can be computed using the command conley_index. For the three critical cells F, DF, and DEF one obtains the following Conley indices:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(conley_index(sc, [\"F\"]))\nprintln(conley_index(sc, [\"DF\"]))\nprintln(conley_index(sc, [\"DEF\"]))","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In other words, the Conley index of a critical cell of dimension k has Betti number beta_k = 1, while the remaining Betti numbers vanish. This is precisely the relative homology of a k-dimensional sphere with respect to a point on the sphere. On the other hand, for the Conley index of the periodic orbit S_P one obtains:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"conley_index(sc, [\"AB\", \"AC\", \"BC\", \"A\", \"B\", \"C\"])","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This Conley index is nontrivial in dimensions 0 and 1. This is exactly the Conley index of an attracting periodic orbit in classical dynamics.","category":"page"},{"location":"man/tutorial/#Connection-Matrices","page":"Tutorial","title":"Connection Matrices","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"One of the main features of ConleyDynamics.jl is its capability to take a given combinatorial vector or multivector field on an arbitrary Lefschetz complex and determine its global dynamical behavior. This is done by computing the connection matrix, which in our setting is discussed in detail in [MW25].  For the sample simplicial complex sc and the Forman vector field formanvf the connection matrix information can be determined as follows:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cm = connection_matrix(sc, formanvf)\nfieldnames(typeof(cm))","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This command calculates the connection matrix over the finite field GF(2) = mathbb Z_2. The base field for this computation is determined by the data type of the boundary matrix in the underlying simplicial complex sc. By default, if one uses the function create_simplicial_complex without specifying the field characteristic p, the simplicial complex is created over the finite field mathbbZ_2, i.e., with p=2.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The connection_matrix function returns a struct which contains the following information regarding the global dynamics of the combinatorial dynamical system:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The field cm.morse contains the Morse decomposition of the Forman vector field. This is a collection of isolated invariant sets which capture all recurrent behavior. Outside of these sets, the dynamics is gradient-like, i.e., it moves from one Morse set to another.\nSince each of the Morse sets is an isolated invariant set, they all have an associated Conley index. These are contained in the field cm.conley.\nIn addition, the struct cm contains information on the actual connection matrix in the field cm.matrix. While the field contains the matrix, the rows and columns of the connection matrix correspond to the simplices in the underlying simplicial complex sc listed in cm.labels. These simplices represent the basis for the homology groups of all the Morse sets. Moreover, a nonzero entry in the connection matrix indicates that there has to be a connecting orbit between the Morse set containing the column label and the Morse set containing the row label.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The remaining field names of the struct cm are described in the section on Conley Theory.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"For our example system, the Morse sets are given by","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cm.morse","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"There are five of them: The stable periodic orbit S_P mentioned earlier, the stable critical state F, the unstable equilibria DF and EF, as well as the two-dimensional unstable critical cell DEF.  The associated Conley indices are","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cm.conley","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Clearly these indices are exactly as described in the homology section, since the underlying field is still mathbbZ_2, as determined by sc. For an example which involves computations over different fields, which also lead to different Conley indices, we refer to the function example_moebius.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, the connection matrix itself is contained in cm.matrix. Since internally the connection matrix is stored in a sparse format, we display it after conversion to a full matrix:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"full_from_sparse(cm.matrix)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to see which simplices represent the columns of the matrix, we use the command","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(cm.labels)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The right-most column contains two nonzero entries, and they imply that there are connecting orbits between the critical cell DEF and the two critical cells DF and EF, respectively. The second-to-last column establishes connecting orbits originating from EF. One of these ends at the critical vertex F, while the other one leads to A. Notice, however, that since A is part of the Morse set S_P, i.e., the periodic orbit, this second nonzero entry in the column implies the existence of a heteroclinic orbit between the equilibrium and the complete periodic solution. Similarly, there are connections between DF and both F and the periodic orbit, in view of the fourth column of the connection matrix.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A description of the remaining fields of cm can also be found in the API entry for connection_matrix. We would like to emphasize again that internally, all computations necessary for finding the connection matrix are performed automatically over the rationals or over the finite field GF(p). The choice depends on the data type of the boundary matrix for the underlying Lefschetz complex, in this case the simplicial complex sc. ","category":"page"},{"location":"man/tutorial/#Multivector-Fields","page":"Tutorial","title":"Multivector Fields","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As second example of this tutorial we turn our attention to the logo of ConleyDynamics.jl. It shows a simple multivector field on a simplicial complex, and both the simplicial complex sclogo and the multivector field mvflogo can be defined using the commands","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"using ..ConleyDynamics # hide\nlabels = [\"A\",\"B\",\"C\",\"D\"]\nsimplices = [[\"A\",\"B\",\"C\"],[\"B\",\"C\",\"D\"]]\nsclogo = create_simplicial_complex(labels,simplices)\nmvflogo = [[\"A\",\"AB\"],[\"C\",\"AC\"],[\"B\",\"BC\",\"BD\",\"BCD\"]]","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This example is taken from [MW25, Figure 2.1], and is visualized in the accompanying figure.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: The logo multivector field)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The multivector field mvflogo clearly has a different structure from the earlier Forman vector field. While the latter consists exclusively of arrows and critical cells, the former is made up of multivectors. In this context a multivector is a collection of simplices which form a locally closed set, as defined earlier in the tutorial. One can show that in the case of a simplicial complex, this is equivalent to requiring that if sigma_1 subset sigma_2 are two simplices in the multivector, then so are all simplices tau with sigma_1 subset tau subset sigma_2.  In other words, multivectors are convex with respect to simplex inclusion,  i.e., with respect to the face relation.  A multivector field is then a partition of the simplicial complex into multivectors. See [LKMW23] for more details.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"It is not difficult to see that every Forman vector field is a multivector field. Every critical cell consists of just one simplex, so it trivially satisfies the above convexity condition. In addition, the two simplices contained in an arrow do not allow for any simplex sigma^- subset tau subset sigma^+ apart from tau = sigma^pm.  As in the case of Forman vector fields, multivector fields in ConleyDynamics.jl only need to list multivectors containing at least two simplices. Any simplex not contained on the list automatically gives rise to a one-element multivector.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"One important difference between Forman vector fields and multivector fields is the definition of criticality. In the multivector field case, the types of multivectors are distinguished as follows:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A multivector V is called critical, if the relative homology H_*(mathrmcl V mathrmmo V) is not trivial, i.e., at least one Betti number is nonzero.\nA multivector V is called regular, if the relative homology H_*(mathrmcl V mathrmmo V) is trivial, i.e., it vanishes in all dimensions.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"One can show that in the case of a Forman vector field, critical cells are always critical in the above sense, while arrows are always regular. In our above example mvflogo, all three multivectors which are not singletons are regular. For example, the following computation shows that the cell ABC is a critical cell:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cl1, mo1 = lefschetz_clomo_pair(sclogo, [\"ABC\"])\nrelative_homology(sclogo, cl1, mo1)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The first command creates the closure-mouth pair associated with the cell ABC, i.e., the variable cl1 is the closed triangle, while mo1 is the closed boundary of the triangle. The next  command determines the relative homology. Notice that this employs another method under the name relative_homology, in contrast to the one used earlier in this tutorial. For more details, see Homology Functions.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, since every multivector is locally closed, one can also use the function conley_index for the same computation:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"conley_index(sclogo, [\"ABC\"])","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, the next sequence of commands verifies that the third nontrivial multivector mvflogo[3] is indeed a regular multivector:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cl2, mo2 = lefschetz_clomo_pair(sclogo, mvflogo[3])\nrelative_homology(sclogo, cl2, mo2)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The global dynamics can again be determined using the function connection_matrix:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cmlogo = connection_matrix(sclogo, mvflogo)\ncmlogo.morse","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As it turns out, our logo gives rise to three Morse sets, which in fact partition the simplicial complex. Their Conley indices are given by","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cmlogo.conley","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, the connection matrix has the form","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"full_from_sparse(cmlogo.matrix)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice that in this example, only the connection between the Morse set ABC and the large index 1 Morse set comprising almost all  of the simplicial complex can be detected algebraically. In fact, there are two connections between the large Morse set and the stable equilibrium D, and they cancel algebraically.","category":"page"},{"location":"man/tutorial/#Analyzing-Planar-Vector-Fields","page":"Tutorial","title":"Analyzing Planar Vector Fields","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Our third and last example of the tutorial briefly indicates how ConleyDynamics.jl can be used to analyze the global dynamics of certain planar ordinary differential equations. For this, consider the planar system given by","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"   beginarrayrcl\n     dotx_1  =  x_1 left( 1 - x_1^2 - 3 x_2^2 right) 1ex\n     dotx_2  =  x_2 left( 1 - 3 x_1^2 - x_2^2 right)\n   endarray","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The right-hand side of this vector field can be implemented using the Julia function","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"using ..ConleyDynamics # hide\nusing Random # hide\nRandom.seed!(1234) # hide\nfunction planarvf(x::Vector{Float64})\n    #\n    # Sample planar vector field with nontrivial Morse decomposition\n    #\n    x1, x2 = x\n    y1 = x1 * (1.0 - x1*x1 - 3.0*x2*x2)\n    y2 = x2 * (1.0 - 3.0*x1*x1 - x2*x2)\n    return [y1, y2]\nend","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"To analyze the global dynamics of this vector field, we first create a Delaunay triangulation of the square -32 32^2 using the commands","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"lc, coords = create_simplicial_delaunay(300, 300, 10, 30);\ncoordsN = convert_planar_coordinates(coords,[-1.5,-1.5], [1.5,1.5]);\ncx = [c[1] for c in coordsN];\n(minimum(cx), maximum(cx))","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The first command generates the triangulation in a square box with  side length 300, while trying to keep a minimum distance of about 10 between vertices. Once this has been accomplished, the second  command transforms the coordinates to the desired square domain. As the last two commands show, the resulting x-coordinates do indeed lie between -3/2 and 3/2.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Next we can create a multivector field which describes the flow behavior through the edges of the triangulation. Basically, for each edge which is traversed in only one direction, the corresponding multivector respects this unidirectionality, while non-transverse edges lead to multivectors which allow for flow in both directions between the adjacent triangles. This is achieved with the commands","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"mvf = create_planar_mvf(lc, coordsN, planarvf);\nmvf[1:3]","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The first command generates the multivector field, while the second one merely displays the first three resulting multivectors. Note that if the discretization is too coarse, this might lead to large multivectors that cannot resolve the underlying dynamics. In our case, we can analyze the global dynamics of the created multivector field using the commands","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cm = connection_matrix(lc, mvf);\ncm.conley","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As the output shows, this planar system has nine isolated invariant sets:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"One unstable equilibrium of index 2,\nfour unstable equilibria of index 1,\nand four stable equilibria.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"More precisely, this computation does not in fact establish the existence of these equilibria, but of corresponding isolated invariant sets which have the respective Conley indices. The connection matrix is given by","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"full_from_sparse(cm.matrix)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"It shows that there are twelve connecting orbits that are forced by the algebraic topology. Finally, we can visualize the Morse sets using the command","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"fname = \"tutorialplanar.pdf\"\nplot_planar_simplicial_morse(lc, coordsN, fname, cm.morse, pv=true)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Morse sets of a planar vector field)","category":"page"},{"location":"man/tutorial/#reftutorial","page":"Tutorial","title":"References","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"B. Batko, T. Kaczynski, M. Mrozek and T. Wanner. Linking combinatorial and classical dynamics: Conley             index and Morse decompositions. Foundations of Computational Mathematics 20, 967–1012 (2020).\n\n\n\nC. Conley. Isolated Invariant Sets and the Morse Index (American Mathematical Society, Providence, R.I., 1978).\n\n\n\nR. Forman. Combinatorial vector fields and dynamical systems. Mathematische Zeitschrift 228, 629–681 (1998).\n\n\n\nR. Forman. Morse theory for cell complexes. Advances in Mathematics 134, 90–145 (1998).\n\n\n\nT. Kaczynski, M. Mrozek and T. Wanner. Towards a formal tie between combinatorial and classical             vector field dynamics. Journal of Computational Dynamics 3, 17–50 (2016).\n\n\n\nS. Lefschetz. Algebraic Topology. Vol. 27 of American Mathematical Society Colloquium Publications (American Mathematical Society, New York, 1942).\n\n\n\nM. Lipinski, J. Kubica, M. Mrozek and T. Wanner. Conley-Morse-Forman theory for generalized combinatorial             multivector fields on finite topological spaces. Journal of Applied and Computational Topology 7, 139–184 (2023).\n\n\n\nM. Mrozek and T. Wanner. Creating semiflows on simplicial complexes from combinatorial vector fields. Journal of Differential Equations 304, 375–434 (2021).\n\n\n\nM. Mrozek and T. Wanner. Connection Matrices in Combinatorial Topological Dynamics. SpringerBriefs in Mathematics (Springer-Verlag, Cham, 2025).\n\n\n\n","category":"page"},{"location":"man/homology/#Homology","page":"Homology","title":"Homology","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Conley's theory for the qualitative study of dynamical systems is based on fundamental concepts from algebraic topology. One of these is homology, which studies the topological properties of spaces using algebraic means. As part of ConleyDynamics.jl a number of homology methods are included. It should be noted that these algorithms are not meant for truly large-scale problems, but mostly for illustrative purposes. They are based on the persistence algorithm described in [EH10], and have been extended to work for arbitrary Lefschetz complexes over either the rationals or a finite field of prime order. For more serious applications one could use professional implementations such as Gudhi, see [GUD24].","category":"page"},{"location":"man/homology/#Lefschetz-Complex-Homology","page":"Homology","title":"Lefschetz Complex Homology","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The most important notion of homology used in ConleyDynamics.jl is Lefschetz homology. It generalizes both simplicial homology as  described in [Mun84], and cubical homology in the sense of [KMM04]. In order to fix our notation, we provide a brief introduction in the following. For more details, see [Lef42].","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"As we saw earlier, a Lefschetz complex X is a collection of cells with associated nonnegative dimensions, together with a boundary map partial which is induced by the incidence coefficient map kappa. The fundamental idea behind homology is to turn this underlying information into an algebraic form in such a way that the boundary map becomes a linear map. For this, define the k-th chain group as","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   C_k(X) = left sum_i=1^m alpha_i sigma_i   \n   alpha_1 ldots alpha_m in F text and \n   sigma_1 ldots sigma_m in X_k right ","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Since X_k denotes the collection of all cells of dimension k, this definition can be rephrased by saying that C_k(X) consists of all formal linear combinations of k-dimensional cells with coefficients in the underlying field F. It is not difficult to see that C_k(X) is in fact a vector space over F. Moreover, its dimension is equal to the number of k-dimensional cells in X. The collection of all chain groups is C(X) = (C_k(X))_k in mathbb Z, where we let C_k(X) =  0  for all k  0 and k  dim X.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"We now turn our attention to the boundary map. It was already explained how the incidence coefficient map kappa can be used to define the boundary partial sigma in C_k-1(X) for every k-dimensional cell sigma in X_k. If one further defines","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   partial left( sum_i=1^m alpha_i sigma_i right) =\n   sum_i=1^m alpha_i partialsigma_i in C_k-1(X)\n   quadtext for quad\n   sum_i=1^m alpha_i sigma_i in C_k(X)  ","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"then one obtains a map partial  C_k(X) to C_k-1(X). It is not  difficult to verify that this map is both well-defined and linear. Sometimes, we write partial_k instead of partial to emphasize that we consider the boundary map defined on the k-th chain group C_k(X).","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Altogether, the above definitions have equipped us with a sequence of vector spaces and maps between them in the form","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   ldots stackrelpartial_k+2longrightarrow\n   C_k+1(X) stackrelpartial_k+1longrightarrow\n   C_k(X) stackrelpartial_klongrightarrow\n   C_k-1(X) stackrelpartial_k-1longrightarrow ldots\n   stackrelpartial_1longrightarrow\n   C_0(X) stackrelpartial_0longrightarrow  0 \n   stackrelpartial_-1longrightarrow ldots ","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"and the properties of a Lefschetz complex further imply that","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   partial_k circ partial_k+1 = 0\n   quadtext for all quad\n   k in mathbb Z ","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In other words, the pair (C(X) partial) is a chain complex, which consists of a sequence of vector spaces over F and linear maps between them. Recall from linear algebra that any linear map induces two important subspaces, which in the context of algebraic topology are given special names as follows:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The elements of the subspace Z_k(X) = mathrmker partial_k are called the k-cycles of X.\nThe elements of the subspace B_k(X) = mathrmim partial_k+1 are called the k-boundaries of X.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Both of these vector spaces are subspaces of the k-th chain group C_k(X). Furthermore, in view of the above identity partial_k circ partial_k+1 = 0, one immediately obtains the subspace inclusion B_k(X) subset Z_k(X). We can therefore define the quotient space","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   H_k(X)  = \n   Z_k(X)  B_k(X)  = \n   mathrmkerpartial_k  mathrmimpartial_k+1 ","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This vector space is called the k-th homology group of the Lefschetz complex X. It is again a vector space over F, and therefore its dimension provides important information. In view of this, the dimension of the k-th homology group H_k(X) is called the k-th Betti number of X, and abbreviated as beta_k(X) = dim H_k(X).","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In order to shed some light on the actual meaning of homology, and in particular the Betti numbers, we turn to an example. Consider the simplicial complex sc that was already introduced in the Tutorial, and which can be created using the commands","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"labels = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\nsimplices = [[\"A\",\"B\"],[\"A\",\"C\"],[\"B\",\"C\"],[\"B\",\"D\"],[\"D\",\"E\",\"F\"]]\nsc = create_simplicial_complex(labels,simplices)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This two-dimensional simplicial complex is shown in the figure.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"(Image: The simplicial complex from the tutorial)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"For simplicity, we consider the associated Lefschetz complex X over the field F = GF(2). Then chains in a chain group are just a sum of individual cells of the same dimension.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In this simple example, one can determine the cycles and boundaries for k=1 directly. The vector space Z_1(X) of 1-cycles contains the two nonzero chains c_1 = mathrmAB + mathrmBC + mathrmAC and c_2 = mathrmDE + mathrmEF + mathrmDF, since one can verify that partial c_1 = partial c_2 = 0. These are, however, not all nontrivial 1-cycles, as their sum c_1 + c_2 is another one. Thus, the first cycle group is given by Z_1(X) =  0 c_1 c_2 c_1 + c_2 . It is a vector space over F = GF(2) of dimension two, and any two nonzero elements of Z_1(X) form a basis. What about the 1-boundaries? The simplicial complex X contains only one 2-cell, namely mathrmDEF, and its boundary is given by the chain c_2. Thus, the first boundary group is given by B_1(X) =  0 c_2 , which is a one-dimensional vector space over F.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Combined, one can show that the first homology group H_1(X) consists of the two equivalence classes","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   H_1(X) = left B_1(X)   c_1 + B_1(X) right  ","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"where the class B_1(X) is the zero element in H_1(X). This implies that the first homology group is one-dimensional, and we have beta_1(X) = 1. In some sense, the basis element of H_1(X), which is the unique nonzero equivalence class given by c_1 + B_1(X), is represented by the cycle c_1.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The above mathematically precise description can be summarized as follows. All three nontrivial cycles in Z_1(X) have the potential to enclose two-dimensional holes in the simplicial complex X, since they are chains without boundary. However, some of these potential holes have been filled in by two-dimensional cells. Thus, while c_1 does indeed represent a hole, the chain c_2 does not, since its interior is filled in by mathrmDEF. Note that the cycle c_1 + c_2 does not create a second hole, since we have (c_1 + c_2) - c_1 = c_2 in B_1(X). In other words, the first Betti number counts the number of independent holes in the complex X.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"One can extend this discussion also to other dimensions and to general Lefschetz complexes X. In this way, one obtains the following informal interpretations of the Betti numbers:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"beta_0(X) counts the number of connected components of X,\nbeta_1(X) counts the number of independent holes  in X,\nbeta_2(X) counts the number of independent cavities in X.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In general, one can show that beta_k(X) represents the number of independent k-dimensional holes in the Lefschetz complex X. For more details, see [Mun84].","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The package ConleyDynamics.jl provides one function to compute standard homology:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"homology expects one input argument, which has to be  of the Lefschetz complex type LefschetzComplex. It returns a vector betti of integers, whose length is one more than  the dimension of the complex. The k-th Betti number beta_k(X) is returned in betti[k+1].","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"We would like to point out that the field F is implicit in the data structure for the Lefschetz complex X, and therefore it does not have to be specified. It can always be queried using the function lefschetz_field. For the above example one obtains","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> homology(sc)\n3-element Vector{Int64}:\n 1\n 1\n 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This clearly gives the correct Betti numbers, as we have already seen that this simplicial complex has one hole, and it is obviously connected.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"(Image: Sample simplicial complex)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The simplicial complex shown in the second figure can be created using the commands","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"labels2 = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\"]\nsimplices2 = [[\"A\",\"B\"],[\"A\",\"F\"],[\"B\",\"F\"],[\"B\",\"C\",\"G\"],[\"D\",\"E\",\"H\"],[\"C\",\"D\"],[\"G\",\"H\"]]\nsc2 = create_simplicial_complex(labels2,simplices2)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"and its homology can then be determined as follows:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> homology(sc2)\n3-element Vector{Int64}:\n 1\n 2\n 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This complex is also connected, and therefore one has beta_0(X) = 1. However, this time one obtains two independent holes, which results in beta_1(X) = 2.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"(Image: Sample cubical complex)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Similarly, the cubical complex depicted in the next figure can be generated via","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"cubes = [\"00.11\", \"01.01\", \"02.10\", \"11.10\", \"11.01\", \"22.00\", \"20.11\", \"31.01\"]\ncc = create_cubical_complex(cubes)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"and its Betti numbers are given by","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> homology(cc)\n3-element Vector{Int64}:\n 2\n 1\n 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In  this case, the complex has two components and one hole. As a final example, consider a simplicial complex which consists of the manifold boundary of a  single cube. Such a complex can be generated using the commands","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"cc2,~ = create_cubical_box(1, 1, 1)\nmbcells = manifold_boundary(cc2)\ncc2bnd = lefschetz_subcomplex(cc2, mbcells)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This time, the homology of the resulting cubical complex is given by the Betti numbers","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> homology(cc2bnd)\n3-element Vector{Int64}:\n 1\n 0\n 1","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This complex is connected and has no holes, but it does have one cavity. As shown, these observations translate into the Betti numbers beta_0(X) = 1 and beta_1(X) = 0, as well as beta_2(X) = 1.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Beyond these simple illustrative examples, homology can be a useful tool in a variety of applied settings. For example, it can be used to quantify the evolution of material microstructures during phase separation processes, see for example [GMW05].","category":"page"},{"location":"man/homology/#Relative-Homology","page":"Homology","title":"Relative Homology","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"For the definition of the Conley index of an isolated invariant set another notion of homology is essential, namely relative homology. For this, we assume that X is a Lefschetz complex, and Y subset X is a closed subset. In other words, for every  cell in Y, all of its faces are contained in Y as well.  Then relative homology defines a sequence of groups H_k(XY) for k in mathbbZ which basically measures the topological properties of X if the subset Y is contracted to a point and then forgotten.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This admittedly very vague definition can be made precise in a number of ways. Two of these can easily be described:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"We have already seen that any locally closed subset of a Lefschetz complex is again a Lefschetz complex. Since the subset Y subset X is closed, its complement X setminus Y is open, and hence locally closed as well. Thus, the complement X setminus Y is again a Lefschetz complex. It has been shown in [MB09, Theorem 3.5] that then\n   H_k(XY) cong H_k(X setminus Y)\n   quadtext for all quad\n   k in mathbbZ \nIn other words, the relative homology of the pair (XY) is just the regular homology of the Lefschetz complex given by the set X setminus Y, with the incidence coefficient map inherited  from X.\nOn a more topological level, one can also think of the relative homology of (XY) in the following way. In the complex X, identify all cells in Y to a single point, in the sense of the quotient space X  Y defined in a standard topology course. Then one can show that\n   H_k(XY) cong tildeH_k(X  Y)\n   quadtext for all quad\n   k in mathbbZ \nwhere tildeH_k(Z) denotes the reduced homology of a space Z. While the details of this latter notion of homology can be found in [Mun84, Section 7], for our purposes it suffices to note that the Betti numbers in reduced homology can be obtained from the ones in regular homology by decreasing the 0-th Betti number by 1, and keeping all other Betti numbers unchanged.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The precise mathematical definition of relative homology can be found in [Mun84, Section 9], and it is briefly introduced in the following. Since the k-th chain group of a Lefschetz complex consists of all formal linear combinations of k-dimensional cells, one can consider the vector space C_k(Y) as a subspace of C_k(X). Thus, it makes sense to form the quotient groups","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   C_k(XY) = C_k(X)  C_k(Y)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"as in linear algebra. Moreover, if one considers a class x in C_k(XY) represented by some x in C_k(X), then the definition","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   partial x = partial x in C_k-1(X Y)\n   quadtext for quad\n   x in C_k(X Y)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"gives a well-defined linear map partial  C_k(XY) to C_k-1(XY) which satisfies partial circ partial = 0. In other words, the collection (C_k(XY))_k in mathbbZ equipped with this boundary operator partial is a chain complex, and its associated homology groups H_k(XY) are called the relative homology groups of the pair (XY). Notice that by forming the quotient spaces C_k(X)  C_k(Y), the chains in the subspace are all identified and set to zero, as mentioned earlier.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In ConleyDynamics.jl, relative homology can be computed using relative_homology. There are two possible ways to invoke this function:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The method relative_homology(lc::LefschetzComplex, subc::Cells) expects a Lefschetz complex lc which represents X, together with a list of cells subc. The closure of this cell list determines the closed subcomplex Y.\nThe method relative_homology(lc::LefschetzComplex, subc::Cells, subc0::Cells) expects an ambient Lefschetz complex specified by the argument lc. The Lefschetz complex X is then the closure of the cell list subc, while the subcomplex Y is given by the closure of the cell list subc0. These closures are automatically computed by the function.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Both versions of relative_homology return the relative  homology as a vector betti of Betti numbers, where betti[k] is the Betti number in dimension k-1. Notice also that the necessary cell list arguments have to be variables of the type Cells = Union{Vector{Int},Vector{String}}, i.e., they can be given in either label or index form.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"(Image: Sample simplicial complex)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In order to briefly illustrate the different usages of the command relative_homology, we consider again the simplicial complex shown in the figure, which can be generated using the commands","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"labels2 = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\"]\nsimplices2 = [[\"A\",\"B\"],[\"A\",\"F\"],[\"B\",\"F\"],[\"B\",\"C\",\"G\"],[\"D\",\"E\",\"H\"],[\"C\",\"D\"],[\"G\",\"H\"]]\nsc2 = create_simplicial_complex(labels2,simplices2)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"If we identify the vertices mathrmA and mathrmE, then an additional loop is created along the bottom of the original simplicial complex. This leads to the following relative homology:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> relative_homology(sc2, [\"A\",\"E\"])\n3-element Vector{Int64}:\n 0\n 3\n 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Note that the 0-th Betti number becomes zero, since these identified vertices are considered as zero in the chain group C_0(XY). On the other hand, if we consider the boundary of the triangle mathrmDEH as the subcomplex Y, then one obtains:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> relative_homology(sc2, [\"DE\",\"DH\",\"EH\"])\n3-element Vector{Int64}:\n 0\n 2\n 1","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Again, the 0-th Betti number is reduced by one. But this time, the first Betti number does not change, as no new holes are created. Nevertheless, collapsing the boundary of the triangle to a point does create a cavity, and therefore the 2-nd Betti number is now one. One can also just consider the closure of the triangle  mathrmBCG as a Lefschetz complex X, and use its boundary as subcomplex Y. In this case we get:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> relative_homology(sc2, [\"BCG\"], [\"BC\",\"BG\",\"CG\"])\n3-element Vector{Int64}:\n 0\n 0\n 1","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This is the reduced homology of a two-dimensional sphere, which is the topological space obtained from the quotient space X  Y. As our final example, consider the closed edge mathrmAB as Lefschetz complex X, and the vertex mathrmB as subcomplex Y, then the relative homology of the pair (XY) is given by","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> relative_homology(sc2, [\"AB\"], [\"B\"])\n3-element Vector{Int64}:\n 0\n 0\n 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In this case, all Betti numbers are zero. This can also be seen by recalling that this relative homology is isomorphic to the relative homology of the two-element Lefschetz complex which consists only of the edge mathrmAB and the vertex mathrmA:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> homology(lefschetz_subcomplex(sc2, [\"A\",\"AB\"]))\n2-element Vector{Int64}:\n 0\n 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Note that one obtains a Betti number vector of length two, since this subcomplex has dimension one.","category":"page"},{"location":"man/homology/#Persistent-Homology","page":"Homology","title":"Persistent Homology","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Even though the notion of persistence is not strictly necessary for the study of combinatorial topological dynamics, the package ConleyDynamics.jl provides rudimentary support for the computation of persistence intervals for filtrations of Lefschetz complexes. A detailed introduction to persistence can be found in the book [EH10], and we briefly provide an intuitive definition and some examples below.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Persistent homology is concerned with the creation and destruction of topological features in a sequence of nested Lefschetz complexes. More precisely, consider the sequence of Lefschetz complexes","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   X^(1) subset X^(2)\n   subset ldots subset X^(n) ","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"where we assume that X^(k) is closed in X^(n) for  all 1 le k  n. This is called a filtration of Lefschetz complexes. As we have seen above, every one of the complexes X^(k) has associated homology groups, and the notion of persistence is concerned with how these groups change as k is increased from 1 to n. More precisely, this is based on the following intuition:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"For k = 1, the Betti numbers of the Lefschetz complex X^(1) describe how many nontrivial holes the complex has in each dimension. Each of these holes is represented by a cycle which generates the associated homology class. One then says that each of these homology classes is born at k=1.\nAs one passes from the complex X^(k) to the  complex X^(k+1), for k = 1ldotsn-1 these Betti numbers can change in a number of ways:\nA new homology class is created in X^(k+1), which leads to an increase in the corresponding Betti number. As before, this means that a new homology class is born at level k+1.\nA homology class that was present in X^(k) is no longer present in X^(k+1). On the one hand, this could be the result of the merging of two separate topological features, such as for example two separate connected components of the complex X^(k) which become one connected component in X^(k+1). On the other hand, the corresponding hole in the complex could have been filled in through the introduction of cells in the set difference X^(k+1) setminus X^(k). In either case, we say that the homology class died at level k+1.\nThe persistent homology associated with this filtration then consists of a collection of persistence intervals for each dimension. All of these intervals are of the form bd), where b denotes the birth time and d the death time of a topological feature. Note that some homology classes might still be present in the homology of the final Lefschetz complex X^(n) and in this case one obtains an interval of the form binfty), i.e., the feature never dies.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"With the above intuitive description one usually can work out the collection of persistence intervals for small and simple examples. There is, however, one final ambiguity that has to be resolved. Suppose that two topological features are born at times b_1 and b_2, and they merge to a single feature at time d. Which of these survives into the next complex, and which dies? In this situation, the elder rule applies, which says that the older feature persists. Thus, if b_1 ge b_2, then  one obtains the persistence interval b_1d), while the death time e in the interval b_2e) will be determined by a later level, i.e., we have e  d.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In order to illustrate this informal definition, we consider the filtration given by the four simplicial complexes shown in the figures. All of these are subcomplexes of, and the last one is equal to, one of our earlier examples.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"(Image: The 1-st complex in the filtration) (Image: The 2-nd complex in the filtration) (Image: The 3-rd complex in the filtration) (Image: The 4-th complex in the filtration)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In this simple example, the persistence intervals in each dimension can be determined easily:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Dimension 0: The first complex has one connected  component. A second component, namely the vertex mathrmH, is added in X^(2). Both of these  components merge in X^(3), and no additional components are created. In view of the elder rule, this gives the two persistence intervals 1infty) and 23).\nDimension 1: The first hole is created in X^(2) given by the cycle mathrmAB + mathrmAF + mathrmBF. Moreover, in X^(3) the hole determined by the chain mathrmDE + mathrmDH + mathrmEH is added to the mix. Finally, in X^(4) the latter hole is removed through filling in the triangle mathrmDEH, while the hole bounded by the cycle mathrmCD + mathrmDH + mathrmCG + mathrmGH is created. This gives the unbounded persistence intervals 2infty) and 4infty), as well as the bounded one 34).\nDimension 2: None of the complexes form any cavities, and therefore there are no persistence intervals in  dimension two.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In ConleyDynamics.jl, there are two functions that provide basic persistence functionality:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The function persistent_homology computes the persistence intervals, and it is usually invoked using the command pinf, ppairs = persistent_homology(lc, filtration). It expects two arguments: The first is an underlying Lefschetz complex lc of type LefschetzComplex, which has to be the complex X^(n) in the above notation. The second argument filtration is of type Vector{Int} and has to have length lc.ncells. For each cell index, it contains the integer level k of the the first complex X^(k) in which the cell appears. The function returns two vectors, pinf and ppairs, each of which have length 1 + lc.dim, and which contain the following information:\npinf[k] contains a vector of birth times for all unbounded persistence intervals in dimension k-1. It is an empty vector if no such intervals exist.\nppairs[k] contains a vector of pairs (b,d) for each of the bounded persistence interval bd) in dimension k-1. Again, this vector is empty if no such intervals exist.\nNote that the integer vector filtration has to contain every integer between 1 and n at least once, and only these integers. An error is raised if this is not the case, or if the resulting subcomplexes X^(k) are not closed.\nThe function lefschetz_filtration is meant to simplify the construction of the argument filtration, especially in the situation that X^(n) is a proper subcomplex of some ambient Lefschetz complex X. The function is invoked using the form lcsub, filtration = lefschetz_filtration(lc, partialfil). The argument lc contains the Lefschetz complex X. The  argument partialfil has the type Vector{Int} and is of length lc.ncells. For each cell index j it contains an integer partialfil[j] between 0 and n. If the cell appears first in complex X^(k), then partialfil[j] = k. This time, however, not all cells have to be specified, since the function automatically computes the complex closure at every level. Clearly, this means that the final complex is the closure of all cells with positive partialfil-values, and this can be a proper subcomplex of lc. The function therefore returns this subcomplex lcsub, together with a filtration filtration which satisfies the requirements of the function persistent_homology.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"We close this section with two examples illustrating these  functions. As first example, we consider the filtration given above, which consists of four simplicial complexes. In this case the persistence can be computed using the  commands:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"labels     = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\"]\nsimplices  = [[\"A\",\"B\"],[\"A\",\"F\"],[\"B\",\"F\"],[\"B\",\"C\",\"G\"],[\"D\",\"E\",\"H\"],[\"C\",\"D\"],[\"G\",\"H\"]]\nsc         = create_simplicial_complex(labels,simplices)\nfiltration = [1,1,1,1,1,2,1,2,\n              1,2,1,2,1,1,1,1,3,3,4,\n              1,4]\npinf, ppairs = persistent_homology(sc, filtration)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The first three lines establish the simplicial complex X^(4), while the next command defines the filtration. For easier reading, we used different lines for the cells of each dimension. Finally, the last command computes the persistence intervals. The unbounded ones have the birth times","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> pinf\n3-element Vector{Vector{Int64}}:\n [1]\n [2, 4]\n []","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"while the bounded ones are given by","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> ppairs\n3-element Vector{Vector{Tuple{Int64, Int64}}}:\n [(2, 3)]\n [(3, 4)]\n []","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This is in accordance with our earlier observations. Notice also that the Betti numbers of the final complex X^(4) in the filtration can easily be determined via","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> length.(pinf)\n3-element Vector{Int64}:\n 1\n 2\n 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"With the second example we illustrate the use of the function lefschetz_filtration. For this, suppose that the ambient Lefschetz complex X is the final simplicial complex in the filtration of the previous example. Within this complex, we  consider the following new filtration:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The complex X^(1) is the closure of  mathrmCD mathrmGH \nThe complex X^(2) is the closure of X^(1) cup  mathrmBC mathrmBG mathrmDEH \nThe complex X^(3) is the closure of X^(2) cup  mathrmBCG ","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The persistent intervals of this filtration can be determined using the following commands:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"labels    = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\"]\nsimplices = [[\"A\",\"B\"],[\"A\",\"F\"],[\"B\",\"F\"],[\"B\",\"C\",\"G\"],[\"D\",\"E\",\"H\"],[\"C\",\"D\"],[\"G\",\"H\"]]\nsc        = create_simplicial_complex(labels,simplices)\ntmpfil    = fill(Int(0),sc.ncells)\ntmpfil[sc.indices[\"CD\"]]  = 1\ntmpfil[sc.indices[\"GH\"]]  = 1\ntmpfil[sc.indices[\"BC\"]]  = 2\ntmpfil[sc.indices[\"BG\"]]  = 2\ntmpfil[sc.indices[\"DEH\"]] = 2\ntmpfil[sc.indices[\"BCG\"]] = 3\nscsub, filtration = lefschetz_filtration(sc, tmpfil)\npsinf, pspairs = persistent_homology(scsub, filtration)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The unbounded persistence intervals have birth times","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> psinf\n3-element Vector{Vector{Int64}}:\n [1]\n [2]\n []","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"while the bounded persistence intervals are","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> pspairs\n3-element Vector{Vector{Tuple{Int64, Int64}}}:\n [(1, 2)]\n []\n []","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Their correctness can immediately be established.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"As we mentioned earlier, more information on persistence can be found in [EH10], which also contains a detailed  discussion of the implemented persistence algorithm in the context of simplicial complexes. Further examples of persistence computations for general Lefschetz complexes are given in [DW18].","category":"page"},{"location":"man/homology/#refhomology","page":"Homology","title":"References","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"P. Dłotko and T. Wanner. Rigorous cubical approximation and persistent homology of             continuous functions. Computers & Mathematics with Applications 75, 1648–1666 (2018).\n\n\n\nH. Edelsbrunner and J. L. Harer. Computational Topology (American Mathematical Society, Providence, 2010).\n\n\n\nM. Gameiro, K. Mischaikow and T. Wanner. Evolution of pattern complexity in the Cahn-Hilliard             theory of phase separation. Acta Materialia 53, 693–704 (2005).\n\n\n\nT. Kaczynski, K. Mischaikow and M. Mrozek. Computational Homology. Vol. 157 of Applied Mathematical Sciences (Springer-Verlag, New York, 2004).\n\n\n\nS. Lefschetz. Algebraic Topology. Vol. 27 of American Mathematical Society Colloquium Publications (American Mathematical Society, New York, 1942).\n\n\n\nM. Mrozek and B. Batko. Coreduction homology algorithm. Discrete & Computational Geometry 41, 96–118 (2009).\n\n\n\nJ. R. Munkres. Elements of Algebraic Topology. SpringerBriefs in Mathematics (Addison-Wesley, Menlo Park, 1984).\n\n\n\nGUDHI Project. GUDHI User and Reference Manual. 3.10.1 Edition (GUDHI Editorial Board, 2024).\n\n\n\n","category":"page"},{"location":"apicore/plots/#Plotting-Functions","page":"Plotting Functions","title":"Plotting Functions","text":"","category":"section"},{"location":"apicore/plots/#Visualizing-Simplicial-Complexes","page":"Plotting Functions","title":"Visualizing Simplicial Complexes","text":"","category":"section"},{"location":"apicore/plots/#ConleyDynamics.plot_planar_simplicial","page":"Plotting Functions","title":"ConleyDynamics.plot_planar_simplicial","text":"plot_planar_simplicial(sc::LefschetzComplex,\n                       coords::Vector{<:Vector{<:Real}},\n                       fname::String;\n                       [mvf::CellSubsets=Vector{Vector{Int}}([]),]\n                       [labeldir::Vector{<:Real}=Vector{Int}([]),]\n                       [labeldis::Real=8,]\n                       [hfac::Real=1.2,]\n                       [vfac::Real=1.2,]\n                       [sfac::Real=0,]\n                       [pdim::Vector{Bool}=[true,true,true],]\n                       [pv::Bool=false])\n\nCreate an image of a planar simplicial complex, and if specified, a Forman vector field on it.\n\nThe vector coords contains coordinates for every one of the vertices of the simplicial complex sc. The image will be saved in the file with name fname, and the ending determines the image type. Accepted are .pdf, .svg, .png, and .eps.\n\nIf the optional mvf is specified and is a Forman vector field, then this Forman vector field is drawn as well. The optional vector labeldir contains directions for the vertex labels, and labeldis the distance from the vertex. The directions have to be reals between 0 and 4, with 0,1,2,3 corresponding to E,N,W,S. The optional constants hfac and vfac contain the horizontal and vertical scale vectors, while sfac describes a uniform scale. If sfac=0 the latter is automatically determined. The vector pdim specifies in which dimensions cells are drawn; the default shows vertices, edges, and triangles. Finally if one passes the argument pv=true, then in addition to saving the file a preview is displayed.\n\nExamples\n\nSuppose we have created a simplicial complex using the commands\n\nsc, coords = create_simplicial_delaunay(300, 300, 30, 20)\nfname = \"sc_plot_test.pdf\"\n\nThen the following code creates an image of the simplicial complex without labels, but with a preview:\n\nplot_planar_simplicial(sc, coords, fname, pv=true)\n\nIf we want to see the labels, we can use\n\nldir = fill(0.5, sc.ncells);\nplot_planar_simplicial(sc, coords, fname, labeldir=ldir, labeldis=10, pv=true)\n\nThis command puts all labels in the North-East direction at a distance of 10.\n\n\n\n\n\n","category":"function"},{"location":"apicore/plots/#ConleyDynamics.plot_planar_simplicial_morse","page":"Plotting Functions","title":"ConleyDynamics.plot_planar_simplicial_morse","text":"plot_planar_simplicial_morse(sc::LefschetzComplex,\n                             coords::Vector{<:Vector{<:Real}},\n                             fname::String,\n                             morsesets::CellSubsets;\n                             [hfac::Real=1.2,]\n                             [vfac::Real=1.2,]\n                             [sfac::Real=0,]\n                             [pdim::Vector{Bool}=[false,true,true],]\n                             [pv::Bool=false])\n\nCreate an image of a planar simplicial complex, together with Morse sets, or also selected multivectors.\n\nThe vector coords contains coordinates for every one of the vertices of the simplicial complex sc. The image will be saved in the file with name fname, and the ending determines the image type. Accepted are .pdf, .svg, .png, and .eps.\n\nThe vector morsesets contains a list of Morse sets, or more general, subsets of the simplicial complex. For every k, the set described by morsesets[k] will be shown in a distinct color.\n\nThe optional constants hfac and vfac contain the horizontal and vertical scale vectors for the margins, while sfac describes a uniform scale. If sfac=0 the latter is automatically determined. The vector pdim specifies in which dimensions cells are drawn; the default only shows edges and triangles. Finally if one passes the argument pv=true, then in addition to saving the file a preview is displayed.\n\n\n\n\n\n","category":"function"},{"location":"apicore/plots/#Visualizing-Cubical-Complexes","page":"Plotting Functions","title":"Visualizing Cubical Complexes","text":"","category":"section"},{"location":"apicore/plots/#ConleyDynamics.plot_planar_cubical","page":"Plotting Functions","title":"ConleyDynamics.plot_planar_cubical","text":"plot_planar_cubical(cc::LefschetzComplex,\n                    coords::Vector{<:Vector{<:Real}},\n                    fname::String;\n                    [hfac::Real=1.2,]\n                    [vfac::Real=1.2,]\n                    [cubefac::Real=0,]\n                    [pdim::Vector{Bool}=[true,true,true],]\n                    [pv::Bool=false])\n\nCreate an image of a planar cubical complex.\n\nThe vector coords contains coordinates for every one of the vertices of the cubical complex cc. The image will be saved in the file with name fname, and the ending determines the image type. Accepted are .pdf, .svg, .png, and .eps. The optional constants hfac and vfac contain the horizontal and vertical scale vectors. The optional argument cubefac specifies the side length of an elementary cube for plotting, and it will be automatically determined otherwise. The vector pdim specifies which cell dimensions should be plotted, with pdim[k] representing dimension k-1. Finally if one passes the argument pv=true, then in addition to saving the file a preview is displayed.\n\nExamples\n\nSuppose we have created a cubical complex using the commands\n\ncubes = [\"00.11\", \"01.01\", \"02.10\", \"11.10\", \"11.01\", \"22.00\"]\ncoords = [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,1],[2,2]]\ncc = create_cubical_complex(cubes)\nfname = \"cc_plot_test.pdf\"\n\nThen the following code creates an image of the simplicial complex without labels, but with a preview:\n\nplot_planar_cubical(cc, coords, fname, pv=true)\n\nIf one only wants to plot the edges in the complex, but not the vertices or rectangles, then one can use:\n\nplot_planar_cubical(cc, coords, fname, pv=true, pdim=[false,true,false])\n\n\n\n\n\nplot_planar_cubical(cc::LefschetzComplex,\n                    fname::String;\n                    [hfac::Real=1.2,]\n                    [vfac::Real=1.2,]\n                    [cubefac::Real=0,]\n                    [pdim::Vector{Bool}=[true,true,true],]\n                    [pv::Bool=false])\n\nCreate an image of a planar cubical complex.\n\nThis is an alternative method which does not require the specification of the vertex coordinates. They will be taken from the cube vertex labels.\n\n\n\n\n\n","category":"function"},{"location":"apicore/plots/#ConleyDynamics.plot_planar_cubical_morse","page":"Plotting Functions","title":"ConleyDynamics.plot_planar_cubical_morse","text":"plot_planar_cubical_morse(cc::LefschetzComplex,\n                          coords::Vector{<:Vector{<:Real}},\n                          fname::String,\n                          morsesets::CellSubsets;\n                          [hfac::Real=1.2,]\n                          [vfac::Real=1.2,]\n                          [cubefac::Real=0,]\n                          [pdim::Vector{Bool}=[false,true,true],]\n                          [pv::Bool=false])\n\nCreate an image of a planar cubical complex, together with Morse sets, or also selected multivectors.\n\nThe vector coords contains coordinates for every one of the vertices of the cubical complex cc. The image will be saved in the file with name fname, and the ending determines the image type. Accepted are .pdf, .svg, .png, and .eps.\n\nThe vector morsesets contains a list of Morse sets, or more general, subsets of the cubical complex. For every k, the set described by morsesets[k] will be shown in a distinct color.\n\nThe optional constants hfac and vfac contain the horizontal and vertical scale vectors for the margins, while cubefac describes a uniform scale. If cubefac=0 the latter is automatically determined. The vector pdim specifies in which dimensions cells are drawn; the default only shows edges and squares. Finally if one passes the argument pv=true, then in addition to saving the file a preview is displayed.\n\n\n\n\n\nplot_planar_cubical_morse(cc::LefschetzComplex,\n                          fname::String,\n                          morsesets::CellSubsets;\n                          [hfac::Real=1.2,]\n                          [vfac::Real=1.2,]\n                          [cubefac::Real=0,]\n                          [pdim::Vector{Bool}=[false,true,true],]\n                          [pv::Bool=false])\n\nCreate an image of a planar cubical complex, together with Morse sets, or also selected multivectors.\n\nThis is an alternative method which does not require the specification of the vertex coordinates. They will be taken from the cube vertex labels.\n\n\n\n\n\n","category":"function"},{"location":"man/sparse/#Sparse-Matrices","page":"Sparse Matrices","title":"Sparse Matrices","text":"","category":"section"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"While Julia provides a data structure for sparse matrix computations, the employed design decisions make it difficult to use this implementation for computations over finite fields. This is mainly due to the fact that in the Julia implementation, it is assumed that one can determine the zero and one elements from the data type alone. However, a finite field data type generally also depends on additional parameters, such as the characteristic of the field.","category":"page"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"Since the algorithms underlying ConleyDynamics.jl only require basic row and column operations, a specialized sparse matrix implementation is provided in the package. It is briefly described in the following.","category":"page"},{"location":"man/sparse/#Sparse-Matrix-Format","page":"Sparse Matrices","title":"Sparse Matrix Format","text":"","category":"section"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"Sparse matrices in this package have to be of the composite data type SparseMatrix, which is structured as follows:","category":"page"},{"location":"man/sparse/#ConleyDynamics.SparseMatrix-man-sparse","page":"Sparse Matrices","title":"ConleyDynamics.SparseMatrix","text":"SparseMatrix{T}\n\nComposite data type for a sparse matrix with entries of type T.\n\nThe struct has the following fields:\n\nconst nrow::Int: Number of rows\nconst ncol::Int: Number of columns\nconst char::Int: Characteristic of type T\nconst zero::T: Number 0 of type T\nconst one::T:  Number 1 of type T\nentries::Vector{Vector{T}}: Matrix entries corresponding to columns\ncolumns::Vector{Vector{Int}}: column[k] points to nonzero entries in column k\nrows::Vector{Vector{Int}}: rows[k] points to nonzero entries in the k-th row\n\n\n\n\n\n","category":"type"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"In this struct, the type T has to be either Int or Rational{Int}, depending on whether the sparse matrix is interpreted as a matrix with entries in the finite field GF(p) for some prime p, or over the field of rationals, respectively. The data type has the following fields:","category":"page"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"nrow::Int designates the number of rows.\nncol::Int gives the number of columns.\nchar::Int specifies the characteristic of the underlying field F. If char=0, then the field is the rationals mathbbQ, and one has to have T = Rational{Int}. If, on the other hand, the finite field F = GF(p) is used, then char=p has to be a prime number. In this case, the data type of the matrix entries has to be T = Int.\nzero::T provides 0 in the data type T.\none::T provides 1 in the data type T.\ncolumns::Vector{Vector{Int}} is a vector of integer vectors, which contains the row indices of nonzero matrix entries in each column. More precisely, columns[k] contains an increasing list of row indices, which give the locations of all nonzero entries in column k. Note that the list for each colum has to be strictly increasing.\nrows::Vector{Vector{Int}} is a vector of integer vectors, which contains the column indices of nonzero matrix entries in each row. It is the precise dual to the previous field. This time, rows[k] contains an increasing list of column indices, which correspond to the nonzero entries of the matrix in the k-th row.\nentries::Vector{Vector{T}} is a vector of vectors which contains  the actual matrix entries. It is organized in exactly the same way as the field columns. In other words, for every k = 1,..,ncol the matrix entry in column k and row columns[k][j] is given by entries[k][j], where j indexes the nonzero column entries from top to bottom.","category":"page"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"This data structure is clearly redundant, in the sense that the field rows is not needed to uniquely determine the matrix. However, the type SparseMatrix is fundamental for almost every aspect of ConleyDynamics.jl, as it is used to encode the incidence coefficient map kappa, and therefore also the matrix representation of the boundary operator partial. And for many operations on or queries of Lefschetz complexes, one needs fast access to both the cells in the boundary and the coboundary of a given cells. While the boundary can easily be accessed via the field columns, the fast coboundary access is aided by the field rows.","category":"page"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"We would like to point out that in view of the different underlying fields, sparse matrices should only be manipulated using the specific commands provided by the package. These are described in detail below. If there is a need for additional functionality beyond these first methods, it can be added at a later point in time.","category":"page"},{"location":"man/sparse/#Creating-Sparse-Matrices","page":"Sparse Matrices","title":"Creating Sparse Matrices","text":"","category":"section"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"The package provides a number of methods for creating sparse  matrices with the data type SparseMatrix. These are geared towards their usage within ConleyDynamics.jl and are therefore by no means exhaustive:","category":"page"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"sparse_from_full is usually invoked in the form A = sparse_from_full(AF, p=PP). The first input argument AF has to be a regular Julia integer matrix. This matrix is then converted to sparse format and returned as A. If the optional parameter p is omitted, the resulting sparse matrix is over the rational numbers mathbbQ, otherwise it is over the finite field with characteristic PP.\nfull_from_sparse converts a given sparse matrix into a standard full matrix in Julia. The data type of the entries is either Rational{Int} or Int, depending on whether the sparse input matrix is considered over the rationals mathbbQ or over a finite field, respectively. When invoking this command,  be mindful of the size of the sparse matrix!\nsparse_from_lists creates a sparse matrix solely based on its nonzero entries and their locations. It expects the following required input arguments, in the order they are listed:\nnr::Int: Number of rows\nnc::Int: Number of columns\ntchar: Field characteristic, which has to be 0 if F = mathbbQ and a positive prime otherwise\ntzero::T: Number 0 of type T\ntone::T:  Number 1 of type T\nr::Vector{Int}: Vector of row indices\nc::Vector{Int}: Vector of column indices\nv::Vector{T}: Vector of matrix entries\nThe function assumes that the vectors r, c, and v have the same length and that the matrix has entry v[k] at the location (r[k],c[k]). Zero entries will be ignored, and multiple entries for the same matrix position raise an error. Furthermore, if tchar>0, then the entries in v are all replaced by their values modulo tchar. As mentioned before, if tchar=0 then the entry type has to be T = Rational{Int}, otherwise we have T = Int.\nlists_from_sparse takes a sparse matrix and disassembles it into the separate ingredients specified in the discussion of the previous function. In this sense, it is precisely the inverse method of sparse_from_lists.\nsparse_identity creates a sparse identity matrix. It is invoked as A = sparse_identity(n, p=PP), and returns a sparse identity matrix A with n rows and n columns. If the optional characteristic parameter specified and positive, then the matrix is considered over the finite field with characteristic PP, otherwise it is over the rationals\\mathbb{Q}`.","category":"page"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"Of these methods, the function sparse_from_lists provides the easiest and quickest way to create a sparse matrix.","category":"page"},{"location":"man/sparse/#Sparse-Matrix-Access","page":"Sparse Matrices","title":"Sparse Matrix Access","text":"","category":"section"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"Access to the entries of sparse matrices is provided via the following commands:","category":"page"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"sparse_get_entry extracts the matrix entry val of the matrix A located in row ri and column ci, if it is invoked using the command val = sparse_get_entry(A,ri,ci).\nsparse_set_entry! sets the matrix entry of the matrix A located in row ri and column ci to the value 'val', if it is invoked using the command sparse_set_entry!(A,ri,ci,val). Internally, this commands makes sure that the above-defined format of the fields of a sparse matrix is preserved. Note that the data type of val has to match the type of A.zero. Moreover, if the matrix is considered over a finite field the value val has to be given as an integer between 0 and A.char-1.\nsparse_get_column is invoked as Acol = sparse_get_column(A,ci), and it returns the full ci-th column of the matrix A as a Vector{T} of length A.nrow.\nsparse_get_nz_column returns the row indices for the nonzero entries in the ci-th column of the sparse matrix A, if invoked as rivec = sparse_get_nz_column(A,ci).\nsparse_get_nz_row returns the column indices for the nonzero entries in the ri-th row of the sparse matrix A, if invoked as civec = sparse_get_nz_row(A,ri).\nsparse_minor creates a minor from a given sparse matrix A. For this, one needs to specify the row and column indices of the minor in the integer vectors rvec and cvec, respectively, and then invoke the function using the command AM = sparse_minor(A,rvec,cvec). Note that the entries in rvec and cvec do not have to be in increasing order, but they are not allowed to contain repeated indices.","category":"page"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"One can also read and set sparse matrix values using the overloaded methods y = A[i,j] and A[i,j] = val. In the latter case, it is up to the user to make sure that val respects the underlying sparse matrix field.","category":"page"},{"location":"man/sparse/#Elementary-Matrix-Operations","page":"Sparse Matrices","title":"Elementary Matrix Operations","text":"","category":"section"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"The following commands perform the basic sparse matrix operations that are needed for the functionality of the package:","category":"page"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"sparse_add_column! is invoked using the form sparse_add_column!(A,ci1,ci2,cn,cd), and it replaces the ci1-th column column[ci1] of A by column[ci1] + (cn/cd) * column[ci2]. This operation automatically performs the computations over the field F underlying the sparse matrix A. In other words, if this field is finite, then it determines the inverse of the argument cd as part of the computation.\nsparse_add_row! is invoked using the form sparse_add_row!(A,ri1,ri2,cn,cd), and it replaces the ri1-th row row[ri1] of A by row[ri1] + (cn/cd) * row[ri2]. As before, this operation automatically performs the computations over the field F underlying the sparse matrix A.\nsparse_permute creates a new sparse matrix by permuting the row and column indices. It is invoked using the command AP = sparse_permute(A,pr,pc), and the integer vectors pr and pc have to describe the row and column permutations, respectively.\nsparse_remove! is invoked as sparse_remove!(A,ri,ci) and removes the sparse matrix entry in the ri-th row and ci-th colum, i.e., it effectively sets the entry equal to zero.\nsparse_multiply computes the matrix product of  two sparse matrices. Exceptions are raised if the matrix product is not defined, or if the involved sparse matrices are defined over different fields. One can also use the operator form A*B to compute the product of sparse matrices.","category":"page"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"As mentioned earlier, additional operations can easily be implemented if they become necessary.","category":"page"},{"location":"man/sparse/#Sparse-Matrix-Information","page":"Sparse Matrices","title":"Sparse Matrix Information","text":"","category":"section"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"Finally, ConleyDynamics.jl provides the following functions  for quickly extracting certain information from sparse matrices:","category":"page"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"sparse_size is invoked as size = sparse_size(A,dim), and it returns the number of rows if dim=1, or the number of columns for dim=2.\nsparse_low returns the largest row index ri of a nonzero entry in the ci-th column of the matrix A, if used in the form ri = sparse_low(A,ci). In other words, it returns the row index of the lowest nonzero matrix entry in the column.\nsparse_is_zero checks whether a sparse matrix is the zero matrix.\nsparse_is_sut checks whether a given sparse matrix is strictly upper triangular, and returns either true or false.\nsparse_fullness returns the fullness of a sparse matrix as a floating point number. Here fullness refers to the ratio of the number of nonzero matrix elements and the total number of matrix entries.\nsparse_sparsity computes the sparseness of a sparse matrix, which is defined as 1 minus its fullness, i.e., it is the ratio of the number of zero matrix elements and the total number of matrix entries.\nsparse_show can be used to display a sparse matrix in traditional matrix form at the Julia REPL prompt.","category":"page"},{"location":"apicore/conley/#Conley-Theory-Functions","page":"Conley Theory Functions","title":"Conley Theory Functions","text":"","category":"section"},{"location":"apicore/conley/#Multivector-Fields","page":"Conley Theory Functions","title":"Multivector Fields","text":"","category":"section"},{"location":"apicore/conley/#ConleyDynamics.mvf_information","page":"Conley Theory Functions","title":"ConleyDynamics.mvf_information","text":"mvf_information(lc::LefschetzComplex, mvf::CellSubsets)\n\nExtract basic information about a multivector field.\n\nThe input argument lc contains the Lefschetz complex, and mvf describes the multivector field. The function returns the information in the form of a Dict{String,Any}. You can use the command keys to see the keyset of the return dictionary:\n\n\"N mv\": Number of multivectors\n\"N critical\": Number of critcal multivectors\n\"N regular\": Number of regular multivectors\n\"Lengths critical\": Length distribution of critical multivectors\n\"Lengths regular\": Length distribution of regular multivectors\n\nIn the last two cases, the dictionary entries are vectors of pairs (length,frequency), where each pair indicates that there are frequency multivectors of length length.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.create_mvf_hull","page":"Conley Theory Functions","title":"ConleyDynamics.create_mvf_hull","text":"create_mvf_hull(lc::LefschetzComplex, mvfbase::Vector{Vector{Int}})\n\nCreate the smallest multivector field containing the given sets.\n\nThe resulting multivector field has the property that every set of the form mvfbase[k] is contained in a minimal multivector. Notice that these sets do not have to be disjoint, and that not even their locally closed hulls have to be disjoint. In the latter case, this leads to two such sets having to be contained in the same multivector. If the sets in mvfbase are poorly chosen, one might end up with extremely large multivectors due to the above potential merging of locally closed hulls.\n\n\n\n\n\ncreate_mvf_hull(lc::LefschetzComplex, mvfbase::Vector{Vector{String}})\n\nCreate the smallest multivector field containing the given sets.\n\nThe resulting multivector field has the property that every set of the form mvfbase[k] is contained in a minimal multivector. Notice that these sets do not have to be disjoint, and that not even their locally closed hulls have to be disjoint. In the latter case, this leads to two such sets having to be contained in the same multivector. If the sets in mvfbase are poorly chosen, one might end up with extremely large multivectors due to the above potential merging of locally closed hulls.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.create_planar_mvf","page":"Conley Theory Functions","title":"ConleyDynamics.create_planar_mvf","text":"create_planar_mvf(lc::LefschetzComplex, coords::Vector{Vector{Float64}}, vf)\n\nCreate a planar multivector field from a regular vector field.\n\nThe function expects a planar Lefschetz complex lc and a coordinate vector coords of coordinates for all the 0-dimensional cells in the complex. Moreover, the underlying vector field is specified by the function vf(z::Vector{Float64})::Vector{Float64}, where both the input and output vectors have length two. The function create_planar_mvf returns a multivector field mvf on lc, which can then be further analyzed using for example the function connection_matrix.\n\nThe input data lc and coords can be generated using one of the following methods:\n\ncreate_cubical_rectangle\ncreate_simplicial_rectangle\ncreate_simplicial_delaunay\n\nIn each case, the provided coordinate vector can be transformed to the correct bounding box values using the conversion function convert_planar_coordinates.\n\nExample 1\n\nSuppose we define a sample vector field using the commands\n\nfunction samplevf(x::Vector{Float64})\n    #\n    # Sample vector field with nontrivial Morse decomposition\n    #\n    x1, x2 = x\n    y1 = x1 * (1.0 - x1*x1 - 3.0*x2*x2)\n    y2 = x2 * (1.0 - 3.0*x1*x1 - x2*x2)\n    return [y1, y2]\nend\n\nOne first creates a triangulation of the enclosing box, which in this case is given by [-2,2] x [-2,2] using the commands\n\nn = 21\nlc, coords = create_simplicial_rectangle(n,n);\ncoordsN = convert_planar_coordinates(coords,[-2.0,-2.0],[2.0,2.0]);\n\nThe multivector field is then generated using\n\nmvf = create_planar_mvf(lc,coordsN,samplevf);\n\nand the commands\n\ncm = connection_matrix(lc, mvf);\ncm.conley\nfull_from_sparse(cm.matrix)\n\nfinally show that this vector field gives rise to a Morse decomposition with nine Morse sets, and twelve connecting orbits. Using the commands\n\nfname = \"morse_test.pdf\"\nplot_planar_simplicial_morse(lc, coordsN, fname, cm.morse, pv=true)\n\nthese Morse sets can be visualized. The image will be saved in fname.\n\nExample 2\n\nAn example with periodic orbits can be generated using the vector field\n\nfunction samplevf2(x::Vector{Float64})\n    #\n    # Sample vector field with nontrivial Morse decomposition\n    #\n    x1, x2 = x\n    c0 = x1*x1 + x2*x2\n    c1 = (c0 - 4.0) * (c0 - 1.0)\n    y1 = -x2 + x1 * c1\n    y2 =  x1 + x2 * c1\n    return [-y1, -y2]\nend\n\nThe Morse decomposition can now be computed via\n\nn2 = 51\nlc2, coords2 = create_cubical_rectangle(n2,n2);\ncoords2N = convert_planar_coordinates(coords2,[-4.0,-4.0],[4.0,4.0]);\nmvf2 = create_planar_mvf(lc2,coords2N,samplevf2);\ncm2 = connection_matrix(lc2, mvf2);\ncm2.conley\ncm2.poset\nfull_from_sparse(cm2.matrix)\n\nfname2 = \"morse_test2.pdf\"\nplot_planar_cubical_morse(lc2, fname2, cm2.morse, pv=true)\n\nIn this case, one obtains three Morse sets: One is a stable equilibrium, one is an unstable periodic orbit, and the last is a stable periodic orbit.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.create_spatial_mvf","page":"Conley Theory Functions","title":"ConleyDynamics.create_spatial_mvf","text":"create_spatial_mvf(lc::LefschetzComplex, coords::Vector{Vector{Float64}}, vf)\n\nCreate a spatial multivector field from a regular vector field.\n\nThe function expects a three-dimensional Lefschetz complex lc and a coordinate vector coords of coordinates for all the 0-dimensional cells in the complex. Moreover, the underlying vector field is specified by the function vf(z::Vector{Float64})::Vector{Float64}, where both the input and output vectors have length three. The function create_spatial_mvf returns a multivector field mvf on lc, which can then be further analyzed using for example the function connection_matrix.\n\nThe input data lc and coords has to be of one of the following two types:\n\nlc is a tetrahedral mesh of a region in three dimensions. In other words, the underlying Lefschetz complex is in fact a simplicial  complex, and the vector coords contains the vertex coordinates.\nlc is a three-dimensional cubical complex, i.e., it is the closure of a collection of three-dimensional cubes in space. The vertex coordinates can be slightly perturbed from the original position in the cubical lattice, as long as the overall structure  of the complex stays intact. In that case, the faces are interpreted as Bezier surfaces with straight edges.\n\nExample 1\n\nSuppose we define a sample vector field using the commands\n\nfunction samplevf(x::Vector{Float64})\n    #\n    # Sample vector field with nontrivial Morse decomposition\n    #\n    x1, x2, x3 = x\n    y1 = x1 * (1.0 - x1*x1)\n    y2 = -x2\n    y3 = -x3\n    return [y1, y2, y3]\nend\n\nOne first creates a cubical complex covering the interesting dynamics, say the trapping region [-1.5,1.5] x [-1,1] x [-1,1], using the commands\n\nlc, coords = create_cubical_box(3,3,3);\ncoordsN = convert_spatial_coordinates(coords,[-1.5,-1.0,-1.0],[1.5,1.0,1.0]);\n\nThe multivector field is then generated using\n\nmvf = create_spatial_mvf(lc,coordsN,samplevf);\n\nand the commands\n\ncm = connection_matrix(lc, mvf);\ncm.conley\nfull_from_sparse(cm.matrix)\n\nfinally show that this vector field gives rise to a Morse decomposition with three Morse sets, and two connecting orbits.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.extract_multivectors","page":"Conley Theory Functions","title":"ConleyDynamics.extract_multivectors","text":"extract_multivectors(lc::LefschetzComplex, mvf::Vector{Vector{Int}},\n                     scells::Vector{Int})\n\nExtract all multivectors containing a provided selection of cells.\n\nThe function returns all multivectors which contain at least one of the cells in the input vector scells. The return argument has type Vector{Vector{Int}}.\n\n\n\n\n\nextract_multivectors(lc::LefschetzComplex, mvf::Vector{Vector{String}},\n                     scells::Vector{String})\n\nExtract all multivectors containing a provided selection of cells.\n\nThe function returns all multivectors which contain at least one of the cells in the input vector scells. The return argument has type Vector{Vector{String}}.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.planar_nontransverse_edges","page":"Conley Theory Functions","title":"ConleyDynamics.planar_nontransverse_edges","text":"planar_nontransverse_edges(lc::LefschetzComplex, coords::Vector{Vector{Float64}}, vf;\n                           npts::Int=100)\n\nFind all edges of a planar Lefschetz complex which are not flow transverse.\n\nThe Lefschetz complex is given in lc, the coordinates of all vertices of the complex in coords, and the vector field is specified in vf. The optional parameter npts determines how many points along an edge are evaluated for the transversality check. The function returns a list of nontransverse edges as Vector{Int}, which contains the edge indices.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#Conley-Index-Computations","page":"Conley Theory Functions","title":"Conley Index Computations","text":"","category":"section"},{"location":"apicore/conley/#ConleyDynamics.isoinvset_information","page":"Conley Theory Functions","title":"ConleyDynamics.isoinvset_information","text":"isoinvset_information(lc::LefschetzComplex, mvf::CellSubsets, iis::Cells)\n\nCompute basic information about an isolated invariant set.\n\nThe input argument lc contains the Lefschetz complex, and mvf describes the multivector field. The isolated invariant set is specified in the  argument iis. The function returns the information in the form of a Dict{String,Any}. The command keys can be used to see the keyset of the return dictionary. These describe the following information:\n\n\"Conley index\" contains the Conley index of the  isolated invariant set.\n\"N multivectors\" contains the number of multivectors in the isolated invariant set.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.conley_index","page":"Conley Theory Functions","title":"ConleyDynamics.conley_index","text":"conley_index(lc::LefschetzComplex, subcomp::Vector{String})\n\nDetermine the Conley index of a Lefschetz complex subset.\n\nThe function raises an error if the subset subcomp is not locally closed. The computations are performed over the field associated with the Lefschetz complex boundary matrix.\n\n\n\n\n\nconley_index(lc::LefschetzComplex, subcomp::Vector{Int})\n\nDetermine the Conley index of a Lefschetz complex subset.\n\nThe function raises an error if the subset subcomp is not locally closed. The computations are performed over the field associated with the Lefschetz complex boundary matrix.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.morse_sets","page":"Conley Theory Functions","title":"ConleyDynamics.morse_sets","text":"morse_sets(lc::LefschetzComplex, mvf::CellSubsets; poset::Bool=false)\n\nFind the nontrivial Morse sets of a multivector field on a Lefschetz complex.\n\nThe input argument lc contains the Lefschetz complex, and mvf describes the multivector field. The function returns the nontrivial Morse sets as a Vector{Vector{Int}}. If the optional argument poset=true is added, then the function returns both the Morse sets and the adjacency matrix of the Hasse diagram of the underlying poset.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.morse_interval","page":"Conley Theory Functions","title":"ConleyDynamics.morse_interval","text":"morse_interval(lc::LefschetzComplex, mvf::CellSubsets,\n               ms::CellSubsets)\n\nFind the isolated invariant set for a Morse set interval.\n\nThe input argument lc contains the Lefschetz complex, and mvf describes the multivector field. The collection of Morse sets are contained inms. All of these sets should be Morse sets in the sense of being strongly connected components of the flow graph. (Nevertheless, this will be enforced in the function!) In other words, the sets in ms should be determined using the function morse_sets!\n\nThe function returns the smallest isolated invariant set which contains the Morse sets and their connections as a Vector{Int}.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.restrict_dynamics","page":"Conley Theory Functions","title":"ConleyDynamics.restrict_dynamics","text":"restrict_dynamics(lc::LefschetzComplex, mvf::CellSubsets, lcsub::Cells)\n\nRestrict a multivector field to a Lefschetz subcomplex.\n\nFor a given multivector field mvf on a Lefschetz complex lc, and a subcomplex which is given by the locally closed set represented by lcsub, create the associated Lefschetz subcomplex lcreduced and the induced multivector field mvfreduced on the subcomplex. The multivectors of the new multivector field are the intersections of the original multivectors and the subcomplex.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.remove_exit_set","page":"Conley Theory Functions","title":"ConleyDynamics.remove_exit_set","text":"remove_exit_set(lc::LefschetzComplex, mvf::CellSubsets)\n\nExit set removal for a multivector field on a Lefschetz subcomplex.\n\nIt is assumed that the Lefschetz complex lc is a topological manifold and that mvf contains a multivector field that is created via either create_planar_mvf or create_spatial_mvf. The function identifies cells on the boundary at which the flows exits the region covered by the Lefschetz complex. If this exit set is closed, we have found an  isolated invariant set and the function returns a Lefschetz complex lcr restricted to it, as well as the restricted multivector field mvfr. If the exit set is not closed, a warning is displayed and the function returns the restricted Lefschetz complex and multivector field obtained by removing the closure of the exit set. In the latter case, unexpected results might be obtained.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#Connection-Matrix-Computation","page":"Conley Theory Functions","title":"Connection Matrix Computation","text":"","category":"section"},{"location":"apicore/conley/#ConleyDynamics.connection_matrix","page":"Conley Theory Functions","title":"ConleyDynamics.connection_matrix","text":"connection_matrix(lc::LefschetzComplex, mvf::CellSubsets;\n                  [returnbasis::Bool])\n\nCompute a connection matrix for the multivector field mvf on the Lefschetz complex lc over the field associated with the Lefschetz complex boundary matrix.\n\nThe function returns an object of type ConleyMorseCM. If the optional argument returnbasis::Bool=true is given, then the function also returns a dictionary which gives the basis for the connection matrix columns in terms of the original labels.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.cm_reduce!","page":"Conley Theory Functions","title":"ConleyDynamics.cm_reduce!","text":"cm_reduce!(matrix::SparseMatrix, psetvec::Vector{Int};\n           [returnbasis::Bool],[returntm::Bool])\n\nCompute the connection matrix.\n\nAssumes that matrix is upper triangular and filtered according to psetvec. Modifies the argument matrix.\n\nReturn values:\n\ncmatrix: Connection matrix\ncmatrix_cols: Columns of the connection matrix in the boundary\nbasisvecs (optional): If the argument returnbasis=true is given, this returns information about the computed basis. The k-th entry of basisvecs is a vector containing the columns making up the k-th basis vector, which corresponds to column cmatrix_cols[k].\ntmatrix (optional): If the argument returntm=true is given in addition to returnbasis=true, then instead of basisvecs the function returns the complete transformation matrix. In this case, basicvecs is not returned.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#Sparse-Matrix-Functions","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"","category":"section"},{"location":"apicore/sparse/#Internal-Sparse-Matrix-Representation","page":"Sparse Matrix Functions","title":"Internal Sparse Matrix Representation","text":"","category":"section"},{"location":"apicore/sparse/#ConleyDynamics.SparseMatrix","page":"Sparse Matrix Functions","title":"ConleyDynamics.SparseMatrix","text":"SparseMatrix{T}\n\nComposite data type for a sparse matrix with entries of type T.\n\nThe struct has the following fields:\n\nconst nrow::Int: Number of rows\nconst ncol::Int: Number of columns\nconst char::Int: Characteristic of type T\nconst zero::T: Number 0 of type T\nconst one::T:  Number 1 of type T\nentries::Vector{Vector{T}}: Matrix entries corresponding to columns\ncolumns::Vector{Vector{Int}}: column[k] points to nonzero entries in column k\nrows::Vector{Vector{Int}}: rows[k] points to nonzero entries in the k-th row\n\n\n\n\n\n","category":"type"},{"location":"apicore/sparse/#Access-Functions","page":"Sparse Matrix Functions","title":"Access Functions","text":"","category":"section"},{"location":"apicore/sparse/#ConleyDynamics.sparse_get_entry","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_get_entry","text":"sparse_get_entry(matrix::SparseMatrix, ri::Int, ci::Int)\n\nGet the sparse matrix entry at location (ri,ci).\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#Base.getindex-Tuple{SparseMatrix, Int64, Int64}","page":"Sparse Matrix Functions","title":"Base.getindex","text":"Base.getindex(matrix::SparseMatrix, ri::Int, ci::Int)\n\nGet the sparse matrix entry at location (ri,ci).\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_set_entry!","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_set_entry!","text":"sparse_set_entry!(matrix::SparseMatrix, ri::Int, ci::Int, val)\n\nSet the sparse matrix entry at location (ri,ci) to val.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#Base.setindex!-Tuple{SparseMatrix, Any, Int64, Int64}","page":"Sparse Matrix Functions","title":"Base.setindex!","text":"Base.setindex!(matrix::SparseMatrix, val, ri::Int, ci::Int)\n\nSet the sparse matrix entry at location (ri,ci) to val.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_get_column","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_get_column","text":"sparse_get_column(matrix::SparseMatrix, ci::Int)\n\nGet the ci-th column of the sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_get_nz_column","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_get_nz_column","text":"sparse_get_nz_column(matrix::SparseMatrix, ci::Int)\n\nGet the row indices for the nonzero entries in the ci-th column of the sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_get_nz_row","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_get_nz_row","text":"sparse_get_nz_row(matrix::SparseMatrix, ri::Int)\n\nGet the column indices for the nonzero entries in the ri-th row of the sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_minor","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_minor","text":"smp = sparse_minor(sm::SparseMatrix, rvec::Vector{Int}, cvec::Vector{Int})\n\nCreate sparse submatrix by specifying the desired row and column indices.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#Basic-Functions","page":"Sparse Matrix Functions","title":"Basic Functions","text":"","category":"section"},{"location":"apicore/sparse/#ConleyDynamics.sparse_size","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_size","text":"sparse_size(matrix::SparseMatrix, dim::Int)\n\nNumber of rows (dim=1) or columns (dim=2) of a sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_low","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_low","text":"sparse_low(matrix::SparseMatrix, col::Int)\n\nRow index of the lowest nonzero matrix entry in column col.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_is_zero","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_is_zero","text":"sparse_is_zero(sm::SparseMatrix)\n\nTest whether the sparse matrix sm is the zero matrix.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_is_sut","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_is_sut","text":"bool = sparse_is_sut(sm::SparseMatrix)\n\nCheck whether the sparse matrix is strictly upper triangular.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_identity","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_identity","text":"sparse_identity(n::Int; p::Int=0)\n\nCreate a sparse identity matrix with n rows and columns.\n\nThe optional argument p specifies the field characteristic. If p=0 then the sparse matrix is over the rationals, while if p>0 is a prime, then the matrix is an integer matrix  whose entries are interpreted in GF(p).\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_fullness","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_fullness","text":"sparse_fullness(sm::SparseMatrix)\n\nDisplay the fullness of the sparse matrix sm.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_sparsity","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_sparsity","text":"sparse_sparsity(sm::SparseMatrix)\n\nDisplay the sparsity of the sparse matrix sm.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_show","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_show","text":"sparse_show(sm::SparseMatrix)\n\nDisplay the sparse matrix sm.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#Elementary-Matrix-Operations","page":"Sparse Matrix Functions","title":"Elementary Matrix Operations","text":"","category":"section"},{"location":"apicore/sparse/#ConleyDynamics.sparse_add_column!","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_add_column!","text":"sparse_add_column!(matrix::SparseMatrix, ci1::Int, ci2::Int, cn, cd)\n\nReplace column[ci1] by column[ci1] + (cn/cd) * column[ci2].\n\n\n\n\n\nsparse_add_column!(matrix::SparseMatrix{Int}, ci1::Int, ci2::Int,\n                   cn::Int, cd::Int)\n\nReplace column[ci1] by column[ci1] + (cn/cd) * column[ci2].\n\nThe computation is performed mod p, where the characteristic is taken from matrix.char. An error is thrown if matrix.char==0.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_add_row!","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_add_row!","text":"sparse_add_row!(matrix::SparseMatrix, ri1::Int, ri2::Int, cn, cd)\n\nReplace row[ri1] by row[ri1] + (cn/cd) * row[ri2].\n\n\n\n\n\nsparse_add_row!(matrix::SparseMatrix{Int}, ri1::Int, ri2::Int,\n                cn::Int, cd::Int)\n\nReplace row[ri1] by row[ri1] + (cn/cd) * row[ri2].\n\nThe computation is performed mod p, where the characteristic is taken from matrix.char. An error is thrown if matrix.char==0.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_permute","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_permute","text":"sparse_permute(sm::SparseMatrix, pr::Vector{Int}, pc::Vector{Int})\n\nCreate sparse matrix by permuting the row and column indices.\n\nThe vector pr describes the row permutation, and pc the column permutation.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_remove!","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_remove!","text":"sparse_remove!(matrix::SparseMatrix, ri::Int, ci::Int)\n\nRemove the sparse matrix entry at location (ri,ci).\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_multiply","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_multiply","text":"sparse_multiply(A::SparseMatrix, B::SparseMatrix)\n\nMultiply two sparse matrices.\n\nExceptions are raised if the matrix product is not defined  or the entry types do not match.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#Base.:*-Tuple{SparseMatrix, SparseMatrix}","page":"Sparse Matrix Functions","title":"Base.:*","text":"Base.:*(A::SparseMatrix, B::SparseMatrix)\n\nMultiply two sparse matrices.\n\nExceptions are raised if the matrix product is not defined  or the entry types do not match.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#Conversion-Functions","page":"Sparse Matrix Functions","title":"Conversion Functions","text":"","category":"section"},{"location":"apicore/sparse/#ConleyDynamics.sparse_from_full","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_from_full","text":"sparse_from_full(matrix::Matrix{Int}; [p::Int=0])\n\nCreate sparse matrix from full integer matrix. If the optional argument p is specified and positive, then the returned matrix is an integer matrix which is interpreted over GF(p). On the other hand, if p is omitted or equal to zero, then the return matrix has rational type.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.full_from_sparse","page":"Sparse Matrix Functions","title":"ConleyDynamics.full_from_sparse","text":"full_from_sparse(sm::SparseMatrix)\n\nCreate full matrix from sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_from_lists","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_from_lists","text":"sparse_from_lists(nr, nc, tchar, tzero, tone, r, c, v)\n\nCreate sparse matrix from lists describing the entries.\n\nThe vectors r, c, and v have to have the same length and the matrix has entry v[k] at (r[k],c[k]). Zero entries will be ignored, and multiple entries for the same matrix position raise an error.\n\nThe input arguments have the following meaning:\n\nnr::Int: Number of rows\nnc::Int: Number of columns\ntchar: Field characteristic if T==Int\ntzero::T: Number 0 of type T\ntone::T:  Number 1 of type T\nr::Vector{Int}: Vector of row indices\nc::Vector{Int}: Vector of column indices\nv::Vector{T}: Vector of matrix entries\n\nIf tchar>0, then the entries in v are all replaced by their values mod tchar.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.lists_from_sparse","page":"Sparse Matrix Functions","title":"ConleyDynamics.lists_from_sparse","text":"nr, nc, tchar, tzero, tone, r, c, v = lists_from_sparse(sm::SparseMatrix)\n\nCreate list representation from sparse matrix.\n\nThe output variables are exactly what is needed to create a sparse matrix object using sparse_from_lists.\n\n\n\n\n\n","category":"function"},{"location":"apicore/examples/#Example-Functions","page":"Example Functions","title":"Example Functions","text":"","category":"section"},{"location":"apicore/examples/#Examples-from-Batko-et-al.","page":"Example Functions","title":"Examples from Batko et al.","text":"","category":"section"},{"location":"apicore/examples/#ConleyDynamics.example_forman1d","page":"Example Functions","title":"ConleyDynamics.example_forman1d","text":"lc, mvf, coords = example_forman1d()\n\nCreate the simplicial complex and multivector field for the example from Figure 1 in the FoCM 2020 paper by Batko, Kaczynski, Mrozek, and Wanner.\n\nThe function returns the Lefschetz complex lc and the  multivector field mvf. If desired for plotting, the third return value coords gives a vector of coordinates for the vertices. The Lefschetz complex is defined over the finite field GF(2).\n\nExamples\n\njulia> lc, mvf = example_forman1d();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0   0   1]\n[0   0   0   0   0]\n[0   0   0   0   1]\n[0   0   0   0   0]\n[0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"A\", \"AD\", \"F\", \"BF\", \"DE\"]\n\n\n\n\n\n","category":"function"},{"location":"apicore/examples/#ConleyDynamics.example_forman2d","page":"Example Functions","title":"ConleyDynamics.example_forman2d","text":"lc, mvf, coords = example_forman2d()\n\nCreate the simplicial complex and multivector field for the example from Figure 3 in the FoCM 2020 paper by Batko, Kaczynski, Mrozek, and Wanner.\n\nThe function returns the Lefschetz complex lc over the finite field GF(2) and the multivector field mvf. If desired for plotting, the third return value coords gives a vector of coordinates for the vertices.\n\nExamples\n\njulia> lc, mvf = example_forman2d();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0   0   1   0   1   0   0]\n[0   0   0   0   0   1   0   0   0]\n[0   0   0   0   1   1   1   0   0]\n[0   0   0   0   0   0   0   0   1]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"D\", \"E\", \"F\", \"GJ\", \"BF\", \"EF\", \"HI\", \"ADE\", \"FGJ\"]\n\n\n\n\n\n","category":"function"},{"location":"apicore/examples/#Examples-from-Mrozek-and-Wanner","page":"Example Functions","title":"Examples from Mrozek & Wanner","text":"","category":"section"},{"location":"apicore/examples/#ConleyDynamics.example_julia_logo","page":"Example Functions","title":"ConleyDynamics.example_julia_logo","text":"lc, mvf = example_julia_logo()\n\nCreate the simplicial complex and multivector field for the example from Figure 1 in the connection matrix paper by Mrozek & Wanner.\n\nThe function returns the Lefschetz complex lc over GF(2) and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_julia_logo();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0]\n[0   0   1]\n[0   0   0]\n\njulia> print(cm.labels)\n[\"D\", \"AC\", \"ABC\"]\n\n\n\n\n\n","category":"function"},{"location":"apicore/examples/#ConleyDynamics.example_three_cm","page":"Example Functions","title":"ConleyDynamics.example_three_cm","text":"lc, mvf, coords = example_three_cm(mvftype)\n\nCreate the simplicial complex and multivector field for the example from Figure 2 in the connection matrix paper by Mrozek & Wanner.\n\nDepending on the value of mvftype, return the periodic orbit (0=default) or one of the three gradient (1,2,3) examples.\n\nThe function returns the Lefschetz complex lc over the rational field and the multivector field mvf. If desired for plotting, the third return value coords gives a vector of coordinates for the vertices.\n\nExamples\n\njulia> lc, mvf = example_three_cm(0);\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> print(cm.labels)\n[\"A\", \"C\", \"CE\", \"AC\", \"BD\", \"DF\", \"ABC\", \"EFG\"]\n\njulia> full_from_sparse(cm.matrix)\n8×8 Matrix{Rational{Int64}}:\n 0  0  0  -1  -1  0   0  0\n 0  0  0   1   1  0   0  0\n 0  0  0   0   0  0   0  0\n 0  0  0   0   0  0  -1  0\n 0  0  0   0   0  0   1  0\n 0  0  0   0   0  0   0  1\n 0  0  0   0   0  0   0  0\n 0  0  0   0   0  0   0  0\n\n\n\n\n\n","category":"function"},{"location":"apicore/examples/#ConleyDynamics.example_multiflow","page":"Example Functions","title":"ConleyDynamics.example_multiflow","text":"lc, mvf = example_multiflow()\n\nCreate the Lefschetz complex and multivector field for the example from Figure 3 in the connection matrix paper by Mrozek & Wanner.\n\nThe function returns the Lefschetz complex lc over GF(2) and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_multiflow();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0   0]\n[0   0   0   0]\n[0   0   0   0]\n[0   0   0   0]\n\njulia> print(cm.labels)\n[\"BD\", \"DF\", \"AC\", \"CE\"]\n\n\n\n\n\n","category":"function"},{"location":"apicore/examples/#ConleyDynamics.example_small_periodicity","page":"Example Functions","title":"ConleyDynamics.example_small_periodicity","text":"lc1, lc2, mvf = example_small_periodicity()\n\nCreate two representations of the Lefschetz complex and the multivector field for the example from Figure 4 in the connection matrix paper by Mrozek & Wanner.\n\nThe complexes lc1 and lc2 are just two representations of the same complex, but they lead to different connection matrices. Both Lefschetz complexes are defined over the finite field GF(2).\n\nThe function returns the Lefschetz complexes lc1 and lc2, as well as the multivector field mvf.\n\nExamples\n\njulia> lc1, lc2, mvf = example_small_periodicity();\n\njulia> cm1 = connection_matrix(lc1, mvf);\n\njulia> cm2 = connection_matrix(lc2, mvf);\n\njulia> full_from_sparse(cm1.matrix)\n4×4 Matrix{Int64}:\n 0  0  0  0\n 0  0  0  1\n 0  0  0  1\n 0  0  0  0\n\njulia> print(cm1.labels)\n[\"A\", \"a\", \"b\", \"alpha\"]\n\njulia> full_from_sparse(cm2.matrix)\n4×4 Matrix{Int64}:\n 0  0  0  0\n 0  0  0  0\n 0  0  0  1\n 0  0  0  0\n\njulia> print(cm2.labels)\n[\"A\", \"c\", \"b\", \"alpha\"]\n\n\n\n\n\n","category":"function"},{"location":"apicore/examples/#ConleyDynamics.example_subdivision","page":"Example Functions","title":"ConleyDynamics.example_subdivision","text":"lc, mvf = example_subdivision(mvftype)\n\nCreate the Lefschetz complex and multivector field for the example from Figure 11 in the connection matrix paper by Mrozek & Wanner.\n\nDepending on the value of mvftype, return the multivector (0=default) or one of the two combinatorial vector field (1,2) examples.\n\nThe function returns the Lefschetz complex lc over the rationals and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_subdivision(1);\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> full_from_sparse(cm.matrix)\n5×5 Matrix{Rational{Int64}}:\n 0  0  -1  -1  -1\n 0  0   1   0   0\n 0  0   0   0   0\n 0  0   0   0   0\n 0  0   0   0   0\n\n\n\n\n\n","category":"function"},{"location":"apicore/examples/#General-Examples","page":"Example Functions","title":"General Examples","text":"","category":"section"},{"location":"apicore/examples/#ConleyDynamics.example_critical_simplex","page":"Example Functions","title":"ConleyDynamics.example_critical_simplex","text":"lc, mvf = example_critical_simplex(dim)\n\nCreate a simplicial complex of dimension dim as well as a multivector field on it in which every cell is critical.\n\nThe function returns the Lefschetz complex lc over GF(2) and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_critical_simplex(2);\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0   1   1   0   0]\n[0   0   0   1   0   1   0]\n[0   0   0   0   1   1   0]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"A\", \"B\", \"C\", \"AB\", \"AC\", \"BC\", \"ABC\"]\n\n\n\n\n\n","category":"function"},{"location":"apicore/examples/#ConleyDynamics.example_moebius","page":"Example Functions","title":"ConleyDynamics.example_moebius","text":"lc1, mvf1, lc2, mvf2 = example_moebius(p)\n\nCreate two simplicial complexes for a cylinder and Moebius strip, respectively, together with associated multivector fields on them.\n\nThe function returns the Lefschetz complexes lc1 and lc2, as well as the multivector fields mvf1 and mvf2. Both complexes are over a field with characteristic p. Positive  prime characteristic uses the finite field GF(p), while zero characteristic gives the rationals.\n\nThe multivector field is the same, and it has one critical  cell each in dimension 1 and 2 in the interior of the strip. The boundary consists of two periodic orbits for lc1 and mvf1, and of one periodic orbit in the Moebius case lc2 and mvf2. The latter case leads to different connection matrices for the fields GF(2) and GF(7), for example.\n\nExamples\n\njulia> lc1, mvf1, lc2, mvf2 = example_moebius(0);\n\njulia> lc2p2 = lefschetz_gfp_conversion(lc2,2);\n\njulia> lc2p7 = lefschetz_gfp_conversion(lc2,7);\n\njulia> cmp2 = connection_matrix(lc2p2, mvf2);\n\njulia> cmp7 = connection_matrix(lc2p7, mvf2);\n\njulia> sparse_show(cmp2.matrix)\n[0   0   0   0]\n[0   0   0   1]\n[0   0   0   0]\n[0   0   0   0]\n\njulia> sparse_show(cmp7.matrix)\n[0   0   0   0]\n[0   0   0   1]\n[0   0   0   2]\n[0   0   0   0]\n\n\n\n\n\n","category":"function"},{"location":"apicore/examples/#ConleyDynamics.example_nonunique","page":"Example Functions","title":"ConleyDynamics.example_nonunique","text":"lc1, lc2, mvf, coords1, coords2 = example_nonunique()\n\nCreate two representations of a simplicial complex and one multivector field which illustrates nonunique connection matrices.\n\nThe two complexes lc1 and lc2 represent the same simplicial complex over GF(2), but differ in the ordering of the labels.\n\nThe function returns the Lefschetz complexes lc1 and lc2, as well as the multivector field mvf. If desired for plotting, the fourth and fifth return values coords1 and coords2 give vectors of coordinates for the vertices of the two complexes.\n\nExamples\n\njulia> lc1, lc2, mvf = example_nonunique();\n\njulia> cm1 = connection_matrix(lc1, mvf);\n\njulia> cm2 = connection_matrix(lc2, mvf);\n\njulia> sparse_show(cm1.matrix)\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   0   0   0   0   1   1]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm1.labels)\n[\"2\", \"7\", \"79\", \"29\", \"45\", \"67\", \"168\", \"349\", \"789\"]\njulia> sparse_show(cm2.matrix)\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   0   0   0   1   0   1]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm2.labels)\n[\"2\", \"8\", \"78\", \"29\", \"45\", \"67\", \"168\", \"349\", \"789\"]\n\n\n\n\n\n","category":"function"},{"location":"apicore/examples/#ConleyDynamics.example_clorenz","page":"Example Functions","title":"ConleyDynamics.example_clorenz","text":"lc, mvf = example_clorenz()\n\nCreate the simplicial complex and multivector field for the example from Figure 3 in the JCD 2016 paper by Kaczynski, Mrozek, and Wanner.\n\nThe function returns the Lefschetz complex lc over the finite field GF(2) and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_clorenz();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0   0   1]\n[0   0   0   0   0]\n[0   0   0   0   1]\n[0   0   0   0   0]\n[0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"i\", \"ip\", \"g\", \"gm\", \"bc\"]\n\njulia> ms, ps = morse_sets(lc, mvf, poset=true);\n\njulia> [conley_index(lc, mset) for mset in ms]\n4-element Vector{Vector{Int64}}:\n [1, 1, 0]\n [1, 1, 0]\n [0, 1, 0]\n [0, 0, 0]\n\njulia> ps\n4×4 Matrix{Bool}:\n 0  0  1  0\n 0  0  1  0\n 0  0  0  1\n 0  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"apicore/examples/#ConleyDynamics.example_dunce_chaos","page":"Example Functions","title":"ConleyDynamics.example_dunce_chaos","text":"sc, vfG, vfC = example_dunce_chaos()\n\nCreate a minimal simplicial complex representation of the Dunce hat, as well as two Forman vector fields.\n\nThe function returns the simplicial representation of the Dunce hat in sc over the finite field GF(2). The Forman vector field vfG is a gradient vector  field with unique connection matrix. The field vfC is a modification of this field which merges the critical cells of dimensions 1 and 2 into a Forman arrow. The resulting Forman vector field is no longer gradient,  and in fact exhibits Lorez-like chaos.\n\nExamples\n\njulia> sc, vfG, vfC = example_dunce_chaos();\n\njulia> homology(sc)\n3-element Vector{Int64}:\n 1\n 0\n 0\n\njulia> cmG = connection_matrix(sc, vfG);\n\njulia> sparse_show(cmG.matrix)\n[0   0   0]\n[0   0   1]\n[0   0   0]\n\njulia> print(cmG.labels)\n[\"1\", \"12\", \"128\"]\n\njulia> cmC = connection_matrix(sc, vfC);\n\njulia> sparse_show(cmC.matrix)\n[0]\n\njulia> print(cmC.labels)\n[\"1\"]\n\njulia> msC, psC = morse_sets(sc, vfC, poset=true);\n\njulia> [conley_index(sc, mset) for mset in msC]\n2-element Vector{Vector{Int64}}:\n [1, 0, 0]\n [0, 0, 0]\n\njulia> psC\n2×2 Matrix{Bool}:\n 0  1\n 0  0\n\njulia> msC\n2-element Vector{Vector{String}}:\n [\"1\"]\n [\"12\", \"14\", \"15\", \"25\", \"28\", \"56\", \"68\", \"78\", \"124\", \"125\", \"128\", \"145\", \"256\", \"278\", \"568\", \"678\"]\n\n\n\n\n\n","category":"function"},{"location":"apicore/examples/#ConleyDynamics.example_torsion_chaos","page":"Example Functions","title":"ConleyDynamics.example_torsion_chaos","text":"sc, vfG, vfC = example_torsion_chaos(n::Int, p::Int)\n\nCreate a triangulation of a space with 1-dimensional torsion, as well as two Forman vectr fields on this complex.\n\nThe function returns a simplicial complex sc which has the following integer homology groups:\n\nIn dimension 0 it is the group of integers.\nIn dimension 1 it is the integers modulo n.\nIn dimension 2 it is the trivial group.\n\nIn other words, the simplicial complex has nontrivial torsion in dimension 1. It is a triangulation of an n-gon, in which all boundary edges are oriented counterclockwise, and all of these edges are identified. The parameter p specifies the characteristic of the underlying field.\n\nIn addition, two Forman vector fields vfG and vfC are returned. The first one is a gradient vector field whose connection matrix has a large connection matrix entry. In fact, if p is any prime larger than n then there will be an entry n in the matrix. The scond Forman vector field contains a chaotic Morse set. This Morse set will have trivial Morse index for most p. On the other hand, for prime p = n the set has the Morse index of an unstable  periodic orbit.\n\nExamples\n\njulia> sc, vfG, vfC = example_torsion_chaos(3,7);\n\njulia> homology(sc)\n3-element Vector{Int64}:\n 1\n 0\n 0\n\njulia> cmG = connection_matrix(sc, vfG);\n\njulia> sparse_show(cmG.matrix)\n[0   0   0]\n[0   0   3]\n[0   0   0]\n\njulia> print(cmG.labels)\n[\"0w\", \"0w0x\", \"0w0x1s\"]\n\njulia> cmC = connection_matrix(sc, vfC);\n\njulia> sparse_show(cmC.matrix)\n[0]\n\njulia> print(cmC.labels)\n[\"0w\"]\n\njulia> msC, psC = morse_sets(sc, vfC, poset=true);\n\njulia> [conley_index(sc, mset) for mset in msC]\n2-element Vector{Vector{Int64}}:\n [1, 0, 0]\n [0, 0, 0]\n\njulia> psC\n2×2 Matrix{Bool}:\n 0  1\n 0  0\n\njulia> length.(msC)\n2-element Vector{Int64}:\n  1\n 26\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Lefschetz-Complex-Functions","page":"Lefschetz Complex Functions","title":"Lefschetz Complex Functions","text":"","category":"section"},{"location":"apicore/lefschetz/#Simplicial-Complexes","page":"Lefschetz Complex Functions","title":"Simplicial Complexes","text":"","category":"section"},{"location":"apicore/lefschetz/#ConleyDynamics.create_simplicial_complex","page":"Lefschetz Complex Functions","title":"ConleyDynamics.create_simplicial_complex","text":"create_simplicial_complex(labels::Vector{String},\n                          simplices::Vector{Vector{Int}};\n                          p::Int=2)\n\nInitialize a Lefschetz complex from a simplicial complex. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe vector labels contains a label for every vertex, while simplices contains all the highest-dimensional simplices necessary to define the simplicial complex. Every simplex is represented as a vector of Int, with entries corresponding to the vertex indices.\n\nwarning: Warning\nNote that the labels all have to have the same character length!\n\n\n\n\n\ncreate_simplicial_complex(labels::Vector{String},\n                          simplices::Vector{Vector{String}};\n                          p::Int=2)\n\nInitialize a Lefschetz complex from a simplicial complex. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe vector labels contains a label for every vertex, while simplices contains all the highest-dimensional simplices necessary to define the simplicial complex.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.create_simplicial_rectangle","page":"Lefschetz Complex Functions","title":"ConleyDynamics.create_simplicial_rectangle","text":"create_simplicial_rectangle(nx::Int, ny::Int; p::Int=2)\n\nCreate a simplicial complex covering a rectangle in the plane. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe rectangle is given by the subset [0,nx] x [0,ny] of the plane. Each unit square is represented by four triangles, which meet in the center point of the square. Labels have the following meaning:\n\nThe label XXXYYYb corresponds to the point (XXX, YYY).\nThe label XXXYYYc corresponds to (XXX + 1/2, YYY + 1/2).\n\nThe number of characters in XXX and YYY matches the number  of digits of the larger number of nx and ny. The function returns the following objects:\n\nA simplicial complex sc::LefschetzComplex.\nA vector coords::Vector{Vector{Float64}} of vertex coordinates.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.create_simplicial_delaunay","page":"Lefschetz Complex Functions","title":"ConleyDynamics.create_simplicial_delaunay","text":"create_simplicial_delaunay(boxw::Real, boxh::Real, pdist::Real, attmpt::Int;\n                           p::Int=2)\n\nCreate a planar Delaunay triangulation inside a box. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe function selects a random sample of points inside the rectangular box [0,boxw] x [0,boxh], while trying to maintain a minimum distance  of pdist between the points. The argument attmpt specifies the number of attempts when trying to add points. A standard value is 20, and larger values tend to fill holes better, but at the expense of runtime. From the random sample, the function then creates a Delaunay triangulation, and returns the following objects:\n\nA simplicial complex sc::LefschetzComplex.\nA vector coords::Vector{Vector{Float64}} of vertex coordinates.\n\nNote that the function does not provide a full triangulation of the given rectangle. Close to the boundary there will be gaps.\n\n\n\n\n\ncreate_simplicial_delaunay(boxw::Real, boxh::Real, npoints::Int;\n                           p::Int=2)\n\nCreate a planar Delaunay triangulation inside a box. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe function selects a random sample of npoints points inside the rectangular box [0,boxw] x [0,boxh]. From the random sample, the function then creates a Delaunay triangulation, and returns the following objects:\n\nA simplicial complex sc::LefschetzComplex.\nA vector coords::Vector{Vector{Float64}} of vertex coordinates.\n\nNote that the function does not provide a full triangulation of the given rectangle. Close to the boundary there will be gaps.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.simplicial_torus","page":"Lefschetz Complex Functions","title":"ConleyDynamics.simplicial_torus","text":"sc = simplicial_torus(p::Int)\n\nCreate a triangulation of the two-dimensional torus.\n\nThe function returns a simplicial complex which represents a two-dimensional torus. The argument p specifies the characteristic of the underlying field. This triangulation is taken from Figure 6.4 in Munkres' book on Algebraic Topology. The boundary vertices are labeled as letters as in the book, the five center vertices are labeled by 1 through 5.\n\nExamples\n\njulia> println(homology(simplicial_torus(0)))\n[1, 2, 1]\n\njulia> println(homology(simplicial_torus(2)))\n[1, 2, 1]\n\njulia> println(homology(simplicial_torus(3)))\n[1, 2, 1]\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.simplicial_klein_bottle","page":"Lefschetz Complex Functions","title":"ConleyDynamics.simplicial_klein_bottle","text":"sc = simplicial_klein_bottle(p::Int)\n\nCreate a triangulation of the two-dimensional Klein bottle.\n\nThe function returns a simplicial complex which represents the two-dimensional Klein bottle. The argument p specifies the characteristic of the underlying field. This triangulation is taken from Figure 6.6 in Munkres' book on Algebraic Topology. The boundary vertices are labeled as letters as in the book, the five center vertices are labeled by 1 through 5.\n\nExamples\n\njulia> println(homology(simplicial_klein_bottle(0)))\n[1, 1, 0]\n\njulia> println(homology(simplicial_klein_bottle(2)))\n[1, 2, 1]\n\njulia> println(homology(simplicial_klein_bottle(3)))\n[1, 1, 0]\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.simplicial_projective_plane","page":"Lefschetz Complex Functions","title":"ConleyDynamics.simplicial_projective_plane","text":"sc = simplicial_projective_plane(p::Int)\n\nCreate a triangulation of the projective plane.\n\nThe function returns a simplicial complex which represents the projective plane. The argument p specifies the characteristic of the underlying field. This triangulation is taken from Figure 6.6 in Munkres' book on Algebraic Topology. The boundary vertices are labeled as letters as in the book, the five center vertices are labeled by 1 through 5.\n\nExamples\n\njulia> println(homology(simplicial_projective_plane(0)))\n[1, 0, 0]\n\njulia> println(homology(simplicial_projective_plane(2)))\n[1, 1, 1]\n\njulia> println(homology(simplicial_projective_plane(3)))\n[1, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.simplicial_torsion_space","page":"Lefschetz Complex Functions","title":"ConleyDynamics.simplicial_torsion_space","text":"sc = simplicial_torsion_space(n::Int, p::Int)\n\nCreate a triangulation of a space with 1-dimensional torsion.\n\nThe function returns a simplicial complex which has the following integer homology groups:\n\nIn dimension 0 it is the group of integers.\nIn dimension 1 it is the integers modulo n.\nIn dimension 2 it is the trivial group.\n\nIn other words, the simplicial complex has nontrivial torsion in dimension 1. It is a triangulation of an n-gon, in which all boundary edges are oriented counterclockwise, and all of these edges are identified. The parameter p specifies the characteristic of the underlying field.\n\nExamples\n\njulia> println(homology(simplicial_torsion_space(6,2)))\n[1, 1, 1]\n\njulia> println(homology(simplicial_torsion_space(6,3)))\n[1, 1, 1]\n\njulia> println(homology(simplicial_torsion_space(6,5)))\n[1, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Cubical-Complexes","page":"Lefschetz Complex Functions","title":"Cubical Complexes","text":"","category":"section"},{"location":"apicore/lefschetz/#ConleyDynamics.create_cubical_complex","page":"Lefschetz Complex Functions","title":"ConleyDynamics.create_cubical_complex","text":"create_cubical_complex(cubes::Vector{String}; p::Int=2)\n\nInitialize a Lefschetz complex from a cubical complex. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe vector cubes contains a list of all the highest-dimensional cubes necessary to define the cubical complex. Every cube is represented as a string as follows:\n\nd integers, which correspond to the coordinates of a point in d-dimensional Euclidean space\na point .\nd integers 0 or 1, which give the interval length in the respective dimension\n\nThe first d integers all have to occupy the same number of characters. In addition, if the occupied space is L characters for each coordinate, the coordinates only can take values from 0 to 10^L - 2. This is due to the fact that the boundary operator will add one to certain coordinates, and they still need to be  representable withing the same L digits.\n\nFor example, the string 030600.101 corresponds to the point (3,6,0) in three dimensions. The dimensions are 1, 0, and 1, and therefore this string corresponds to the cube [3,4] x [6] x [0,1]. The same cube could have also been represented by 360.101 or by 003006000.101.\n\nwarning: Warning\nNote that the labels all have to have the same format!\n\nExample\n\njulia> cubes = [\"00.11\", \"01.01\", \"02.10\", \"11.10\", \"11.01\", \"22.00\"];\n\njulia> lc = create_cubical_complex(cubes);\n\njulia> lc.ncells\n17\n\njulia> homology(lc)\n3-element Vector{Int64}:\n 2\n 1\n 0\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.create_cubical_rectangle","page":"Lefschetz Complex Functions","title":"ConleyDynamics.create_cubical_rectangle","text":"create_cubical_rectangle(nx::Int, ny::Int;\n                         p::Int=2, randomize::Real=0.0)\n\nCreate a cubical complex covering a rectangle in the plane. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe rectangle is given by the subset [0,nx] x [0,ny] of the plane, and each unit square gives a two-dimensional cube in the resulting cubical complex. The function returns the following objects:\n\nA cubical complex cc::LefschetzComplex\nA vector coords::Vector{Vector{Float64}} of vertex coordinates\n\nIf the optional parameter randomize is assigned a positive real fraction r less that 0.5, then the actual coordinates will be randomized. They are chosen uniformly from discs of radius r centered at each vertex.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.create_cubical_box","page":"Lefschetz Complex Functions","title":"ConleyDynamics.create_cubical_box","text":"create_cubical_box(nx::Int, ny::Int, nz::Int;\n                   p::Int=2, randomize::Real=0.0)\n\nCreate a cubical complex covering a box in space. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe box is given by the subset [0,nx] x [0,ny] x [0,nz] of space, and each unit cube gives a three-dimensional cube in the resulting cubical complex. The function returns the following objects:\n\nA cubical complex cc::LefschetzComplex\nA vector coords::Vector{Vector{Float64}} of vertex coordinates\n\nIf the optional parameter randomize is assigned a positive real fraction r less that 0.5, then the actual coordinates will be randomized. They are chosen uniformly from balls of radius r centered at each vertex.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.cube_field_size","page":"Lefschetz Complex Functions","title":"ConleyDynamics.cube_field_size","text":"cube_field_size(cube::String)\n\nDetermine the field sizes of a given cube label.\n\nThe function returns the dimension of the ambient space in the first output parameter pointdim, and the length of the individual coordinate fields in the second return variable pointlen.\n\nExample\n\njulia> cube_field_size(\"011654003020.0110\")\n(4, 3)\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.cube_information","page":"Lefschetz Complex Functions","title":"ConleyDynamics.cube_information","text":"cube_information(cube::String)\n\nCompute a cube's coordinate information.\n\nThe function returns an integer vector with the cubes coordinate information. The return vector intinfo contains in its components the following data:\n\n1:pointdim: Coordinates of the anchor point\n1+pointdim:2*pointdim: Interval length in each dimension\n1+2*pointdim: Dimension of the cube\n\nNote that pointdim equals the dimension of the points specifying the cube.\n\nExample\n\njulia> cube_information(\"011654003.011\")\n7-element Vector{Int64}:\n  11\n 654\n   3\n   0\n   1\n   1\n   2\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.cube_label","page":"Lefschetz Complex Functions","title":"ConleyDynamics.cube_label","text":"cube_label(pointdim::Int, pointlen::Int, pointinfo::Vector{Int})\n\nCreate a label from a cube's coordinate information.\n\nThe dimension of the ambient Eucliden space is pointdim, while the field length for each coordinate is pointlen. The vector pointinfo has to be of length at least two times pointdim. The first pointdim entries contain the coordinates of the anchor point, while the next pointdim entries are either 0 or 1 depending on the size of the interval. For example, if poindim = 3 and pointinfo = [1,2,3,1,0,1], then we represent the cube in three-dimensional space given by [1,2] x [2] x [3 4].\n\nExample\n\njulia> cube_label(3,2,[10,23,5,1,1,0])\n\"102305.110\"\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.get_cubical_coords","page":"Lefschetz Complex Functions","title":"ConleyDynamics.get_cubical_coords","text":"get_cubical_coords(cc::LefschetzComplex)\n\nCompute the vertex coordinates for a cubical complex.\n\nThe variable cc has to contain a cubical complex, and the function returns a vector of coordinates for the vertices of the complex, that can then be used for plotting. ```\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Lefschetz-Complex-Creation","page":"Lefschetz Complex Functions","title":"Lefschetz Complex Creation","text":"","category":"section"},{"location":"apicore/lefschetz/#ConleyDynamics.create_lefschetz_gf2","page":"Lefschetz Complex Functions","title":"ConleyDynamics.create_lefschetz_gf2","text":"create_lefschetz_gf2(defcellbnd)\n\nCreate a Lefschetz complex over GF(2) by specifying its essential cells and boundaries.\n\nThe input argument defcellbnd has to be a vector of vectors. Each entry defcellbnd[k] has to be of one of the following two forms:\n\n[String, Int, String, String, ...]: The first String contains  the label for the cell k, followed by its dimension in the second  entry. The remaining entries are for the labels of the cells which  make up the boundary.\n[String, Int]: This shorther form is for cells with empty boundary. The first entry denotes the cell label, and the second its dimension.\n\nThe cells of the resulting Lefschetz complex correspond to the union of all occurring labels. Cell labels that only occur in the boundary specification are assumed to have empty boundary, and they do not have to be specified separately in the second form above. However, if their boundary is not empty, they have to be listed via the above first form as well.\n\nExamples\n\njulia> defcellbnd = [[\"A\",0], [\"a\",1,\"B\",\"C\"], [\"b\",1,\"B\",\"C\"]];\n\njulia> push!(defcellbnd, [\"c\",1,\"B\",\"C\"]);\n\njulia> push!(defcellbnd, [\"alpha\",2,\"b\",\"c\"]);\n\njulia> lc = create_lefschetz_gf2(defcellbnd);\n\njulia> lc.labels\n7-element Vector{String}:\n \"A\"\n \"B\"\n \"C\"\n \"a\"\n \"b\"\n \"c\"\n \"alpha\"\n\njulia> homology(lc)\n3-element Vector{Int64}:\n 2\n 1\n 0\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_subcomplex","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_subcomplex","text":"lefschetz_subcomplex(lc::LefschetzComplex, subcomp::Vector{Int})\n\nExtract a subcomplex from a Lefschetz complex. The subcomplex has to be locally closed, and is given by the collection of cells in subcomp.\n\n\n\n\n\nlefschetz_subcomplex(lc::LefschetzComplex, subcomp::Vector{String})\n\nExtract a subcomplex from a Lefschetz complex. The subcomplex has to be locally closed, and is given by the collection of cells in subcomp.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_closed_subcomplex","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_closed_subcomplex","text":"lefschetz_closed_subcomplex(lc::LefschetzComplex, subcomp::Vector{Int})\n\nExtract a closed subcomplex from a Lefschetz complex. The subcomplex is the closure of the collection of cells given in subcomp.\n\n\n\n\n\nlefschetz_closed_subcomplex(lc::LefschetzComplex, subcomp::Vector{String})\n\nExtract a closed subcomplex from a Lefschetz complex. The subcomplex is the closure of the collection of cells given in subcomp.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_reduction","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_reduction","text":"lefschetz_reduction(lc::LefschetzComplex, redpairs::Vector{Vector{Int}})\n\nApply a sequence of elementary reductions to a Lefschetz complex.\n\nThe reduction pairs have to be specified in the argument redpairs. Each entry has to be a vector of length two which contains an elementary reduction pair in index form. In particular, the dimensions of the two cells in the pair have to differ by one, and once the pair is reached in the reduction sequence, one cell has to be a face of the other. The function returns a new Lefschetz complex, where all cells in redpairs have been removed.\n\n\n\n\n\nlefschetz_reduction(lc::LefschetzComplex, redpairs::Vector{Vector{String}})\n\nApply a sequence of elementary reductions to a Lefschetz complex.\n\nThe reduction pairs have to be specified in the argument redpairs. Each entry has to be a vector of length two which contains an elementary reduction pair in label form. In particular, the dimensions of the two cells in the pair have to differ by one, and once the pair is reached in the reduction sequence, one cell has to be a face of the other. The function returns a new Lefschetz complex, where all cells in redpairs have been removed.\n\n\n\n\n\nlefschetz_reduction(lc::LefschetzComplex, r1::Int, r2::Int)\n\nApply a single elementary reduction to a Lefschetz complex.\n\nThis method expects that the two cells r1 and r2 which form the reduction pair are given in index form. The function returns the reduced Lefschetz complex.\n\n\n\n\n\nlefschetz_reduction(lc::LefschetzComplex, r1::String, r2::String)\n\nApply a single elementary reduction to a Lefschetz complex.\n\nThis method expects that the two cells r1 and r2 which form the reduction pair are given in label form. The function returns the reduced Lefschetz complex.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.permute_lefschetz_complex","page":"Lefschetz Complex Functions","title":"ConleyDynamics.permute_lefschetz_complex","text":"permute_lefschetz_complex(lc::LefschetzComplex,\n                          permutation::Vector{Int})\n\nPermute the indices of a Lefschetz complex.\n\nThe vector permutation contains a permutation of the indices for the given Lefschetz complex lc. If no permutation is specified, or if the length of the vector is not correct, then a randomly generated one will be used. Note that the permutation has to respect the ordering of the cells by dimension, otherwise an error is raised. In other words,  the permutation has to decompose into permutations within each dimension. This is automatically done if no permutation is explicitly specified.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Lefschetz-Complex-Queries","page":"Lefschetz Complex Functions","title":"Lefschetz Complex Queries","text":"","category":"section"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_information","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_information","text":"lefschetz_information(lc::LefschetzComplex)\n\nExtract basic information about a Lefschetz complex.\n\nThe input argument lc contains the Lefschetz complex. The function returns the information in the form of a Dict{String,Any}. You can use the command keys to see the keyset of the return dictionary:\n\n\"Dimension\": Dimension of the Lefschetz complex\n\"Coefficient field\": Underlying coefficient field\n\"Euler characteristic\": Euler characteristic of the complex\n\"Homology\": Betti numbers of the Lefschetz complex\n\"Boundary sparsity\": Sparsity percentage of the boundary matrix\n\"Number of cells\": Total number of cells in the complex\n\"Cell counts by dim\": Cell counts by dimension\n\nIn the last case, the dictionary entry is a vector of pairs (dimension, cell count).\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_field","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_field","text":"fieldstr = lefschetz_field(lc::LefschetzComplex)\n\nReturns the Lefschetz complex coefficient field.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_is_closed","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_is_closed","text":"lefschetz_is_closed(lc::LefschetzComplex, subcomp::Vector{Int})\n\nDetermine whether a Lefschetz complex subset is closed.\n\n\n\n\n\nlefschetz_is_closed(lc::LefschetzComplex, subcomp::Vector{String})\n\nDetermine whether a Lefschetz complex subset is closed.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_is_locally_closed","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_is_locally_closed","text":"lefschetz_is_locally_closed(lc::LefschetzComplex, subcomp::Vector{Int})\n\nDetermine whether a Lefschetz complex subset is locally closed.\n\n\n\n\n\nlefschetz_is_locally_closed(lc::LefschetzComplex, subcomp::Vector{String})\n\nDetermine whether a Lefschetz complex subset is locally closed.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Topological-Features","page":"Lefschetz Complex Functions","title":"Topological Features","text":"","category":"section"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_boundary","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_boundary","text":"lefschetz_boundary(lc::LefschetzComplex, cellI::Int)\n\nCompute the support of the boundary of a Lefschetz complex cell.\n\nThis method returns the boundary support as a Vector{Int}.\n\n\n\n\n\nlefschetz_boundary(lc::LefschetzComplex, cellS::String)\n\nCompute the support of the boundary of a Lefschetz complex cell.\n\nThis method returns the boundary support as a Vector{String}.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_coboundary","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_coboundary","text":"lefschetz_coboundary(lc::LefschetzComplex, cellI::Int)\n\nCompute the support of the coboundary of a Lefschetz complex cell.\n\nThis method returns the boundary support as a Vector{Int}.\n\n\n\n\n\nlefschetz_coboundary(lc::LefschetzComplex, cellS::String)\n\nCompute the support of the coboundary of a Lefschetz complex cell.\n\nThis method returns the boundary support as a Vector{String}.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_closure","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_closure","text":"lefschetz_closure(lc::LefschetzComplex, subcomp::Vector{Int})\n\nCompute the closure of a Lefschetz complex subset.\n\n\n\n\n\nlefschetz_closure(lc::LefschetzComplex, subcomp::Vector{String})\n\nCompute the closure of a Lefschetz complex subset.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_interior","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_interior","text":"lefschetz_interior(lc::LefschetzComplex, subcomp::Vector{Int})\n\nCompute the interior of a Lefschetz complex subset.\n\n\n\n\n\nlefschetz_interior(lc::LefschetzComplex, subcomp::Vector{String})\n\nCompute the interior of a Lefschetz complex subset.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_topboundary","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_topboundary","text":"lefschetz_topboundary(lc::LefschetzComplex, subcomp::Vector{Int})\n\nCompute the topological boundary of a Lefschetz complex subset.\n\nIn contrast to the algebraic boundary defined via the boundary operator, this function computes the boundary of the Lefschetz complex subset specified in subcomp if the Lefschetz complex is interpreted as a finite topological space. In other words, the topological boundary is the set difference of the closure and the interior of the subset.\n\n\n\n\n\nlefschetz_topboundary(lc::LefschetzComplex, subcomp::Vector{String})\n\nCompute the topological boundary of a Lefschetz complex subset.\n\nIn contrast to the algebraic boundary defined via the boundary operator, this function computes the boundary of the Lefschetz complex subset specified in subcomp if the Lefschetz complex is interpreted as a finite topological space. In other words, the topological boundary is the set difference of the closure and the interior of the subset.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_openhull","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_openhull","text":"lefschetz_openhull(lc::LefschetzComplex, subcomp::Vector{Int})\n\nCompute the open hull of a Lefschetz complex subset.\n\n\n\n\n\nlefschetz_openhull(lc::LefschetzComplex, subcomp::Vector{String})\n\nCompute the open hull of a Lefschetz complex subset.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_lchull","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_lchull","text":"lefschetz_lchull(lc::LefschetzComplex, subcomp::Vector{Int})\n\nCompute the locally closed hull of a Lefschetz complex subset.\n\nThe locally closed hull is the smallest locally closed set which contains the given cells. It is the intersection of the closure and the open hull.\n\n\n\n\n\nlefschetz_lchull(lc::LefschetzComplex, subcomp::Vector{String})\n\nCompute the locally closed hull of a Lefschetz complex subset.\n\nThe locally closed hull is the smallest locally closed set which contains the given cells. It is the intersection of the closure and the open hull.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_clomo_pair","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_clomo_pair","text":"lefschetz_clomopair(lc::LefschetzComplex, subcomp::Vector{Int})\n\nDetermine the closure-mouth-pair associated with a Lefschetz complex subset.\n\nThe function returns the pair (closure,mouth).\n\n\n\n\n\nlefschetz_clomopair(lc::LefschetzComplex, subcomp::Vector{String})\n\nDetermine the closure-mouth-pair associated with a Lefschetz complex subset.\n\nThe function returns the pair (closure,mouth).\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_skeleton","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_skeleton","text":"lefschetz_skeleton(lc::LefschetzComplex, subcomp::Vector{Int}, skdim::Int)\n\nCompute the skdim-dimensional skeleton of a Lefschetz complex subset.\n\nThe computed skeleton is for the closure of the subcomplex given by subcomp.\n\n\n\n\n\nlefschetz_skeleton(lc::LefschetzComplex, subcomp::Vector{String}, skdim::Int)\n\nCompute the skdim-dimensional skeleton of a Lefschetz complex subset.\n\nThe computed skeleton is for the closure of the subcomplex given by subcomp.\n\n\n\n\n\nlefschetz_skeleton(lc::LefschetzComplex, skdim::Int)\n\nCompute the skdim-dimensional skeleton of a Lefschetz complex.\n\nThe computed skeleton is for the full Lefschetz complex.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.manifold_boundary","page":"Lefschetz Complex Functions","title":"ConleyDynamics.manifold_boundary","text":"manifold_boundary(lc::LefschetzComplex)\n\nExtract the manifold boundary from a Lefschetz complex.\n\nThe function expects a Lefschetz complex which represents a compact d-dimensional manifold with boundary. It returns a  list of all cells which lie on the topological boundary of the manifold, in the form of a Vector{Int}.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Filters-on-Lefschetz-Complexes","page":"Lefschetz Complex Functions","title":"Filters on Lefschetz Complexes","text":"","category":"section"},{"location":"apicore/lefschetz/#ConleyDynamics.create_random_filter","page":"Lefschetz Complex Functions","title":"ConleyDynamics.create_random_filter","text":"create_random_filter(lc::LefschetzComplex)\n\nCreate a random injective filter on a Lefschetz complex.\n\nThe function creates a random injective filter on a Lefschetz complex. The filter is created by assigning integers to cell groups, increasing with dimension. Within each dimension the assignment is random, but all filter values of cells of dimension k are less than all filter values of cells with dimension k+1. The function returns the filter as Vector{Int}, with indices corresponding to the cell indices in the Lefschetz complex.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.filter_shallow_pairs","page":"Lefschetz Complex Functions","title":"ConleyDynamics.filter_shallow_pairs","text":"filter_shallow_pairs(lc::LefschetzComplex, phi)\n\nFind all shallow pairs for a filter.\n\nThis function finds all shallow pairs for the filter phi. These are face-coface pairs (x,y) whose dimensions differ by one, and such that y has the smallest filter value on the coboundary of x, and x has the largest filter value on the boundary of y.\n\nIf the filter is injective, these pairs give rise to a Forman vector field on the underlying Lefschetz complex. For noninjective filters this is not true in general.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.filter_induced_mvf","page":"Lefschetz Complex Functions","title":"ConleyDynamics.filter_induced_mvf","text":"filter_induced_mvf(lc::LefschetzComplex, phi)\n\nCompute the multivector field induced by a filter.\n\nThis function returns the smallest multivector field which has the property that every shallow pair is contained in a multivector. For injective filters this is a Forman vector field, but in the noninjective case it can be a general multivector field.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Lefschetz-Helper-Functions","page":"Lefschetz Complex Functions","title":"Lefschetz Helper Functions","text":"","category":"section"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_gfp_conversion","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_gfp_conversion","text":"lcgfp = lefschetz_gfp_conversion(lc::LefschetzComplex, p::Int)\n\nConvert a Lefschetz complex to the same complex over a finite field.\n\nIt is expected that the boundary matrix of the given Lefschetz complex lc is defined over the rationals, and that the target characteristic p is a prime.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_filtration","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_filtration","text":"lefschetz_filtration(lc::LefschetzComplex, fvalues::Vector{Int})\n\nCompute a filtration on a Lefschetz subset.\n\nThe considered Lefschetz complex is given in lc. The vector fvalues assigns an integer between 0 and N to every cell in lc. For every k the complex L_k is given by the closure of all cells with values between 1 and k. The function returns the following variables:\n\nlcsub: The subcomplex L_N\nfvalsub: The filtration on the subcomplex with values 1,...,N\n\nExample\n\njulia> labels = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"];\n\njulia> simplices = [[\"A\",\"B\",\"D\"],[\"B\",\"D\",\"E\"],[\"B\",\"C\",\"E\"],[\"C\",\"E\",\"F\"],[\"F\",\"G\"]];\n\njulia> sc = create_simplicial_complex(labels,simplices);\n\njulia> filtration = [0,0,0,0,0,0,0,1,1,0,1,2,0,4,2,4,0,5,3,7,6];\n\njulia> lcsub, fvalsub = lefschetz_filtration(sc,filtration);\n\njulia> phinf, phint = persistent_homology(lcsub,fvalsub);\n\njulia> phinf\n3-element Vector{Vector{Int64}}:\n [1]\n []\n []\n\njulia> phint\n3-element Vector{Vector{Tuple{Int64, Int64}}}:\n []\n [(1, 5), (2, 7), (4, 6)]\n []\n\n\n\n\n\nlefschetz_filtration(lc::LefschetzComplex, strfilt::Vector{Vector{String}})\n\nCompute a filtration on a Lefschetz subset.\n\nThe considered Lefschetz complex is given in lc. The vector of string vectors strfilt contains the necessary simplices to build the filtration. The list strfilt[k] contains the simplices that are added at the k-th step, together with their closures. Thus, for every k the complex L_k is given by the closure of all cells listed in strfilt[i] for i between 1 and k. The function returns the following variables:\n\nlcsub: The subcomplex L_N, where N = length(strfilt)\nfvalsub: The filtration on the subcomplex with values 1,...,N\n\nExample\n\njulia> labels = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"];\n\njulia> simplices = [[\"A\",\"B\",\"D\"],[\"B\",\"D\",\"E\"],[\"B\",\"C\",\"E\"],[\"C\",\"E\",\"F\"],[\"F\",\"G\"]];\n\njulia> sc = create_simplicial_complex(labels,simplices);\n\njulia> strfiltration = [[\"AB\",\"AD\",\"BD\"],[\"BE\",\"DE\"],[\"BCE\"],[\"CF\",\"EF\"],[\"ABD\"],[\"CEF\"],[\"BDE\"]];\n\njulia> lcsub, fvalsub = lefschetz_filtration(sc, strfiltration);\n\njulia> phinf, phint = persistent_homology(lcsub,fvalsub);\n\njulia> phinf\n3-element Vector{Vector{Int64}}:\n [1]\n []\n []\n\njulia> phint\n3-element Vector{Vector{Tuple{Int64, Int64}}}:\n []\n [(1, 5), (2, 7), (4, 6)]\n []\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Cell-Subset-Helper-Functions","page":"Lefschetz Complex Functions","title":"Cell Subset Helper Functions","text":"","category":"section"},{"location":"apicore/lefschetz/#ConleyDynamics.convert_cells","page":"Lefschetz Complex Functions","title":"ConleyDynamics.convert_cells","text":"convert_cells(lc::LefschetzComplex, cl::Vector{Int})\n\nConvert cell list cl in the Lefschetz complex lc from  index form to label form.\n\n\n\n\n\nconvert_cells(lc::LefschetzComplex, cl::Vector{String})\n\nConvert cell list cl in the Lefschetz complex lc from  label form to index form.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.convert_cellsubsets","page":"Lefschetz Complex Functions","title":"ConleyDynamics.convert_cellsubsets","text":"convert_cellsubsets(lc::LefschetzComplex, clsub::Vector{Vector{Int}})\n\nConvert CellSubsets clsub in the Lefschetz complex lc from  index form to label form.\n\n\n\n\n\nconvert_cellsubsets(lc::LefschetzComplex, clsub::Vector{Vector{String}})\n\nConvert CellSubsets clsub in the Lefschetz complex lc from  label form to index form.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Coordinate-Helper-Functions","page":"Lefschetz Complex Functions","title":"Coordinate Helper Functions","text":"","category":"section"},{"location":"apicore/lefschetz/#ConleyDynamics.convert_planar_coordinates","page":"Lefschetz Complex Functions","title":"ConleyDynamics.convert_planar_coordinates","text":"convert_planar_coordinates(coords::Vector{Vector{Float64}},\n                           p0::Vector{Float64},\n                           p1::Vector{Float64})\n\nConvert a given collection of planar coordinates.\n\nThe vector coords contains pairs of coordinates, which are then transformed to fit into the box with vertices p0 = (p0x,p0y) and p1 = (p1x,p1y). It is assumed that p0 denotes the lower left box corner, while p1 is the upper right corner. The function shifts and scales the coordinates in such a way that every side of the box contains at least one point. Upon completion, it returns a new coordinate vector coordsNew.\n\nMore precisely, if the x-coordinates are spanning the interval [xmin,xmax] and the y-coordinates span [ymin,ymax], then the point (x,y) is transformed to (xn,yn) with:\n\nxn = p0x + (p1x-p0x) * (x-cxmin) / (cxmax-cxmin)\nyn = p0y + (p1y-p0y) * (y-cymin) / (cymax-cymin)\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.convert_spatial_coordinates","page":"Lefschetz Complex Functions","title":"ConleyDynamics.convert_spatial_coordinates","text":"convert_spatial_coordinates(coords::Vector{Vector{Float64}},\n                            p0::Vector{Float64},\n                            p1::Vector{Float64})\n\nConvert a given collection of spatial coordinates.\n\nThe vector coords contains triples of coordinates, which are then transformed to fit into the box with vertices p0 = (p0x,p0y,p0z) and p1 = (p1x,p1y,p1z). It is assumed that each coordinate of p0 is strictly smaller than the corresponding coordinate of p1. The function shifts and scales the coordinates in such a way that every side of the box contains at least one point. Upon completion, it returns a new coordinate vector coordsNew.\n\nMore precisely, if the x-coordinates are spanning the interval [xmin,xmax], the y-coordinates span [ymin,ymax], and the z-coordinates span [zmin,zmax], then the point (x,y,z) is transformed to (xn,yn,zn) with:\n\nxn = p0x + (p1x-p0x) * (x-cxmin) / (cxmax-cxmin)\nyn = p0y + (p1y-p0y) * (y-cymin) / (cymax-cymin)\nzn = p0z + (p1z-p0z) * (z-czmin) / (czmax-czmin)\n\n\n\n\n\n","category":"function"},{"location":"#ConleyDynamics.jl","page":"Overview","title":"ConleyDynamics.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Conley index and multivector fields for Julia.","category":"page"},{"location":"#Introduction","page":"Overview","title":"Introduction","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"ConleyDynamics.jl is a Julia package for studying combinatorial multivector fields using Conley theory. The multivector fields can be studied on arbitrary Lefschetz complexes, which include both simplicial and cubical complexes as important special cases. The concept of combinatorial multivector field generalizes Forman vector fields, which were originally introduced to study Morse theory in a discrete combinatorial setting.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"note: Note\nThis documentation is also available in PDF format: ConleyDynamics.pdf.","category":"page"},{"location":"#Features","page":"Overview","title":"Features","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Data structures for Lefschetz complexes, in particular simplicial and cubical complexes.\nClassical Forman combinatorial vector fields and multivector fields are supported.\nComputation of Conley indices, connection matrices, and Conley-Morse graphs.\nBasic homology algorithms over finite fields and the rationals, including persistent homology and relative homology.\nAlgorithms rely on a built-in sparse matrix implementation which is geared towards computations over finite fields and the rationals.","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"To use ConleyDynamics.jl please install Julia 1.10 or higher. See https://julialang.org/downloads/ for instructions on how to obtain Julia for your system.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"At the Julia prompt simply type","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> using Pkg; Pkg.add(\"ConleyDynamics\")","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"After Julia has finished downloading and precompiling the package and all of its dependencies, you can start using it by typing","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> using ConleyDynamics","category":"page"},{"location":"#Manual-Outline","page":"Overview","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The Tutorial briefly explains how to get started with ConleyDynamics.jl. More details, including on the underlying mathematics, are provided in the following three sections, which cover Lefschetz complexes, homology, and Conley theory including connection matrices. After a discussion of all included examples in the Examples section, the manual concludes with a description of the sparse matrix format underlying the package.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Pages = [\n    \"man/tutorial.md\",\n    \"man/lefschetz.md\",\n    \"man/homology.md\",\n    \"man/conley.md\",\n    \"man/examples.md\",\n    \"man/sparse.md\",\n]\nDepth = 2","category":"page"},{"location":"apicore/datastruct/#Composite-Data-Structures","page":"Composite Data Structures","title":"Composite Data Structures","text":"","category":"section"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"The package relies on a number of basic composite data structures that encompass more complicated objects. For the internal representation of sparse matrices we refer to Internal Sparse Matrix Representation.","category":"page"},{"location":"apicore/datastruct/#ConleyDynamics","page":"Composite Data Structures","title":"ConleyDynamics","text":"module ConleyDynamics\n\nCollection of tools for computational Conley theory.\n\n\n\n\n\n","category":"module"},{"location":"apicore/datastruct/#Lefschetz-Complex-Type","page":"Composite Data Structures","title":"Lefschetz Complex Type","text":"","category":"section"},{"location":"apicore/datastruct/#ConleyDynamics.LefschetzComplex","page":"Composite Data Structures","title":"ConleyDynamics.LefschetzComplex","text":"LefschetzComplex\n\nCollect the Lefschetz complex information in a struct.\n\nThe struct is created via the following fields:\n\nlabels::Vector{String}: Vector of labels associated with cell indices\ndimensions::Vector{Int}: Vector cell dimensions\nboundary::SparseMatrix: Boundary matrix, columns give the cell boundaries\n\nIt is expected that the dimensions are given in increasing order, and that the square of the boundary matrix is zero. Otherwise, exceptions are raised. In addition, the following fields are created during initialization:\n\nncells::Int: Number of cells\ndim::Int: Dimension of the complex\nindices::Dict{String,Int}: Dictionary for finding cell index from label\n\nThe coefficient field is specified by the boundary matrix.\n\nwarning: Warning\nNote that the constructor does not check whether the boundary matrix squares to zero. It is the responsibility of the user to ensure that!\n\n\n\n\n\n","category":"type"},{"location":"apicore/datastruct/#Cell-Subset-Types","page":"Composite Data Structures","title":"Cell Subset Types","text":"","category":"section"},{"location":"apicore/datastruct/#ConleyDynamics.Cells","page":"Composite Data Structures","title":"ConleyDynamics.Cells","text":"Cells = Union{Vector{Int},Vector{String}}\n\nA list of cells of a Lefschetz complex.\n\nThis data type is used to represent subsets of a Lefschetz complex. It is used for individual isolated invariant sets, locally closed subsets, and multivectors.\n\n\n\n\n\n","category":"type"},{"location":"apicore/datastruct/#ConleyDynamics.CellSubsets","page":"Composite Data Structures","title":"ConleyDynamics.CellSubsets","text":"CellSubsets = Union{Vector{Vector{Int}},Vector{Vector{String}}}\n\nA collection of cell lists.\n\nThis data type is used to represent a collection of subsets of a Lefschetz complex. It is used for Morse decompositions and for multivector fields.\n\n\n\n\n\n","category":"type"},{"location":"apicore/datastruct/#Conley-Morse-Graph-Type","page":"Composite Data Structures","title":"Conley-Morse Graph Type","text":"","category":"section"},{"location":"apicore/datastruct/#ConleyDynamics.ConleyMorseCM","page":"Composite Data Structures","title":"ConleyDynamics.ConleyMorseCM","text":"ConleyMorseCM{T}\n\nCollect the connection matrix information in a struct.\n\nThe struct has the following fields:\n\nmatrix::SparseMatrix{T}: Connection matrix\ncolumns::Vector{Int}: Corresponding columns in the boundary matrix\nposet::Vector{Int}: Poset indices for the connection matrix columns\nlabels::Vector{String}: Labels for the connection matrix columns\nmorse::Vector{Vector{String}}: Vector of Morse sets in original complex\nconley::Vector{Vector{Int}}: Vector of Conley indices for the Morse sets\ncomplex::LefschetzComplex: The Conley complex as a Lefschetz complex\n\n\n\n\n\n","category":"type"}]
}
