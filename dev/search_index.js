var documenterSearchIndex = {"docs":
[{"location":"apicore/homology/#Homology-Functions","page":"Homology Functions","title":"Homology Functions","text":"","category":"section"},{"location":"apicore/homology/#Regular-Homology","page":"Homology Functions","title":"Regular Homology","text":"","category":"section"},{"location":"apicore/homology/","page":"Homology Functions","title":"Homology Functions","text":"homology(::LefschetzComplex;::Int)\nrelative_homology(::LefschetzComplex,::Union{Vector{Int},Vector{String}};::Int)","category":"page"},{"location":"apicore/homology/#ConleyDynamics.homology-Tuple{LefschetzComplex}","page":"Homology Functions","title":"ConleyDynamics.homology","text":"betti = homology(lc::LefschetzComplex; p::Int=2)\n\nCompute the homology of a Lefschetz complex.\n\nThe homology is computed over the finite field GF(p) and is returned as a vector betti of Betti numbers, where betti[k] is the Betti number in dimension k-1.\n\n\n\n\n\n","category":"method"},{"location":"apicore/homology/#ConleyDynamics.relative_homology-Tuple{LefschetzComplex, Union{Vector{Int64}, Vector{String}}}","page":"Homology Functions","title":"ConleyDynamics.relative_homology","text":"betti = relative_homology(lc::LefschetzComplex,\n                          subc::Union{Vector{Int},Vector{String}};\n                          p::Int=2)\n\nCompute the relative homology of a Lefschetz complex with respect to a subcomplex.\n\nThe subcomplex is the closure of the cells in subc, which can be given either as indices or labels. The homology is computed over the finite field GF(p) and is returned as a vector betti of Betti numbers, where betti[k] is the Betti number in dimension k-1.\n\n\n\n\n\n","category":"method"},{"location":"apicore/homology/#Persistent-Homology","page":"Homology Functions","title":"Persistent Homology","text":"","category":"section"},{"location":"apicore/homology/","page":"Homology Functions","title":"Homology Functions","text":"persistent_homology(::LefschetzComplex,::Vector{Int};::Int)","category":"page"},{"location":"apicore/homology/#ConleyDynamics.persistent_homology-Tuple{LefschetzComplex, Vector{Int64}}","page":"Homology Functions","title":"ConleyDynamics.persistent_homology","text":"phsingles, phpairs = persistent_homology(lc::LefschetzComplex,\n                                         filtration::Vector{Int};\n                                         p::Int=2)\n\nComplete the persistent homology of a Lefschetz complex filtration.\n\nThe function assumes that the order given by the filtration values is admissible, i.e., the permuted boundary matrix is strictly upper triangular. The persistence computation is performed over the finite field GF(p). The function returns the starting filtration values for infinite length persistence intervals in phsingles, and the birth- and death-filtration values for finite length persistence intervals in phpairs.\n\n\n\n\n\n","category":"method"},{"location":"apicore/homology/#Reduction-Algorithm","page":"Homology Functions","title":"Reduction Algorithm","text":"","category":"section"},{"location":"apicore/homology/","page":"Homology Functions","title":"Homology Functions","text":"ph_reduce!(::SparseMatrix;::Bool)","category":"page"},{"location":"apicore/homology/#ConleyDynamics.ph_reduce!-Tuple{SparseMatrix}","page":"Homology Functions","title":"ConleyDynamics.ph_reduce!","text":"phsingles, phpairs = ph_reduce!(matrix::SparseMatrix)\nphsingles, phpairs, basis = ph_reduce!(matrix::SparseMatrix;\n                                       returnbasis=true)\n\nApply the persistence reduction algorithm to the matrix.\n\nThe function assumes that matrix is strictly upper triangular. It returns the starting columns for infinite length persistence intervals in phsingles, and the birth- and death-columns for finite length persistence intervals in phpairs. If the optional argument returnbasis=true is given, then the function also returns the computed basis matrix B with reduced = matrix * B.\n\n\n\n\n\n","category":"method"},{"location":"man/guide/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"In this tutorial we explain the basic usage of the main components of ConleyDynamics. It is not meant to be exhaustive, since more  details will be provided in the more indiviualized sections. Also, precise mathematical definitions will be delayed until then.","category":"page"},{"location":"man/guide/#Creating-Lefschetz-Complexes","page":"Tutorial","title":"Creating Lefschetz Complexes","text":"","category":"section"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"The fundamental mathematical object for ConleyDynamics is a Lefschetz complex. For now we note that both simplicial complexes and cubical complexes are special cases, and ConleyDynamics provides convenient interfaces for generating them.","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"We begin by considering the case of a simplicial complex. Recall that an abstract simplicial complex K is just a collection of finite sets, called simplices, which is closed under taking subsets. In other words, every subset of a simplex is again a simplex. Each simplex has an associated dimension, which is one less than the  number of its elements. One usually calls simplices of dimension 0 vertices, edges have dimension 1, and simplices of dimension 2 are triangles. It follows easily from these definitions that every simplex is the union of its vertices.","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"In ConleyDynamics it is easy to generate a simplicial complex. This requires two objects:","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"The vertices are described by a vector labels of string labels for the vertices of the simplicial complex. Thus, the length of the vector equals the number of vertices, and the k-th entry is the label for the k-th vertex.\nIn addition, a second vector simplices has to describe enough simplices so that the simplicial complex is determined. This object is a vector of vectors, and the vector simplices[k] describes the index values of all the vertices in the k-th simplex. These indices are precisely the corresponding locations of the vertices in labels.","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"tip: Simplices via labels\nIt is also possible to specify the list of simplices using a Vector{Vector{String}}, i.e., as a vector of string vectors. In this case, the entry simplices[k] is a list of the labels of the vertices.","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"warning: Watch the label length\nIt is expected that the labels in labels all have the same number of characters. This is due to the fact that when creating the simplicial complex, ConleyDynamics automatically creates  labels for each of the simplices in K, by concatenating the vertex labels. Not using a fixed label size could lead to  ambiguities, and will therefore raise an error message.","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"The following first example creates a simple simplicial complex. It consists of six vertices which we label by the first six letters.","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"using ..ConleyDynamics # hide\nlabels = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\nsimplices = [[\"A\",\"B\"],[\"A\",\"C\"],[\"B\",\"C\"],[\"B\",\"D\"],[\"D\",\"E\",\"F\"]]\nsc = create_simplicial_complex(labels,simplices)\nfieldnames(typeof(sc))","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"Based on the simplex specifications, the generated simplicial complex K consists of three edges connecting each of the vertices A, B, and C, a two-dimensional triangle DEF, as well as the edge BD which connects the triangle boundary and the filled triangle. The created struct sc is of type LefschetzComplex, with fieldnames as indicated in the above output. The number of cells in the complex can be seen as follows:","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"println(sc.ncells)","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"Note that the final simplicial complex has a total of seven edges, since also the edges of DEF are part of the simplicial complex. They are automatically generated by create_simplicial_complex. The dimension of K is the largest simplex dimensions, and can be seen via","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"println(sc.dim)","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"println(sc.labels)","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"println(sc.dimensions)","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"println(sc.indices)","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"println(sc.boundary)","category":"page"},{"location":"man/guide/#Computing-Homology-and-Persistence","page":"Tutorial","title":"Computing Homology and Persistence","text":"","category":"section"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"homology(sc,p=0)","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"relative_homology(sc, [1,6], p=0)","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"filtration = [1,1,1,2,2,2,1,1,1,3,2,2,2,4]\nphsingles, phpairs = persistent_homology(sc, filtration, p=2)","category":"page"},{"location":"man/guide/#Finding-Connection-Matrices","page":"Tutorial","title":"Finding Connection Matrices","text":"","category":"section"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"(Image: The logo multivector field)","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"We begin by discussion an elementary example from Mrozek & Wanner[1].","category":"page"},{"location":"man/guide/","page":"Tutorial","title":"Tutorial","text":"[1]: Marian Mrozek, Thomas Wanner: Connection matrices in combinatorial topological dynamics, Preprint, submitted for publication, 115 pp, 2023.","category":"page"},{"location":"man/guide/#Working-with-Sparse-Matrices","page":"Tutorial","title":"Working with Sparse Matrices","text":"","category":"section"},{"location":"man/lefschetz/#Lefschetz-Complexes","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Here we need a more detailed description of Lefschetz complexes. In particular, this should discuss the various field types that can be used, as well as all the entries in the LefschetzComplex data structure.","category":"page"},{"location":"man/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"In the following we discuss a number of connection matrix examples.","category":"page"},{"location":"man/examples/#Critical-flow-on-a-simplex","page":"Examples","title":"Critical flow on a simplex","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_critical_simplex(::Int)","category":"page"},{"location":"man/examples/#ConleyDynamics.example_critical_simplex-Tuple{Int64}","page":"Examples","title":"ConleyDynamics.example_critical_simplex","text":"lc, mvf = example_critical_simplex(dim)\n\nCreate a simplicial complex of dimension dim as well as a multivector field on it in which every cell is critical.\n\nExamples\n\njulia> lc, mvf = example_critical_simplex(2);\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.cm)\n[0   0   0   1   1   0   0]\n[0   0   0   1   0   1   0]\n[0   0   0   0   1   1   0]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"A\", \"B\", \"C\", \"AB\", \"AC\", \"BC\", \"ABC\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#Combinatorial-flows-on-a-cylinder-and-a-Moebius-strip","page":"Examples","title":"Combinatorial flows on a cylinder and a Moebius strip","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_moebius()","category":"page"},{"location":"man/examples/#ConleyDynamics.example_moebius-Tuple{}","page":"Examples","title":"ConleyDynamics.example_moebius","text":"lc1, mvf1, lc2, mvf2 = example_moebius()\n\nCreate two simplicial complexes for a cylinder and Moebius strip, respectively, together with associated multivector fields on them.\n\nThe multivector field is the same, and it has one critical  cell each in dimension 1 and 2 in the interior of the strip. The boundary consists of two periodic orbits for lc1 and mvf1, and of one periodic orbit in the Moebius case lc2 and mvf2. The latter case leads to different connection matrices for the fields GFP(2) and GFP(7), for example.\n\nExamples\n\njulia> lc1, mvf1, lc2, mvf2 = example_moebius();\n\njulia> cmp2 = connection_matrix(lc2, mvf2; p=2);\n\njulia> cmp7 = connection_matrix(lc2, mvf2; p=7);\n\njulia> sparse_show(cmp2.cm)\n[0   0   0   0]\n[0   0   0   1]\n[0   0   0   0]\n[0   0   0   0]\n\njulia> sparse_show(cmp7.cm)\n[0   0   0   0]\n[0   0   0   1]\n[0   0   0   2]\n[0   0   0   0]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#Nonunique-connection-matrices","page":"Examples","title":"Nonunique connection matrices","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: An example with nonunique connection matrices)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_nonunique()","category":"page"},{"location":"man/examples/#ConleyDynamics.example_nonunique-Tuple{}","page":"Examples","title":"ConleyDynamics.example_nonunique","text":"lc1, lc2, mvf = example_nonunique()\n\nCreate two representations of a simplicial complex and one multivector field which illustrates nonunique connection matrices.\n\nThe two complexes lc1 and lc2 represent the same simplicial complex, but differ in the ordering of the labels.\n\nExamples\n\njulia> lc1, lc2, mvf = example_nonunique();\n\njulia> cm1 = connection_matrix(lc1, mvf);\n\njulia> cm2 = connection_matrix(lc2, mvf);\n\njulia> sparse_show(cm1.cm)\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   0   0   0   0   1   1]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm1.labels)\n[\"1\", \"6\", \"68\", \"18\", \"34\", \"56\", \"057\", \"238\", \"678\"]\njulia> sparse_show(cm2.cm)\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   0   0   0   1   0   1]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm2.labels)\n[\"1\", \"7\", \"67\", \"18\", \"34\", \"56\", \"057\", \"238\", \"678\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#Examples-from-MW-2023","page":"Examples","title":"Examples from MW-2023","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The following examples are taken from the paper Connection matrices in combinatorial topological dynamics by Marian Mrozek & Thomas Wanner (Preprint, submitted for publication, 115 pp, 2023).","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: Four sample combinatorial vector fields)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_MW_fig02()","category":"page"},{"location":"man/examples/#ConleyDynamics.example_MW_fig02-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig02","text":"lc, mvf = example_MW_fig02(mvftype)\n\nCreate the simplicial complex and multivector field for the example from Figure 2 in the connection matrix paper by Mrozek & Wanner.\n\nDepending on the value of mvftype, return the periodic orbit (0=default) or one of the three gradient (1,2,3) examples.\n\nExamples\n\njulia> lc, mvf = example_MW_fig02(0);\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> cm.cm\n[0   0   0   1   1   0   0   0]\n[0   0   0   1   1   0   0   0]\n[0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   0   1]\n[0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"A\", \"C\", \"CE\", \"AC\", \"BD\", \"DF\", \"ABC\", \"EFG\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_MW_fig01()\nexample_MW_fig03()\nexample_MW_fig04()\nexample_MW_fig11()","category":"page"},{"location":"man/examples/#ConleyDynamics.example_MW_fig01-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig01","text":"lcomplex, mvf = example_MW_fig01()\n\nCreate the simplicial complex and multivector field for the example from Figure 1 in the connection matrix paper by Mrozek & Wanner.\n\nExamples\n\njulia> lc, mvf = example_MW_fig01();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.cm)\n[0   0   0]\n[0   0   1]\n[0   0   0]\n\njulia> print(cm.labels)\n[\"D\", \"AC\", \"ABC\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#ConleyDynamics.example_MW_fig03-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig03","text":"lc, mvf = example_MW_fig03()\n\nCreate the Lefschetz complex and multivector field for the example from Figure 3 in the connection matrix paper by Mrozek & Wanner.\n\nExamples\n\njulia> lc, mvf = example_MW_fig03();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.cm)\n[0   0   0   0]\n[0   0   0   0]\n[0   0   0   0]\n[0   0   0   0]\n\njulia> print(cm.labels)\n[\"BD\", \"DF\", \"AC\", \"CE\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#ConleyDynamics.example_MW_fig04-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig04","text":"lc1, lc2, mvf = example_MW_fig04()\n\nCreate two representations of the Lefschetz complex and the multivector field for the example from Figure 4 in the connection matrix paper by Mrozek & Wanner.\n\nThe complexes lc1 and lc2 are just two representations of the same complex, but they lead to different connection matrices.\n\nExamples\n\njulia> lc1, lc2, mvf = example_MW_fig04();\n\njulia> cm1 = connection_matrix(lc1, mvf);\n\njulia> cm2 = connection_matrix(lc2, mvf);\n\njulia> cm1.cm\n4×4 Matrix{Nemo.fpFieldElem}:\n 0  0  0  0\n 0  0  0  1\n 0  0  0  1\n 0  0  0  0\n\njulia> cm2.cm\n4×4 Matrix{Nemo.fpFieldElem}:\n 0  0  0  0\n 0  0  0  0\n 0  0  0  1\n 0  0  0  0\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#ConleyDynamics.example_MW_fig11-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig11","text":"lc, mvf = example_MW_fig11(mvftype)\n\nCreate the Lefschetz complex and multivector field for the example from Figure 11 in the connection matrix paper by Mrozek & Wanner.\n\nDepending on the value of mvftype, return the multivector (0=default) or one of the two combinatorial vector field (1,2) examples.\n\nExamples\n\njulia> lc, mvf = example_MW_fig11(1);\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> cm.cm\n5×5 Matrix{Nemo.fpFieldElem}:\n 0  0  1  1  1\n 0  0  1  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#Examples-from-BKMW-2020","page":"Examples","title":"Examples from BKMW-2020","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The following examples are taken from the paper Linking combinatorial and classical dynamics: Conley index and Morse decompositions by Bogdan Batko, Tomasz Kaczynski, Marian Mrozek, and Thomas Wanner (Foundations of Computational Mathematics 20(5), pp. 967-1012, 2020).","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_BKMW20_fig1()\nexample_BKMW20_fig3()","category":"page"},{"location":"man/examples/#ConleyDynamics.example_BKMW20_fig1-Tuple{}","page":"Examples","title":"ConleyDynamics.example_BKMW20_fig1","text":"lc, mvf = example_BKMW20_fig1()\n\nCreate the simplicial complex and multivector field for the example from Figure 1 in the FoCM 2020 paper by Batko, Kaczynski, Mrozek, and Wanner.\n\nExamples\n\njulia> lc, mvf = example_BKMW20_fig1();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.cm)\n[0   0   0   0   1]\n[0   0   0   0   0]\n[0   0   0   0   1]\n[0   0   0   0   0]\n[0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"A\", \"AD\", \"F\", \"BF\", \"DE\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#ConleyDynamics.example_BKMW20_fig3-Tuple{}","page":"Examples","title":"ConleyDynamics.example_BKMW20_fig3","text":"lc, mvf = example_BKMW20_fig3()\n\nCreate the simplicial complex and multivector field for the example from Figure 3 in the FoCM 2020 paper by Batko, Kaczynski, Mrozek, and Wanner.\n\nExamples\n\njulia> lc, mvf = example_BKMW20_fig3();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.cm)\n[0   0   0   0   1   0   1   0   0]\n[0   0   0   0   0   1   0   0   0]\n[0   0   0   0   1   1   1   0   0]\n[0   0   0   0   0   0   0   0   1]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"D\", \"E\", \"F\", \"GJ\", \"BF\", \"EF\", \"HI\", \"ADE\", \"FGJ\"]\n\n\n\n\n\n","category":"method"},{"location":"man/connections/#Connection-Matrices","page":"Connection Matrices","title":"Connection Matrices","text":"","category":"section"},{"location":"man/connections/","page":"Connection Matrices","title":"Connection Matrices","text":"Here we need a more detailed description of connection matrices. In particular, this should discuss the various field types that can be used, as well as all the entries in the ConleyMorseCM data structure.","category":"page"},{"location":"man/homology/#Homology","page":"Homology","title":"Homology","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Conley's theory for the qualitative study of dynamical systems is based on fundamental concepts from algebraic topology. One of these is homology, which studies the topological properties of spaces. As part of ConleyDynamics a number of homology methods are included. These are described in detail  below.","category":"page"},{"location":"man/homology/#Homology-of-Lefschetz-Complexes","page":"Homology","title":"Homology of Lefschetz Complexes","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"As we saw earlier, a Lefschetz complex is a collection of cells which associated nonnegative dimensions, together with a boundary map.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   ldots stackrelpartial_k+2longrightarrow\n   C_k+1(L) stackrelpartial_k+1longrightarrow\n   C_k(L) stackrelpartial_klongrightarrow\n   C_k-1(L) stackrelpartial_k-1longrightarrow ldots\n   stackrelpartial_1longrightarrow\n   C_0(L) longrightarrow 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The boundary map partial_k is a linear map from the chain group C_k(L) to the chain group C_k-1(L). Since ConleyDynamics uses only field coefficients, these chain groups are in fact vector spaces. As such, any linear map induces two important subspaces, which in the context of algebraic topology are called as follows:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The elements of the subspace Z_k(L) subset C_k(L) = mathrmker partial_k are called the k-cycles of L.\nThe elements of the subspace B_k(L) subset C_k(L) = mathrmim partial_k+1 are called the k-boundaries of L.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Recall that the fundamental property of the boundary map is the identity partial^2 = 0, i.e., its square vanishes. Using the dimension-induced gradation mentioned above, this can be reformulated as the equation partial_k circ partial_k+1 = 0. This immmediately implies the subspace inclusion B_k(L) subset Z_k(L), and we can therefore define the quotient space","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   H_k(L) =\n   mathrmkerpartial_k  mathrmimpartial_k+1","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This vector space is called the k-th homology group of the Lefschetz  complex L.","category":"page"},{"location":"man/homology/#Relative-Homology","page":"Homology","title":"Relative Homology","text":"","category":"section"},{"location":"man/homology/#Persistent-Homology-of-Filtrations","page":"Homology","title":"Persistent Homology of Filtrations","text":"","category":"section"},{"location":"apicore/utils/#Utility-Functions","page":"Utility Functions","title":"Utility Functions","text":"","category":"section"},{"location":"apicore/utils/#Simplicial-Complexes","page":"Utility Functions","title":"Simplicial Complexes","text":"","category":"section"},{"location":"apicore/utils/","page":"Utility Functions","title":"Utility Functions","text":"create_simplicial_complex(::Vector{String},::Vector{Vector{Int}})\ncreate_simplicial_complex(::Vector{String},::Vector{Vector{String}})\nconvert_simplices(::Vector{Vector{Int}},::Vector{String})\nconvert_simplices(::Vector{Vector{String}},::Vector{String})","category":"page"},{"location":"apicore/utils/#ConleyDynamics.create_simplicial_complex-Tuple{Vector{String}, Vector{Vector{Int64}}}","page":"Utility Functions","title":"ConleyDynamics.create_simplicial_complex","text":"lc = create_simplicial_complex(labels::Vector{String},\n                               simplices::Vector{Vector{Int}})\n\nInitialize a Lefschetz complex from a simplicial complex.\n\nThe vector labels contains a label for every vertex, while simplices contains all the highest-dimensional simplices necessary to define the simplicial complex. Every simplex is represented as a vector of Int, with entries corresponding to the vertex indices.\n\nNote that the labels all have to have the same character length!\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.create_simplicial_complex-Tuple{Vector{String}, Vector{Vector{String}}}","page":"Utility Functions","title":"ConleyDynamics.create_simplicial_complex","text":"lc = create_simplicial_complex(labels::Vector{String},\n                               simplices::Vector{Vector{String}})\n\nInitialize a Lefschetz complex from a simplicial complex.\n\nThe vector labels contains a label for every vertex, while simplices contains all the highest-dimensional simplices necessary to define the simplicial complex.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.convert_simplices-Tuple{Vector{Vector{Int64}}, Vector{String}}","page":"Utility Functions","title":"ConleyDynamics.convert_simplices","text":"newsimplicies = convert_simplices(simplices::Vector{Vector{Int}},\n                                  labels::Vector{String})\n\nConvert list of simplices from index form to label form.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.convert_simplices-Tuple{Vector{Vector{String}}, Vector{String}}","page":"Utility Functions","title":"ConleyDynamics.convert_simplices","text":"newsimplicies = convert_simplices(simplices::Vector{Vector{String}},\n                                  labels::Vector{String})\n\nConvert list of simplices from label form to index form.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#Lefschetz-complexes","page":"Utility Functions","title":"Lefschetz complexes","text":"","category":"section"},{"location":"apicore/utils/","page":"Utility Functions","title":"Utility Functions","text":"lefschetz_closure(::LefschetzComplex,::Vector{Int})\nlefschetz_closure(::LefschetzComplex,::Vector{String})\npermute_lefschetz_complex(::LefschetzComplex,::Vector{Int})\nconvert_lefschetz_sparse(::LefschetzComplex)","category":"page"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_closure-Tuple{LefschetzComplex, Vector{Int64}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_closure","text":"c = lefschetz_closure(lc::LefschetzComplex, subcomp::Vector{Int})\n\nCompute the closure of a Lefschetz complex subset.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.lefschetz_closure-Tuple{LefschetzComplex, Vector{String}}","page":"Utility Functions","title":"ConleyDynamics.lefschetz_closure","text":"c = lefschetz_closure(lc::LefschetzComplex, subcomp::Vector{String})\n\nCompute the closure of a Lefschetz complex subset.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.permute_lefschetz_complex-Tuple{LefschetzComplex, Vector{Int64}}","page":"Utility Functions","title":"ConleyDynamics.permute_lefschetz_complex","text":"lc2 = permute_lefschetz_complex(lc::LefschetzComplex,\n                                permutation::Vector{Int})\n\nPermute the indices of a Lefschetz complex.\n\nThe vector permutation contains a permutation of the indices for the given Lefschetz complex lc. If no permutation is specified, or if the length of the vector is not correct, then a randomly generated one will be used.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.convert_lefschetz_sparse-Tuple{LefschetzComplex}","page":"Utility Functions","title":"ConleyDynamics.convert_lefschetz_sparse","text":"lc2 = convert_lefschetz_sparse(lc::LefschetzComplex)\n\nConvert the boundary matrix of a Lefschetz complex to sparse.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#Multivector-Fields","page":"Utility Functions","title":"Multivector Fields","text":"","category":"section"},{"location":"apicore/utils/","page":"Utility Functions","title":"Utility Functions","text":"convert_mvf(::Vector{Vector{Int}},::LefschetzComplex)\nconvert_mvf(::Vector{Vector{String}},::LefschetzComplex)","category":"page"},{"location":"apicore/utils/#ConleyDynamics.convert_mvf-Tuple{Vector{Vector{Int64}}, LefschetzComplex}","page":"Utility Functions","title":"ConleyDynamics.convert_mvf","text":"newmvf = convert_mvf(mvf::Vector{Vector{Int}}, lc::LefschetzComplex)\n\nConvert multivector field mvf on the Lefschetz complex lc from  index form to label form.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.convert_mvf-Tuple{Vector{Vector{String}}, LefschetzComplex}","page":"Utility Functions","title":"ConleyDynamics.convert_mvf","text":"newmvf = convert_mvf(mvf::Vector{Vector{String}}, lc::LefschetzComplex)\n\nConvert multivector field mvf on the Lefschetz complex lc from  label form to index form.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#Matrix-Conversions","page":"Utility Functions","title":"Matrix Conversions","text":"","category":"section"},{"location":"apicore/utils/","page":"Utility Functions","title":"Utility Functions","text":"convert_matrix_gfp(::Matrix{Int},::Int)\nconvert_matrix_gfp(::SparseMatrix{Int},::Int)\nconvert_matrix_int(::Matrix)","category":"page"},{"location":"apicore/utils/#ConleyDynamics.convert_matrix_gfp-Tuple{Matrix{Int64}, Int64}","page":"Utility Functions","title":"ConleyDynamics.convert_matrix_gfp","text":"gfpmatrix = convert_matrix_gfp(matrix::Matrix{Int}, p::Int)\n\nConvert an integer matrix to a finite field matrix over GF(p). For the choice p=0 the rationals are used.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.convert_matrix_gfp-Tuple{SparseMatrix{Int64}, Int64}","page":"Utility Functions","title":"ConleyDynamics.convert_matrix_gfp","text":"gfpmatrix = convert_matrix_gfp(matrix::SparseMatrix{Int}, p::Int)\n\nConvert a sparse integer matrix to a finite field sparse matrix over GF(p). For the choice p=0 the rationals are used.\n\n\n\n\n\n","category":"method"},{"location":"apicore/utils/#ConleyDynamics.convert_matrix_int-Tuple{Matrix}","page":"Utility Functions","title":"ConleyDynamics.convert_matrix_int","text":"intmatrix = convert_matrix_int(matrix::Matrix)\n\nConvert a matrix over the finite field GF(p) to an integer matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/sparse/#Sparse-Matrices","page":"Sparse Matrices","title":"Sparse Matrices","text":"","category":"section"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"While Julia provides a data structure for sparse matrix computations, the employed design decisions make it difficult to use this implementation for computations over finite fields. This is mainly due to the fact that in the Julia implementation, it is assumed that one can determine the zero and one elements from the data type alone. However, a finite field data type and especially the ones implemented in the package Nemo, generally also depends on additional parameters, such as the characteristic of the field.","category":"page"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"Since the algorithms underlying ConleyDynamics only require basic row and column operations, we decided to include a specialized sparse matrix implementation.","category":"page"},{"location":"man/sparse/#Sparse-Matrix-Format","page":"Sparse Matrices","title":"Sparse Matrix Format","text":"","category":"section"},{"location":"apicore/sparse/#Sparse-Matrix-Functions","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"","category":"section"},{"location":"apicore/sparse/#Access-Functions","page":"Sparse Matrix Functions","title":"Access Functions","text":"","category":"section"},{"location":"apicore/sparse/","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"sparse_get_entry(matrix::SparseMatrix, ri::Int, ci::Int)\nsparse_set_entry!(matrix::SparseMatrix, ri::Int, ci::Int, val)\nsparse_get_column(matrix::SparseMatrix, ci::Int)\nsparse_get_nz_column(matrix::SparseMatrix, ci::Int)\nsparse_minor(sm::SparseMatrix, rvec::Vector{Int}, cvec::Vector{Int})","category":"page"},{"location":"apicore/sparse/#ConleyDynamics.sparse_get_entry-Tuple{SparseMatrix, Int64, Int64}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_get_entry","text":"value = sparse_get_entry(matrix::SparseMatrix, ri::Int, ci::Int)\n\nGet the sparse matrix entry at location (ri,ci).\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_set_entry!-Tuple{SparseMatrix, Int64, Int64, Any}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_set_entry!","text":"sparse_set_entry!(matrix::SparseMatrix, ri::Int, ci::Int, val)\n\nSet the sparse matrix entry at location (ri,ci) to val.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_get_column-Tuple{SparseMatrix, Int64}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_get_column","text":"value = sparse_get_column(matrix::SparseMatrix, ci::Int)\n\nGet the ci-th column of the sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_get_nz_column-Tuple{SparseMatrix, Int64}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_get_nz_column","text":"value = sparse_get_nz_column(matrix::SparseMatrix, ci::Int)\n\nGet the row indizes for the nonzero entries in the ci-th column of the sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_minor-Tuple{SparseMatrix, Vector{Int64}, Vector{Int64}}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_minor","text":"smp = sparse_minor(sm::SparseMatrix, rvec::Vector{Int}, cvec::Vector{Int})\n\nCreate sparse submatrix by specifying the desired row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#Basic-Functions","page":"Sparse Matrix Functions","title":"Basic Functions","text":"","category":"section"},{"location":"apicore/sparse/","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"sparse_size(matrix::SparseMatrix, dim::Int)\nsparse_low(matrix::SparseMatrix, col::Int)\nsparse_is_sut(sm::SparseMatrix)\nsparse_identity(n::Int, tone)\nsparse_fullness(sm::SparseMatrix)\nsparse_sparsity(sm::SparseMatrix)\nsparse_show(sm::SparseMatrix)","category":"page"},{"location":"apicore/sparse/#ConleyDynamics.sparse_size-Tuple{SparseMatrix, Int64}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_size","text":"n = sparse_size(matrix::SparseMatrix, dim::Int)\n\nNumber of rows (dim=1) or columns (dim=2) of a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_low-Tuple{SparseMatrix, Int64}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_low","text":"n = sparse_low(matrix::SparseMatrix, col::Int)\n\nRow index of the lowest nonzero matrix entry in column col.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_is_sut-Tuple{SparseMatrix}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_is_sut","text":"bool = sparse_is_sut(sm::SparseMatrix)\n\nCheck whether the sparse matrix is strictly upper triangular.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_identity-Tuple{Int64, Any}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_identity","text":"sm = sparse_identity(n::Int, tone)\n\nCreate a sparse identity matrix with n rows and columns, and with diagonal entry tone.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_fullness-Tuple{SparseMatrix}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_fullness","text":"sparse_fullness(sm::SparseMatrix)\n\nDisplay the fullness of the sparse matrix sm.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_sparsity-Tuple{SparseMatrix}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_sparsity","text":"sparse_sparsity(sm::SparseMatrix)\n\nDisplay the sparsity of the sparse matrix sm.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_show-Tuple{SparseMatrix}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_show","text":"sparse_show(sm::SparseMatrix)\n\nDisplay the sparse matrix sm.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#Elementary-Matrix-Operations","page":"Sparse Matrix Functions","title":"Elementary Matrix Operations","text":"","category":"section"},{"location":"apicore/sparse/","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"sparse_add_column!(matrix::SparseMatrix, ci1::Int, ci2::Int, c)\nsparse_add_row!(matrix::SparseMatrix, ri1::Int, ri2::Int, c)\nsparse_permute(sm::SparseMatrix, pr::Vector{Int}, pc::Vector{Int})\nsparse_remove!(matrix::SparseMatrix, ri::Int, ci::Int)","category":"page"},{"location":"apicore/sparse/#ConleyDynamics.sparse_add_column!-Tuple{SparseMatrix, Int64, Int64, Any}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_add_column!","text":"sparse_add_column!(matrix::SparseMatrix, ci1::Int, ci2::Int, c)\n\nReplace column[ci1] by column[ci1] + c * column[ci2].\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_add_row!-Tuple{SparseMatrix, Int64, Int64, Any}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_add_row!","text":"sparse_add_row!(matrix::SparseMatrix, ri1::Int, ri2::Int, c)\n\nReplace row[ri1] by row[ri1] + c * row[ri2].\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_permute-Tuple{SparseMatrix, Vector{Int64}, Vector{Int64}}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_permute","text":"smp = sparse_permute(sm::SparseMatrix, pr::Vector{Int}, pc::Vector{Int})\n\nCreate sparse matrix by permuting the row and column indices.\n\nThe vector pr describes the row permutation, and pc the column permutation.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_remove!-Tuple{SparseMatrix, Int64, Int64}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_remove!","text":"sparse_remove!(matrix::SparseMatrix, ri::Int, ci::Int)\n\nRemove the sparse matrix entry at location (ri,ci).\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#Conversion-Functions","page":"Sparse Matrix Functions","title":"Conversion Functions","text":"","category":"section"},{"location":"apicore/sparse/","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"sparse_from_full(matrix::Matrix{Int})\nfull_from_sparse(sm::SparseMatrix)\nsparse_from_lists(nr::Int, nc::Int, tzero, tone, r::Vector{Int}, c::Vector{Int}, vals)\nlists_from_sparse(sm::SparseMatrix)","category":"page"},{"location":"apicore/sparse/#ConleyDynamics.sparse_from_full-Tuple{Matrix{Int64}}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_from_full","text":"sm = sparse_from_full(matrix::Matrix{Int})\n\nCreate sparse matrix from full matrix.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.full_from_sparse-Tuple{SparseMatrix}","page":"Sparse Matrix Functions","title":"ConleyDynamics.full_from_sparse","text":"fm = full_from_sparse(sm::SparseMatrix)\n\nCreate full matrix from sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_from_lists-Tuple{Int64, Int64, Any, Any, Vector{Int64}, Vector{Int64}, Any}","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_from_lists","text":"sm = sparse_from_lists(nr, nc, tzero, tone, r, c, vals)\n\nCreate sparse matrix from lists describing the entries.\n\nThe vectors r, c, and vals have to have the same length and the matric has entry vals[k] at (r[k],c[k]). Zero entries will be ignored, and multiple entries for the same matrix position raise an error.\n\nThe input arguments have the following meaning:\n\nnr::Int: Number of rows\nnc::Int: Number of columns\ntzero::T: Number 0 of type T\ntone::T:  Number 1 of type T\nr::Vector{Int}: Vector of row indices\nc::Vector{Int}: Vector of column indices\nvals::Vector{T}: Vector of matrix entries\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.lists_from_sparse-Tuple{SparseMatrix}","page":"Sparse Matrix Functions","title":"ConleyDynamics.lists_from_sparse","text":"nr, nc, tzero, tone, r, c, vals = lists_from_sparse(sm::SparseMatrix)\n\nCreate list representation from sparse matrix.\n\nThe output variables are exactly what is needed to create a sparse matrix object using sparse_from_lists.\n\n\n\n\n\n","category":"method"},{"location":"#ConleyDynamics.jl","page":"Overview","title":"ConleyDynamics.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Conley index and multivector fields for Julia.","category":"page"},{"location":"#Introduction","page":"Overview","title":"Introduction","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"ConleyDynamics.jl is a Julia package for studying combinatorial multivector fields using Conley theory. The multivector fields can be studied on arbitrary Lefschetz complexes, which include both simplicial and cubical complexes as important special cases. The concept of combinatorial multivector field generalizes Forman vector fields, which were originally introduced to study Morse theory in a discrete combinatorial setting.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"note: Note\nThis package and the documentation is still very much work in progress!","category":"page"},{"location":"#Features","page":"Overview","title":"Features","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Data structures for Lefschetz complexes, in particular simplicial and cubical complexes.\nClassical Forman combinatorial vector fields and multivector fields are supported.\nComputation of connection matrices and Conley-Morse graphs.\nBasic homology algorithms over finite fields, including persistent homology and relative homology.\nAlgorithms rely on a built-in sparse matrix implementation geared towards computations over finite fields.","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"To use ConleyDynamics please install Julia 1.10 or higher. See https://julialang.org/downloads/ for instructions on how to obtain Julia for your system.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"At the Julia prompt simply type","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> using Pkg; Pkg.add(\"ConleyDynamics\")","category":"page"},{"location":"#Manual-Outline","page":"Overview","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Pages = [\n    \"man/guide.md\",\n    \"man/lefschetz.md\",\n    \"man/connections.md\",\n    \"man/homology.md\",\n    \"man/sparse.md\",\n    \"man/examples.md\",\n]\nDepth = 1","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The Tutorial briefly explains how to get started with ConleyDynamics. More details, including on the underlying mathematics, are provided in the following four sections, which cover Lefschetz complexes, connection matrices, homology, and sparse matrices, respectively.  Finally, a discussion of all included examples can be found in the Examples section.","category":"page"},{"location":"apicore/datastruct/#Composite-Data-Structures","page":"Composite Data Structures","title":"Composite Data Structures","text":"","category":"section"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"The package relies on three basic composite data structures that encompass more complicated objects.","category":"page"},{"location":"apicore/datastruct/#Representation-of-a-LefschetzComplex","page":"Composite Data Structures","title":"Representation of a LefschetzComplex","text":"","category":"section"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"LefschetzComplex","category":"page"},{"location":"apicore/datastruct/#ConleyDynamics.LefschetzComplex","page":"Composite Data Structures","title":"ConleyDynamics.LefschetzComplex","text":"LefschetzComplex\n\nCollect the Lefschetz complex information in a struct.\n\nThe struct has the following fields:\n\nncells::Int: number of cells\ndim::Int: dimension of the complex\nboundary::Matrix{Int}: boundary matrix, columns give the cell boundaries\nlabels::Vector{String}: vector of labels associated with cell indices\nindices::Dict{String,Int}: dictionary for finding cell index from label\ndimensions::Vector{Int}: vector cell dimensions\n\n\n\n\n\n","category":"type"},{"location":"apicore/datastruct/#Representation-of-a-Conley-Morse-Graph","page":"Composite Data Structures","title":"Representation of a Conley-Morse Graph","text":"","category":"section"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"ConleyMorseCM","category":"page"},{"location":"apicore/datastruct/#ConleyDynamics.ConleyMorseCM","page":"Composite Data Structures","title":"ConleyDynamics.ConleyMorseCM","text":"ConleyMorseCM{Tmatrix}\n\nCollect the connection matrix information in a struct.\n\nThe struct has the following fields:\n\ncm::Tmatrix: connection matrix\ncolumns::Vector{Int}: corresponding columns in the boundary matrix\nposet::Vector{Int}: poset indices for the connection matrix columns\nlabels::Vector{String}: labels for the connection matrix columns\nmorsesets::Vector{Vector{String}}: vector of Morse sets in original complex\npoincare::Vector{Vector{Int}}: vector of Poincare polynomial coefficients for the Morse sets. The k-th entry is the coefficient of t^(k-1).\n\n\n\n\n\n","category":"type"},{"location":"apicore/datastruct/#Internal-Sparse-Matrix-Representation","page":"Composite Data Structures","title":"Internal Sparse Matrix Representation","text":"","category":"section"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"SparseMatrix","category":"page"},{"location":"apicore/datastruct/#ConleyDynamics.SparseMatrix","page":"Composite Data Structures","title":"ConleyDynamics.SparseMatrix","text":"SparseMatrix{T}\n\nComposite data type for a sparse matrix with entries of type T.\n\nThe struct has the following fields:\n\nconst nrow::Int: Number of rows\nconst ncol::Int: Number of columns\nconst zero::T: Number 0 of type T\nconst one::T:  Number 1 of type T\nentries::Vector{Vector{T}}: Matrix entries corresponding to columns\ncolumns::Vector{Vector{Int}}: column[k] points to nonzero entries in column k\nrows::Vector{Vector{Int}}: rows[k] points to nonzero entries in the k-th row\n\n\n\n\n\n","category":"type"},{"location":"apicore/cmcore/#Connection-Matrix-Functions","page":"Connection Matrix Functions","title":"Connection Matrix Functions","text":"","category":"section"},{"location":"apicore/cmcore/#Connection-Matrix-Computation","page":"Connection Matrix Functions","title":"Connection Matrix Computation","text":"","category":"section"},{"location":"apicore/cmcore/","page":"Connection Matrix Functions","title":"Connection Matrix Functions","text":"connection_matrix(::LefschetzComplex,::Vector{Vector{Int}};::Int,::Bool)\nconnection_matrix(::LefschetzComplex,::Vector{Vector{String}};::Int,::Bool)\ncm_create!(::Matrix,::Vector{Int};::Bool)\ncm_create!(::SparseMatrix,::Vector{Int};::Bool)","category":"page"},{"location":"apicore/cmcore/#ConleyDynamics.connection_matrix-Tuple{LefschetzComplex, Vector{Vector{Int64}}}","page":"Connection Matrix Functions","title":"ConleyDynamics.connection_matrix","text":"cm = connection_matrix(lc, mvf; p=2)\ncm, cmbasis = connection_matrix(lc, mvf; p=2, returnbasis=true)\n\nCompute a connection matrix for the multivector field mvf on the Lefschetz complex lc over a finite field with p elements.\n\nThe arguments are typed as lc::LefschetzComplex and mvf::Vector{Vector{Int}}, and the return object is of type ConleyMorseCM. If the optional argument returnbasis::Bool=true is given, then the function returns a dictionary  which gives the basis for the connection matrix columns in terms of the original labels. If p is omitted, then p=2 is used.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.connection_matrix-Tuple{LefschetzComplex, Vector{Vector{String}}}","page":"Connection Matrix Functions","title":"ConleyDynamics.connection_matrix","text":"cm = connection_matrix(lc, mvf; p=2)\ncm, cmbasis = connection_matrix(lc, mvf; p=2, returnbasis=true)\n\nCompute a connection matrix for the multivector field mvf on the Lefschetz complex lc over a finite field with p elements.\n\nThe arguments are typed as lc::LefschetzComplex and mvf::Vector{Vector{String}}, and the return object is of type ConleyMorseCM. If the optional argument returnbasis::Bool=true is given, then the function returns a dictionary  which gives the basis for the connection matrix columns in terms of the original labels. If p is omitted, then p=2 is used.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.cm_create!-Tuple{Matrix, Vector{Int64}}","page":"Connection Matrix Functions","title":"ConleyDynamics.cm_create!","text":"cmatrix, cmatrix_cols = cm_create!(matrix, psetvec)\ncmatrix, cmatrix_cols, basisvecs = cm_create!(matrix, psetvec;\n                                              returnbasis=true)\n\nCompute the connection matrix.\n\nAssumes that matrix is upper triangular and filtered according to psetvec. Modifies the argument matrix. If the optional argument returnbasis=true is given, then the function also returns information about the computed basis. The k-th entry of basisvecs is a vector containing the columns making up the k-th basis vector, which corresponds to column cmatrix_cols[k].\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.cm_create!-Tuple{SparseMatrix, Vector{Int64}}","page":"Connection Matrix Functions","title":"ConleyDynamics.cm_create!","text":"cmatrix, cmatrix_cols = cm_create!(matrix, psetvec)\ncmatrix, cmatrix_cols, basisvecs = cm_create!(matrix, psetvec;\n                                              returnbasis=true)\n\nCompute the connection matrix.\n\nAssumes that matrix is upper triangular and filtered according to psetvec. Modifies the argument matrix. If the optional argument returnbasis=true is given, then the function also returns information about the computed basis. The k-th entry of basisvecs is a vector containing the columns making up the k-th basis vector, which corresponds to column cmatrix_cols[k].\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#Poset-Order-Functions","page":"Connection Matrix Functions","title":"Poset Order Functions","text":"","category":"section"},{"location":"apicore/cmcore/","page":"Connection Matrix Functions","title":"Connection Matrix Functions","text":"admissible_order(bndmatrix::Matrix{Int}, mvf::Vector{Vector{Int}})\nadmissible_order(bndmatrix::SparseMatrix{Int}, mvf::Vector{Vector{Int}})\nrenumber_poset!(poset::Vector{Int})","category":"page"},{"location":"apicore/cmcore/#ConleyDynamics.admissible_order-Tuple{Matrix{Int64}, Vector{Vector{Int64}}}","page":"Connection Matrix Functions","title":"ConleyDynamics.admissible_order","text":"admiorder, admibnd, sccnumber, scc = admissible_order(bndmatrix, mvf)\n\nFind an admissible order based on the boundary matrix and the multivector field.\n\nThe vector sccnumber contains the strongly connected component for each column, and the matrix admibnd is the reordered boundary matrix corresponding to the order given by admiorder.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.admissible_order-Tuple{SparseMatrix{Int64}, Vector{Vector{Int64}}}","page":"Connection Matrix Functions","title":"ConleyDynamics.admissible_order","text":"admiorder, admibnd, sccnumber, scc = admissible_order(bndmatrix, mvf)\n\nFind an admissible order based on the boundary matrix and the multivector field.\n\nThe vector sccnumber contains the strongly connected component for each column, and the matrix admibnd is the reordered boundary matrix corresponding to the order given by admiorder.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.renumber_poset!-Tuple{Vector{Int64}}","page":"Connection Matrix Functions","title":"ConleyDynamics.renumber_poset!","text":"renumber_poset!(poset)\n\nRenumber the poset given by the increasing integer vector poset.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#Sparse-Matrix-Helper-Functions","page":"Connection Matrix Functions","title":"Sparse Matrix Helper Functions","text":"","category":"section"},{"location":"apicore/cmcore/","page":"Connection Matrix Functions","title":"Connection Matrix Functions","text":"cm_columns(matrix::SparseMatrix, psetvec::Vector{Int})\nhomogeneous_columns(::SparseMatrix,::Vector{Int})\nis_homogeneous(::SparseMatrix,::Vector{Int},::Int)\ntarget_columns(matrix::SparseMatrix, psetvec::Vector{Int})","category":"page"},{"location":"apicore/cmcore/#ConleyDynamics.cm_columns-Tuple{SparseMatrix, Vector{Int64}}","page":"Connection Matrix Functions","title":"ConleyDynamics.cm_columns","text":"ccols = cm_columns(matrix::SparseMatrix, psetvec)\n\nCreate a vector of column indices for the connection matrix.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.homogeneous_columns-Tuple{SparseMatrix, Vector{Int64}}","page":"Connection Matrix Functions","title":"ConleyDynamics.homogeneous_columns","text":"hcols = homogeneous_columns(matrix::SparseMatrix, psetvec)\n\nDetermine which columns of matrix are homogenenous columns.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.is_homogeneous-Tuple{SparseMatrix, Vector{Int64}, Int64}","page":"Connection Matrix Functions","title":"ConleyDynamics.is_homogeneous","text":"bool = is_homogeneous(matrix::SparseMatrix, psetvec, cindex)\n\nDecide whether a column of matrix is homogeneous.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.target_columns-Tuple{SparseMatrix, Vector{Int64}}","page":"Connection Matrix Functions","title":"ConleyDynamics.target_columns","text":"tcols = target_columns(matrix::SparseMatrix, psetvec)\n\nDetermine which columns of matrix are target columns.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#Full-Matrix-Helper-Functions","page":"Connection Matrix Functions","title":"Full Matrix Helper Functions","text":"","category":"section"},{"location":"apicore/cmcore/","page":"Connection Matrix Functions","title":"Connection Matrix Functions","text":"cm_columns(matrix::Matrix, lowvec::Vector{Int}, psetvec::Vector{Int})\nhomogeneous_columns(::Matrix,::Vector{Int},::Vector{Int})\nis_homogeneous(::Matrix,::Vector{Int},::Vector{Int},::Int)\ntarget_columns(::Matrix,::Vector{Int},::Vector{Int})\nupdate_low!(matrix::Matrix, lowvec::Vector{Int}; startindex::Int=1)","category":"page"},{"location":"apicore/cmcore/#ConleyDynamics.cm_columns-Tuple{Matrix, Vector{Int64}, Vector{Int64}}","page":"Connection Matrix Functions","title":"ConleyDynamics.cm_columns","text":"ccols = cm_columns(matrix, lowvec, psetvec)\n\nCreate a vector of column indices for the connection matrix.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.homogeneous_columns-Tuple{Matrix, Vector{Int64}, Vector{Int64}}","page":"Connection Matrix Functions","title":"ConleyDynamics.homogeneous_columns","text":"hcols = homogeneous_columns(matrix, lowvec, psetvec)\n\nDetermine which columns of matrix are homogenenous columns.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.is_homogeneous-Tuple{Matrix, Vector{Int64}, Vector{Int64}, Int64}","page":"Connection Matrix Functions","title":"ConleyDynamics.is_homogeneous","text":"bool = is_homogeneous(matrix, lowvec, psetvec, cindex)\n\nDecide whether a column of matrix is homogeneous.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.target_columns-Tuple{Matrix, Vector{Int64}, Vector{Int64}}","page":"Connection Matrix Functions","title":"ConleyDynamics.target_columns","text":"tcols = target_columns(matrix, lowvec, psetvec)\n\nDetermine which columns of matrix are target columns.\n\n\n\n\n\n","category":"method"},{"location":"apicore/cmcore/#ConleyDynamics.update_low!-Tuple{Matrix, Vector{Int64}}","page":"Connection Matrix Functions","title":"ConleyDynamics.update_low!","text":"update_low!(matrix, lowvec; startindex=1)\n\nCompute the indices of the lowest nonzero entries in each column of matrix.\n\nThe indices are stored in lowvec. If startindex > 1, then only the values starting with column startindex are updated.\n\n\n\n\n\n","category":"method"}]
}
