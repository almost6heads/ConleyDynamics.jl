var documenterSearchIndex = {"docs":
[{"location":"apicore/apiindex/#Complete-API-Index","page":"Complete API Index","title":"Complete API Index","text":"","category":"section"},{"location":"apicore/apiindex/#indexdata","page":"Complete API Index","title":"Composite Data Structures","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"datastruct.md\"]","category":"page"},{"location":"apicore/apiindex/#indexlefschetz","page":"Complete API Index","title":"Lefschetz Complex Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"lefschetz.md\"]","category":"page"},{"location":"apicore/apiindex/#indexhomology","page":"Complete API Index","title":"Homology Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"homology.md\"]","category":"page"},{"location":"apicore/apiindex/#indexconley","page":"Complete API Index","title":"Conley Theory Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"conley.md\"]","category":"page"},{"location":"apicore/apiindex/#indexplot","page":"Complete API Index","title":"Plotting Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"plots.md\"]","category":"page"},{"location":"apicore/apiindex/#indexsparse","page":"Complete API Index","title":"Sparse Matrix Functions","text":"","category":"section"},{"location":"apicore/apiindex/","page":"Complete API Index","title":"Complete API Index","text":"Pages = [\"sparse.md\"]","category":"page"},{"location":"apicore/homology/#Homology-Functions","page":"Homology Functions","title":"Homology Functions","text":"","category":"section"},{"location":"apicore/homology/#Regular-Homology","page":"Homology Functions","title":"Regular Homology","text":"","category":"section"},{"location":"apicore/homology/","page":"Homology Functions","title":"Homology Functions","text":"homology\nrelative_homology","category":"page"},{"location":"apicore/homology/#ConleyDynamics.homology","page":"Homology Functions","title":"ConleyDynamics.homology","text":"homology(lc::LefschetzComplex)\n\nCompute the homology of a Lefschetz complex.\n\nThe homology is returned as a vector betti of Betti numbers, where betti[k] is the Betti number in dimension k-1. The computations are performed over the field associated with the Lefschetz complex boundary matrix.\n\n\n\n\n\n","category":"function"},{"location":"apicore/homology/#ConleyDynamics.relative_homology","page":"Homology Functions","title":"ConleyDynamics.relative_homology","text":"relative_homology(lc::LefschetzComplex,subc::Cells)\n\nCompute the relative homology of a Lefschetz complex with respect to a subcomplex. The computation is performed over the field associated with the Lefschetz boundary matrix.\n\nThe subcomplex is the closure of the cells in subc, which can be given either as indices or labels. The homology is returned as a vector betti of Betti numbers, where betti[k] is the Betti number in dimension k-1.\n\n\n\n\n\nrelative_homology(lc::LefschetzComplex,subc::Cells,subc0::Cells)\n\nCompute the relative homology of a Lefschetz complex with respect to a subcomplex. The computation is performed over the field associated with the Lefschetz boundary matrix.\n\nIn this implementation, relative homology of the pair cl(subc), cl(subc0)) is computed. An error is raised if cl(subc0) is not a subset of cl(subc). The homology is returned as a vector betti of Betti numbers, where betti[k] is the Betti number in dimension k-1.\n\n\n\n\n\n","category":"function"},{"location":"apicore/homology/#Persistent-Homology","page":"Homology Functions","title":"Persistent Homology","text":"","category":"section"},{"location":"apicore/homology/","page":"Homology Functions","title":"Homology Functions","text":"persistent_homology","category":"page"},{"location":"apicore/homology/#ConleyDynamics.persistent_homology","page":"Homology Functions","title":"ConleyDynamics.persistent_homology","text":"persistent_homology(lc::LefschetzComplex, filtration::Vector{Int})\n\nComplete the persistent homology of a Lefschetz complex filtration over the field associated with the Lefschetz complex boundary matrix.\n\nThe function returns the two values\n\nphsingles::Vector{Vector{Int}}\nphpairs::Vector{Vector{Tuple{Int,Int}}}\n\nIt assumes that the order given by the filtration values is admissible, i.e., the permuted boundary matrix is strictly upper triangular. The function returns the starting filtration values for infinite length persistence intervals in phsingles, and the birth- and death-filtration values for finite length persistence intervals in phpairs.\n\n\n\n\n\n","category":"function"},{"location":"apicore/homology/#Reduction-Algorithm","page":"Homology Functions","title":"Reduction Algorithm","text":"","category":"section"},{"location":"apicore/homology/","page":"Homology Functions","title":"Homology Functions","text":"ph_reduce!","category":"page"},{"location":"apicore/homology/#ConleyDynamics.ph_reduce!","page":"Homology Functions","title":"ConleyDynamics.ph_reduce!","text":"ph_reduce!(matrix::SparseMatrix; [returnbasis=true])\n\nApply the persistence reduction algorithm to the matrix.\n\nThe function returns the values\n\nphsingles::Vector{Vector{Int}}\nphpairs::Vector{Vector{Tuple{Int,Int}}}\nbasis::SparseMatrix (if returnbasis=true)\n\nIt assumes that matrix is strictly upper triangular. The function returns the starting columns for infinite length persistence intervals in phsingles, and the birth- and death-columns for finite length persistence intervals in phpairs. If the optional argument returnbasis=true is given, then the function also returns the computed basis matrix B with reduced = matrix * B.\n\n\n\n\n\n","category":"function"},{"location":"man/lefschetz/#Lefschetz-Complexes","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The fundamental structure underlying the functionality of ConleyDynamics.jl is a Lefschetz complex. It provides us with the basic model of phase space for combinatorial topological dynamics. In view of the combinatorial, and therefore discrete, character of the dynamical behavior, a Lefschetz complex is not a typical phase space in the sense of classical dynamics. While the latter one is usually a Euclidean space, a Lefschetz complex is basically a combinatorial model of it. In the following, we provide its precise mathematical definition, and explain how it can be created and modified within the package. We also discuss two important special cases, namely simplicial complexes and cubical complexes.","category":"page"},{"location":"man/lefschetz/#Basic-Lefschetz-Terminology","page":"Lefschetz Complexes","title":"Basic Lefschetz Terminology","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The original definition of a Lefschetz complex can be found in [Lef42], where it was simply referred to as a complex.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"tip: Definition: Lefschetz complex\nLet F denote an arbitrary field. Then a pair (Xkappa) is called a Lefschetz complex over F if X = (X_k)_k in mathbbN_0 is a finite set with mathbbN_0-gradation, and kappa  X times X to F is a mapping such that   kappa(xy) neq 0\n   quadmathrm implies quad\n   x in X_k\n   quadmathrm and quad y in X_k-1and such that for any xz in X one has   sum_y in X kappa(xy) kappa(yz) = 0  The elements of X are referred to as cells, the value kappa(xy) in F is called the incidence coefficient of the cells x and y, and the map kappa is the incidence coefficient map. In addition, one defines the dimension of a cell xin X_k as the integer k, and denotes it by k = dim x. Whenever the incidence coefficient map is clear from context, we often just refer to X as the Lefschetz complex.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"At first glance the above definition can seem daunting. However, it is based on a straightforward geometric idea. A Lefschetz  complex is a structure that is built from elementary building blocks called cells. Each cell has a dimension associated with it, and it is topologically an open ball of this dimension. Thus, cells of dimension zero are points, also called vertices. Cells of dimension one are open curve segments, which we call edges, and two-dimensional cells are called faces and take the form of open two-dimensional membranes.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The incidence coefficient map encodes how these cells are glued together to form the Lefschetz complex X. In order to shed more light on this, consider the boundary map partial which is defined on cells via","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   partial x = sum_y in X kappa(xy) y  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"This map sends a cell x of dimension k to a specific  linear combination of cells of dimension k-1, called the boundary of x. By using ideas from linear algebra, the boundary map can be extended to map a general linear combination of k-dimensional cells to the corresponding linear combination of the separate boundaries. For example, if one chooses the field F = mathbbQ of rationals, one has partial  (x_1 - 2x_2) = partial x_1 - 2 partial x_2. Notice that using this extended definition of the boundary map, one can rewrite the summation condition in the definition of a Lefschetz complex in the equivalent form","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   partial( partial x) = 0\n   quadtext for all cells quad\n   x in X  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"In other words, the boundary of any cell is itself boundaryless.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"With the help of the boundary map, one can often infer the overall geometric structure of a Lefschetz complex X. For this, think of a Lefschetz complex as being build from the ground up in the following way. First, start by putting down all vertices of X at different locations in some ambient space. Since the boundary of each one-dimensional cell is made up of a linear combination of vertices, one can then add a curve segment for each one-dimensional cell, which connects the vertices in its boundary. Note that in the general version of a Lefschetz complex it is possible that an edge has only one vertex in its boundary, or maybe even none, and in these cases the edge is either only connected to the one boundary vertex, or it is an open curve segment connected to no vertex at all, respectively. Continue in this fashion to add two-dimensional faces to fill in the space between the edges in its boundary, and so on for higher dimensions. Needless to say, in the case of a general complicated Lefschetz complex this procedure is of limited use, since the boundary of a cell can be an arbitrary linear combination of cells, with coefficients that can be any nonzero numbers in the field F. Yet, in many simple cases the above intuition is sufficient.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"In addition to the Lefschetz complex definition, there are a handful of other concepts which will be important for our discussion of Lefschetz complexes. Specifically, the following notions are important:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"A facet of a cell x in X is any cell y which satisfies kappa(xy) neq 0.\nOne can define a partial order on the cells of X by letting x le y if and only if for some integer n in mathbbN there exist cells x = x_1 ldots x_n = y such that x_k is a facet of x_k+1 for all k = 1 ldots n-1. It is not difficult to show that this defines a partial order on X, i.e., this relation is reflexive, antisymmetric, and transitive. We call this partial order the face relation.  Moreover, if x le y then x is called a face of y.\nA subset C subset X of a Lefschetz complex is called closed, if for every x in C all the faces of the cell x are also contained in the subset C.\nThe closure of a subset C subset X is the collection of all faces of all cells in C, and it is denoted by mathrmcl C. Thus, a subset of a Lefschetz complex is closed if and only if it equals its closure.\nA subset S subset X is called locally closed, if its mouth mathrmmo S = mathrmcl S setminus S is closed. Note that every closed set is automatically locally closed, but the reverse implication is usually false.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"While the first two points merely introduce notation for describing the combinatorial boundary of cells, the remaining three points establish important topological concepts. In fact, the above definition of closedness defines a topology on the Lefschetz complex X, which is the so-called Alexandrov topology from [Ale37]. As usual in the field of topology, a subset of a Lefschetz complex will be called open, if and only if its complement is closed.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"We would like to point out that while the concept of local closedness is rarely considered in standard topology courses, it is of utmost important for the study of combinatorial topological dynamics. For the moment, we just mention the following result:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"danger: Theorem: Lefschetz subcomplexes\nLet X be a Lefschetz complex over a field F, and let kappa  X times X to F denote its incidence coefficient map. Then a subset S subset X is again a Lefschetz complex, with respect to the restriction of kappa to S times S, if and only if the subset S is locally closed.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"This result goes back to [MB09, Theorem 3.1], where it was shown that local closedness is sufficient. In other words, in the category of Lefschetz complexes local closedness arises naturally. Due to its importance, we also mention the following two equivalent formulations:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"A subset S subset X is locally closed, if and only if it is the difference of two closed subsets of X.\nA subset S subset X is locally closed, if and only if it is an interval with respect to the face relation on X, i.e., whenever we have three cells with S ni x le y le z in S, then one has to have y in S as well.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The proof of these characterizations can be found in [MW23, Proposition 3.2] and [LKMW23, Proposition 3.10], respectively.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Lefschetz complexes are a very general mathematical concept, and they can be rather confusing at first sight. Nevertheless, they do encompass other complex types, which are more geometric in nature. As we already saw in the tutorial, every simplicial complex is automatically a Lefschetz complex, and we will further elaborate on this connection below. In addition, we will also demonstrate that cubical complexes are Lefschetz complexes. More general, any regular CW complex is  a Lefschetz complex as well. For more details on this, we refer to the definition in [Mas91] and the discussion in [DKMW11].","category":"page"},{"location":"man/lefschetz/#Lefschetz-Complex-Data-Structure","page":"Lefschetz Complexes","title":"Lefschetz Complex Data Structure","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"For the efficient and easy manipulation of Lefschetz complexes in ConleyDynamics.jl we make use of a specific composite data type:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"LefschetzComplex","category":"page"},{"location":"man/lefschetz/#ConleyDynamics.LefschetzComplex-man-lefschetz","page":"Lefschetz Complexes","title":"ConleyDynamics.LefschetzComplex","text":"LefschetzComplex\n\nCollect the Lefschetz complex information in a struct.\n\nThe struct has the following fields:\n\nncells::Int: Number of cells\ndim::Int: Dimension of the complex\nboundary::SparseMatrix: Boundary matrix, columns give the cell boundaries\nlabels::Vector{String}: Vector of labels associated with cell indices\nindices::Dict{String,Int}: Dictionary for finding cell index from label\ndimensions::Vector{Int}: Vector cell dimensions\n\nThe coefficient field is specified by the boundary matrix.\n\n\n\n\n\n","category":"type"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The fields of this struct relate to the mathematical definition of a Lefschetz complex X in the following way:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The integer ncells gives the total number of cells in X. Internally, these cells are numbered by integers ranging from 1 to ncells.\nThe vector dimensions is a Vector{Int} and collects the  dimensions of the cells. In other words, the cell which is indexed by the integer k has dimension dimensions[k].\nThe integer dim describes the overall dimension of the Lefschetz complex, which is the largest dimension of a cell.\nThe incidence coefficient map kappa is encoded in the sparse matrix boundary. This matrix is a square matrix with ncells  rows and columns. The k-th column contains the incidence coefficients kappa(kcdot) in the sense that the entry in row m and column k equals the value kappa(km). Since for most Lefschetz complexes the majority of the incidence coefficients is zero, the matrix is represented using the sparse format SparseMatrix, which is described in more detail in Sparse Matrices.\nWhile the internal representation of cells as integers is  computationally convenient, it does make interpreting the results more difficult. Each Lefschetz complex therefore has to have string labels assigned to each cell as well. These are contained in labels::Vector{String}, where labels[k] gives the label of cell k.\nIn order to easily determine the integer index for a cell with a specific label, the field indices contains a dictionary of type Dict{String,Int} which maps labels to indices. For  example, if a cell has the label \"124.010\", then the associated integer index is given by indices[\"124.010\"].","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"An object of type LefschetzComplex is created by passing the field items in the order given in LefschetzComplex. Consider for example the Lefschetz complex from Figure 4 in [MW23], see also the left complex in the next image. This complex consists of six cells with labels A,  B, a, b, c, and alpha, and we initialize the vector of labels, the cell index dictionary, and the cell dimensions via the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"ncL = 6\nlabelsL  = Vector{String}([\"A\",\"B\",\"a\",\"b\",\"c\",\"alpha\"])\nindicesL = Dict{String,Int}([(labelsL[k],k) for k in 1:length(labelsL)])\ncdimsL   = [0, 0, 1, 1, 1, 2]","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The boundary matrix can then be defined using","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"bndmatrixL = zeros(Int, ncL, ncL)\nbndmatrixL[[1,2],3] = [1; 1]     # a\nbndmatrixL[[1,2],4] = [1; 1]     # b\nbndmatrixL[[1,2],5] = [1; 1]     # c\nbndmatrixL[[3,4],6] = [1; 1]     # alpha\nbndsparseL = sparse_from_full(bndmatrixL, p=2)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Notice that we first create the matrix as a regular integer  matrix, and then use the function sparse_from_full  to turn it into sparse format over the field GF(2) with characteristic p = 2. This is the most convenient method for small boundary matrices, yet for larger ones it is better to use the function sparse_from_lists. Finally, the Lefschetz complex is created using","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"lcL = LefschetzComplex(ncL, 2, bndsparseL, labelsL, indicesL, cdimsL)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"(Image: Two sample Lefschetz complexes)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Lefschetz complexes do not always have to contain cells of all dimensions. For example, the Lefschetz complex shown on the right side of the figure has no vertices, and it can be created using the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"ncR = 4\nlabelsR  = Vector{String}([\"a\",\"b\",\"c\",\"alpha\"])\nindicesR = Dict{String,Int}([(labelsR[k],k) for k in 1:length(labelsR)])\ncdimsR   = [1, 1, 1, 2]\nbndmatrixR = zeros(Int, ncR, ncR)\nbndmatrixR[[1,2,3],4] = [1; 1; 1]     # alpha\nbndsparseR = sparse_from_full(bndmatrixR, p=2)\nlcR = LefschetzComplex(ncR, 2, bndsparseR, labelsR, indicesR, cdimsR)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"While Lefschetz complexes can always be created in ConleyDynamics.jl in this direct way, it is often more convenient to make use of special types, such as simplicial and cubical complexes, and then restrict the complex to a locally closed set using the function lefschetz_subcomplex.","category":"page"},{"location":"man/lefschetz/#Simplicial-Complexes","page":"Lefschetz Complexes","title":"Simplicial Complexes","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"One of the earliest types of complexes that have been studied in  topology are simplicial complexes. As already mentioned in the tutorial, an abstract simplicial complex X is a finite collection of finite sets, called simplices, which is closed under taking subsets. Each simplex sigma has a dimension dimsigma, which is one less than the number of its elements.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"In order to see why every simplicial complex is automatically a  Lefschetz complex, we need to be able to define the incidence  coefficient map kappa. For this, we make use of some notions from [Mun84]. Let X_0 denote the collection of all vertices of the simplicial complex X. Then we use the notation","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   sigma = left v_0 v_1 ldots v_d right\n   quadtext with quad\n   v_k in X_0","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"to describe a d-dimensional simplex. Note that even though every simplex in X is just the set of its vertices, in the above  representation we pick an order of the vertices, called an orientation of the simplex. This orientation can be chosen arbitrarily, and there are two equivalence classes of orientations. To get from one orientation to the other, one just has to exchange two vertices, and we write","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   left ldots v_i ldots v_j ldots right  = \n   -left ldots v_j ldots v_i ldots right  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"For more complicated reorderings, one has to represent the corrresponding vertex permutation as a sequence of such exchanges. Using these oriented simplices we can define the boundary operator","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   partial sigma  = \n   partial left v_0 ldots v_d right  = \n   sum_i=0^d (-1)^i left v_0 ldots hatv_i\n     ldots v_d right  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"where the notation hatv_i means that in the simplex behind the summation sign on the right-hand side the vertex v_i is omitted. For example, for a two-dimensional simplex one obtains","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   partial left v_0 v_1 v_2 right  = \n   left v_1 v_2 right - \n   left v_0 v_2 right + \n   left v_0 v_1 right  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Thus, if one chooses a total order of all the vertices in the simplicial complex, and orients the individual simplices in such a way that their vertices are arranged using this overall order, then the incidence coefficient map is given by","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   kappa left( left v_0 ldots v_i ldots v_d right \n     left v_0 ldots hatv_i ldots v_d right right)\n    =  (-1)^i  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"If some or all of the simplices are represented by different orientations, one simply has to multiply the value (-1)^i by the sign of a suitable vertex permutation. In either case, one can show that the so-defined map kappa does indeed satisfy the definition of a Lefschetz complex. For more details, see [Mun84, Lemma 5.3].","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"In ConleyDynamics.jl there are three basic commands for defining a simplicial complex:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"create_simplicial_complex is the most general method, and it expects two input arguments. The first is usually called labels, and  it has to have the data type Vector{String}. This vector lists the labels for each vertex. It is important that all of these labels have exactly the same number of characters. The second argument is usually called simplices, and it lists as many simplices as necessary for defining the underlying simplicial complex. This means that in practice one only needs to include the simplices which are not faces of higher-dimensional ones, see also the example below. The variable simplices can either be of type Vector{Vector{String}} or Vector{Vector{Int}}, depending on whether the vertices are identified via their labels or integer indices, respectively. Finally, the optional parameter p can be used to specify the underlying field for the  boundary matrix. If p is a prime, then F = GF(p), while for p = 0 the function uses F = mathbbQ. If the argument p is ommitted, the function defaults to p = 2.\ncreate_simplicial_rectangle expects two integer arguments nx and ny, and then creates a triangulation of the square 0nx times 0ny by subdividing every unit square into four triangles which meet at the center of the square. As before, the optional parameter p specifies the underlying field.\ncreate_simplicial_delaunay creates a planar Delaunay triangulation inside a planar rectangle. The function selects a random sample of points inside the box, while either trying to maintain a minimum distance between the points, or just using a prespecified number of points. More details on these two options can be found in the documentation for the function.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"To illustrate the first of these functions, consider the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"labels = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\"]\nsimplices = [[\"A\",\"B\"],[\"A\",\"F\"],[\"B\",\"F\"],[\"B\",\"C\",\"G\"],[\"D\",\"E\",\"H\"],[\"C\",\"D\"],[\"G\",\"H\"]]\nsc = create_simplicial_complex(labels,simplices)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"These create the simplicial complex sc, in the form of a  Lefschetz complex. Note that the above commands only specify the labels for the vertices. The labels for simplices of dimension at least one are automatically generated by concatenating the labels for their vertices, sorted in lexicographic order. This can be seen in the following Julia output:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"julia> sc.labels[end-4:end]\n5-element Vector{String}:\n \"DH\"\n \"EH\"\n \"GH\"\n \"BCG\"\n \"DEH\"","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The simplicial complex sc can be visualized using the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"coords = [[0,0],[2,0],[4,0],[6,0],[8,0],[1,2],[4,2],[6,2]]\nldir   = [3,3,3,3,3,1,1,1]\nfname  = \"lefschetzex2.pdf\"\nplot_planar_simplicial(sc,coords,fname,labeldir=ldir,labeldis=10,hfac=2,vfac=1.5,sfac=50)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"(Image: First sample simplicial complex)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Similarly, the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"sc2, coords2 = create_simplicial_rectangle(5,2)\nfname2 = \"lefschetzex3.pdf\"\nplot_planar_simplicial(sc2,coords2,fname2,hfac=2.0,vfac=1.2,sfac=75)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"define and illustrate a second simplicial complex, which triangularizes a rectangle in the plane.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"(Image: Second sample simplicial complex)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"For a demonstration of the Delaunay triangulation approach, please see Analyzing Planar Vector Fields.","category":"page"},{"location":"man/lefschetz/#Cubical-Complexes","page":"Lefschetz Complexes","title":"Cubical Complexes","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The second important special case of a Lefschetz complex is called cubical complex, and it has been discussed in detail in [KMM04]. In the following, we only present the definitions that are essential for our purposes.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Loosely speaking, a cubical complex is a collection of cubes of varying dimensions in some Euclidean space mathbbR^d. More precisely, we say that an interval I subset mathbbR is an elementary interval if it is of the form","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   I = ell ell+1\n   quadtext or quad\n   I = ell ell\n   quadtext for some integer quad\n   ell in mathbbZ  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"If the elementary interval I consists of only one point, then it is called degenerate, and it is nondegenerate if it is of length one. Elementary intervals are the building blocks for the cubes in a cubical complex. For a complex in mathbbR^d, an elementary cube Q is of the form","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   Q  = \n   I_1 times I_2 times ldots times I_d  subset \n   mathbbR^d  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"where I_1 ldots I_d are elementary intervals. The dimension dim Q of an elementary cube is given by the number of nondegenerate intervals in its representation. For example, the cube Q = 00  times 11 is a zero-dimensional elementary cube in mathbbR^2 which contains only the point (01), while the elementary cube R = 22 times 34 is one-dimensional, and consists of the  closed vertical line segment between the points (23) and (24).","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"After these preparations, the definition of a cubical complex is now straightforward. A cubical complex X in mathbbR^d is a finite collection of elementary cubes in mathbbR^d which is closed under the inclusion of elementary subcubes. More precisely, if Q in X is an elementary cube in the cubical complex, and if R subset Q is any elementary cube contained in Q, then one also has R in X.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The definition of a cubical complex is reminiscent of that of a simplicial complex. It is therefore not surprising that also in the cubical case one can describe the incidence coefficient map kappa explicitly, and thus recognize a cubical complex as a Lefschetz complex. For this, we need more notation.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Let Q = I_1 times I_2 times ldots times I_d denote an elementary cube, and let the nondegenerate elementary intervals in this decomposition be given by I_i_1 ldots I_i_n, where I_i_j = k_j k_j + 1 and j = 1ldotsn = dim Q. For every index j, we further define the two (n-1)-dimensional elementary cubes","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   beginarrayccccccc\n   Q_j^-  =  I_1 times ldots times I_i_j - 1  times \n           k_j k_j  times  I_i_j + 1 times ldots\n           times I_d   2ex\n   Q_j^+  =  I_1 times ldots times I_i_j - 1  times \n           k_j + 1 k_j + 1  times  I_i_j + 1 times\n           ldots times I_d  \n   endarray","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Geometrically, the two elementary cubes Q_j^- and Q_j^+ are directly opposite sides of the elementary cube Q. Using them, one can define the algebraic boundary of the cube as","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   partial Q  = \n   sum_j=1^n (-1)^j-1 left( Q_j^+ - Q_j^- right) ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"This formula is the cubical analogue of the boundary operator in a simplicial complex, and it allows us to define the incidence coefficient map via","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"   kappaleft( Q  Q_j^+ right)  =  (-1)^j-1\n   quadtext and quad\n   kappaleft( Q  Q_j^- right)  =  (-1)^j  \n   quadtext for all quad\n   j = 1 ldots n  ","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"For all remaining pairs of elementary cubes in X we let kappa = 0. Then it was shown in [KMM04, Proposition 2.37] that the so-defined incidence coefficient map satisfies the summation condition in the definition of a Lefschetz complex, i.e., we have partial(partial Q) = 0 for every Q in X. This in turn implies that every cubical complex is indeed a Lefschetz complex.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Cubical complexes in ConleyDynamics.jl are a little more restricted. Since a cubical complex in the above sense is always finite, one can assume without loss of generality that the left endpoints of all involved elementary intervals are nonnegative. In other words, we always assume that the cubical complex only contains elementary cubes from the set (mathbbR_0^+)^d. This allows for a simple encoding of elementary cubes via labels of a fixed length, and without having to worry about the sign of an integer.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"To describe this, fix a dimension d of the ambient space. Then every elementary cube in (mathbbR_0^+)^d has the following label, which depends on a coordinate width L:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The first d cdot L characters of the label encode the  starting points of the elementary intervals I_1 ldots I_d in the standard representation of the elementary cube. For this, the starting points, which are nonnegative integers, are concatenated without spaces, but with leading zeros. For example, with L = 2 the string \"010203\" would correspond to the starting points 1, 2, and 3. Note that for given coordinate width L, one can only encode starting points between 0 and 10^L-1.\nThe next entry in the label string is a period ..\nThe remaining d characters of the string are integers 0 or 1, which give the interval lengths of I_1 ldots I_d.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"For example, for L = 2 the string \"030600.000\" corresponds to the point (360) in three dimensions. Similarly, the label \"030600.101\" represents the two-dimensional elementary cube 34 times 66 times 01 subset mathbbR^3. Note, however, that the label representation is not unique, since it depends on the coordinate width L. Thus, with L = 1 the latter cube could also be written as \"360.101\", or with L = 3 as \"003006000.101\". As we will see in a moment, though, within a given cubical complex all labels have to use the same coordinate width L! This implies in particular that for a given coordinate width L one can only represent bounded cubical complexes which are contained in the d-dimensional box 010^L-1^d.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The following three helper functions simplify the work with these types of cube labels:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"cube_field_size determines the field sizes of a given cube label. The first return value gives the dimension d of the ambient space, while the second value returns the coordinate width L.\ncube_information returns all information encoded in the cube label. The function returns an integer vector of length 2d+1, where d is the dimension of the ambient space. The first d entries give the vector of elementary interval starting points, while the next d values yield the corresponding interval lengths. The last entry specifies the dimension of the cube.\ncube_label creates a label from a cube's coordinate information. As function parameters, one has to specify d and L, and then pass an integer vector of length six which specifies the coordinates of the starting points and the interval lengths as in the previous item.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"In ConleyDynamics.jl there are four basic commands for defining a cubical complex and working with it:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"create_cubical_complex creates a cubical complex in the Lefschetz complex data format. The complex is specified via a list of all the highest-dimensional cubes which are necessary to define the cubical complex. For this, every cube has to be given using the above-described special label format, with the same coordinate width L. In other words, all label strings have to be of the same length! If the optional parameter p is specified, the complex will be defined over a field with characteristic p, analogous to the case of a simplicial complex. If the characteristic is not specified, then the function defaults to the field GF(2).\nget_cubical_coords determines the coordinates of all  vertices of a given cubical complex from the cube labels. This vector can then be used for plotting purposes, see below.\ncreate_cubical_rectangle creates a cubical complex covering a rectangle in the plane. The rectangle is given by the subset 0nx times 0ny of the plane, where the nonnegative integers nx and ny have to be passed as arguments to the function. The function returns the cubical complex, and a vector of coordinates for the vertices. The latter can also be randomly perturbed as described in more detail in the function documentation.\ncreate_cubical_box creates a cubical complex covering a box in three-dimensional Euclidean space. The box is given by the subset 0nx times 0ny times 0nz of space, where the nonnegative integers nx, ny, and nz have to be passed as arguments to the function. The optional parameters are the same as in the planar version.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"To illustrate the first of these functions, consider the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"cubes = [\"00.11\", \"01.01\", \"02.10\", \"11.10\", \"11.01\", \"22.00\", \"20.11\", \"31.01\"]\ncc = create_cubical_complex(cubes)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"These create the cubical complex cc, in the form of a  Lefschetz complex. It can be visualized using the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"coords = get_cubical_coords(cc)\nfname  = \"lefschetzex4.pdf\"\nplot_planar_cubical(cc,coords,fname,hfac=2.2,vfac=1.1,cubefac=60)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"(Image: First sample cubical complex)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Similarly, the commands","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"cc2, coords2 = create_cubical_rectangle(5,2)\nfname2 = \"lefschetzex5.pdf\"\nplot_planar_cubical(cc2,coords2,fname2,hfac=1.7,vfac=1.2,cubefac=75)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"define and illustrate a second cubical complex.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"(Image: Second sample cubical complex)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Finally, it is also possible to perturb the vertices in a cubical rectangle to obtain a Lefschetz complex consisting of quadrilaterals in the plane. This can be accomplied as follows:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"cc3, coords3 = create_cubical_rectangle(5,2,randomize=0.2)\nfname3 = \"lefschetzex6.pdf\"\nplot_planar_cubical(cc3,coords3,fname3,hfac=1.7,vfac=1.2,cubefac=75)","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The resulting Lefschetz complex is visualized in the last figure of this section.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"(Image: A randomly perturbed cubical complex)","category":"page"},{"location":"man/lefschetz/#Lefschetz-Complex-Operations","page":"Lefschetz Complexes","title":"Lefschetz Complex Operations","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Once a Lefschetz complex has been created, there are a number of manipulations and queries that one has to be able to perform on the complex. At the moment, ConleyDynamics.jl supplies a number of functions for this. The following three functions  provide basic information:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"lefschetz_field returns the field F over which the Lefschetz complex is defined as a String.\nlefschetz_is_closed determines whether a given Lefschetz complex cell subset is closed or not.\nlefschetz_is_locally_closed checks whether a given Lefschetz complex cell subset is locally closed or not.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The next set of functions can be used to extract certain topological features from a Lefschetz complex:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"lefschetz_boundary computes the support of the boundary partialsigma of a Lefschetz complex cell sigma. In other words, it returns the vector of all facets of sigma. The cell can either be specified via its index or its label, and the return format corresponds to the input format.\nlefschetz_coboundary returns all cells which lie in the coboundary of the specified cell sigma, i.e., it returns all cells which have sigma as a facet.\nlefschetz_closure determines the closure of a  given cell subset, i.e., the union of all faces of cells in the cell subset.\nlefschetz_openhull computes the open hull of a cell subset, i.e., the smallest open set which contains the given cell subset.\nlefschetz_lchull finds the locally closed hull of a Lefschetz complex subset. This is the smallest locally closed set which contains the given cell subset. One can show that  it is the intersection of the closure and the open hull of the cell subset.\nlefschetz_clomo_pair determines the closure-mouth-pair associated with a Lefschetz complex subset.\nlefschetz_skeleton computes the k-dimensional skeleton of a Lefschetz complex or of a given Lefschetz complex subset. While in the first case the k-skeleton of the full Lefschetz complex is returned, in the second case it returns the k-skeleton of the closure of the given subset.\nmanifold_boundary returns a list of cells which form the \"manifold boundary\" of the given Lefschetz complex. More  precisely, if the complex has dimension d, then it determines all cells of dimension d-1 which have at most one cell in their coboundary, as well as all cells of dimensions less than d-1 which have no cell in their coboundary, and finally returns the closure of the resulting cell subset.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"The following functions create Lefschetz subcomplexes from a Lefschetz complex:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"lefschetz_subcomplex determines a Lefschetz subcomplex from a given Lefschetz complex. The subcomplex has to be locally closed, and it is given by a collection of cells.\nlefschetz_closed_subcomplex extracts a closed Lefschetz subcomplex from the given Lefschetz complex. The subcomplex is the closure of the specified collection of cells.\npermute_lefschetz_complex determines a new Lefschetz complex which is obtained from the original one by a permutation of the cells.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"There are also two helper functions which can sometimes  be useful:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"lefschetz_gfp_conversion changes the base field of the given Lefschetz complex from the rationals mathbbQ to a finite field GF(p). Note that it is not possible to perform the reverse conversion.\nlefschetz_filtration computes a filtration on a Lefschetz subset. Based on integer filtration values assigned to some cells of the given Lefschetz complex, it determines the smallest closed subcomplex lcsub which contains all cells with nonzero filtration values, as well as filtration values fvalsub on this subcomplex, which give rise to a filtration of closed subcomplexes, and which can be used to compute persistent homology.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"In addition, ConleyDynamics.jl provides the following helper functions for the fundamental objects of cells and cell subsets, which can be represented either by integer cell indices or by cell labels:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"convert_cells converts a vector of cells from integer to label format, or vice versa.\nconvert_cellsubsets converts a vector of cell subsets from integer to label format, and vice versa.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"Finally, there are a couple of ccordinate helper functions which allow for the transformation of vertex coordinates in a Lefschetz complex:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"convert_planar_coordinates transforms a given collection of planar coordinates in such a way that the extreme coordinates fit precisely in a given rectangle in the plane.\nconvert_spatial_coordinates transforms a given collection of spatial coordinates in such a way that the extreme coordinates fit precisely in a given rectangular box in space.","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"For more details on the usage of any of these functions, please see their documentation in the API section of the manual. ","category":"page"},{"location":"man/lefschetz/#reflefschetz","page":"Lefschetz Complexes","title":"References","text":"","category":"section"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/lefschetz/","page":"Lefschetz Complexes","title":"Lefschetz Complexes","text":"P.Alexandrov. Diskrete Rume. MathematiceskiiSbornik(N.S.) 2, 501518 (1937).\n\n\n\nP.Dotko, T.Kaczynski, M.Mrozek and T.Wanner. Coreduction homology algorithm for regular CW-complexes. Discrete&ComputationalGeometry 46, 361388 (2011).\n\n\n\nT.Kaczynski, K.Mischaikow and M.Mrozek. Computational Homology. Vol.157 of Applied Mathematical Sciences (Springer-Verlag, New York, 2004).\n\n\n\nS.Lefschetz. Algebraic Topology. Vol. 27 of American Mathematical Society Colloquium Publications (American Mathematical Society, New York, 1942).\n\n\n\nM.Lipinski, J.Kubica, M.Mrozek and T.Wanner. Conley-Morse-Forman theory for generalized combinatorial             multivector fields on finite topological spaces. JournalofAppliedandComputationalTopology 7, 139184 (2023).\n\n\n\nW.S.Massey. A Basic Course in Algebraic Topology. Vol.127 of Graduate Texts in Mathematics (Springer-Verlag, New York, 1991).\n\n\n\nM.Mrozek and B.Batko. Coreduction homology algorithm. Discrete&ComputationalGeometry 41, 96118 (2009).\n\n\n\nM.Mrozek and T.Wanner. Connection matrices in combinatorial topological dynamics, arXiv:2103.04269 (2023).\n\n\n\nJ.R.Munkres. Elements of Algebraic Topology (Addison-Wesley, Menlo Park, 1984).\n\n\n\n","category":"page"},{"location":"man/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"DocTestSetup = quote\n    push!(LOAD_PATH,\"../../../src/\")\n    using ConleyDynamics\nend","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"In the following we discuss a number of connection matrix examples.","category":"page"},{"location":"man/examples/#Critical-Flow-on-a-Simplex","page":"Examples","title":"Critical Flow on a Simplex","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_critical_simplex(::Int)","category":"page"},{"location":"man/examples/#ConleyDynamics.example_critical_simplex-Tuple{Int64}","page":"Examples","title":"ConleyDynamics.example_critical_simplex","text":"lc, mvf = example_critical_simplex(dim)\n\nCreate a simplicial complex of dimension dim as well as a multivector field on it in which every cell is critical.\n\nThe function returns the Lefschetz complex lc over GF(2) and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_critical_simplex(2);\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0   1   1   0   0]\n[0   0   0   1   0   1   0]\n[0   0   0   0   1   1   0]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   1]\n[0   0   0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"A\", \"B\", \"C\", \"AB\", \"AC\", \"BC\", \"ABC\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#Flow-on-a-Moebius-Strip","page":"Examples","title":"Flow on a Moebius Strip","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_moebius(::Int)","category":"page"},{"location":"man/examples/#ConleyDynamics.example_moebius-Tuple{Int64}","page":"Examples","title":"ConleyDynamics.example_moebius","text":"lc1, mvf1, lc2, mvf2 = example_moebius(p)\n\nCreate two simplicial complexes for a cylinder and Moebius strip, respectively, together with associated multivector fields on them.\n\nThe function returns the Lefschetz complexes lc1 and lc2, as well as the multivector fields mvf1 and mvf2. Both complexes are over a field with characteristic p. Positive  prime characteristic uses the finite field GF(p), while zero characteristic gives the rationals.\n\nThe multivector field is the same, and it has one critical  cell each in dimension 1 and 2 in the interior of the strip. The boundary consists of two periodic orbits for lc1 and mvf1, and of one periodic orbit in the Moebius case lc2 and mvf2. The latter case leads to different connection matrices for the fields GF(2) and GF(7), for example.\n\nExamples\n\njulia> lc1, mvf1, lc2, mvf2 = example_moebius(0);\n\njulia> lc2p2 = lefschetz_gfp_conversion(lc2,2);\n\njulia> lc2p7 = lefschetz_gfp_conversion(lc2,7);\n\njulia> cmp2 = connection_matrix(lc2p2, mvf2);\n\njulia> cmp7 = connection_matrix(lc2p7, mvf2);\n\njulia> sparse_show(cmp2.matrix)\n[0   0   0   0]\n[0   0   0   1]\n[0   0   0   0]\n[0   0   0   0]\n\njulia> sparse_show(cmp7.matrix)\n[0   0   0   0]\n[0   0   0   1]\n[0   0   0   2]\n[0   0   0   0]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#Nonunique-Connection-Matrices","page":"Examples","title":"Nonunique Connection Matrices","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: An example with nonunique connection matrices)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_nonunique()","category":"page"},{"location":"man/examples/#ConleyDynamics.example_nonunique-Tuple{}","page":"Examples","title":"ConleyDynamics.example_nonunique","text":"lc1, lc2, mvf, coords1, coords2 = example_nonunique()\n\nCreate two representations of a simplicial complex and one multivector field which illustrates nonunique connection matrices.\n\nThe two complexes lc1 and lc2 represent the same simplicial complex over GF(2), but differ in the ordering of the labels.\n\nThe function returns the Lefschetz complexes lc1 and lc2, as well as the multivector field mvf. If desired for plotting, the fourth and fifth return values coords1 and coords2 give vectors of coordinates for the vertices of the two complexes.\n\nExamples\n\njulia> lc1, lc2, mvf = example_nonunique();\n\njulia> cm1 = connection_matrix(lc1, mvf);\n\njulia> cm2 = connection_matrix(lc2, mvf);\n\njulia> sparse_show(cm1.matrix)\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   0   0   0   0   1   1]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm1.labels)\n[\"1\", \"6\", \"68\", \"18\", \"34\", \"56\", \"057\", \"238\", \"678\"]\njulia> sparse_show(cm2.matrix)\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   1   0   1   0   0   0]\n[0   0   0   0   0   0   1   0   1]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm2.labels)\n[\"1\", \"7\", \"67\", \"18\", \"34\", \"56\", \"057\", \"238\", \"678\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#Further-Connection-Matrix-Examples","page":"Examples","title":"Further Connection Matrix Examples","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The following examples are taken from [MW23].","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"(Image: Four sample combinatorial vector fields)","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_MW_fig02()","category":"page"},{"location":"man/examples/#ConleyDynamics.example_MW_fig02-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig02","text":"lc, mvf, coords = example_MW_fig02(mvftype)\n\nCreate the simplicial complex and multivector field for the example from Figure 2 in the connection matrix paper by Mrozek & Wanner.\n\nDepending on the value of mvftype, return the periodic orbit (0=default) or one of the three gradient (1,2,3) examples.\n\nThe function returns the Lefschetz complex lc over the rational field and the multivector field mvf. If desired for plotting, the third return value coords gives a vector of coordinates for the vertices.\n\nExamples\n\njulia> lc, mvf = example_MW_fig02(0);\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> print(cm.labels)\n[\"A\", \"C\", \"CE\", \"AC\", \"BD\", \"DF\", \"ABC\", \"EFG\"]\n\njulia> full_from_sparse(cm.matrix)\n88 Matrix{Rational{Int64}}:\n 0  0  0  -1  -1  0   0  0\n 0  0  0   1   1  0   0  0\n 0  0  0   0   0  0   0  0\n 0  0  0   0   0  0  -1  0\n 0  0  0   0   0  0   1  0\n 0  0  0   0   0  0   0  1\n 0  0  0   0   0  0   0  0\n 0  0  0   0   0  0   0  0\n\n\n\n\n\n","category":"method"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_MW_fig01()\nexample_MW_fig03()\nexample_MW_fig04()\nexample_MW_fig11()","category":"page"},{"location":"man/examples/#ConleyDynamics.example_MW_fig01-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig01","text":"lc, mvf = example_MW_fig01()\n\nCreate the simplicial complex and multivector field for the example from Figure 1 in the connection matrix paper by Mrozek & Wanner.\n\nThe function returns the Lefschetz complex lc over GF(2) and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_MW_fig01();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0]\n[0   0   1]\n[0   0   0]\n\njulia> print(cm.labels)\n[\"D\", \"AC\", \"ABC\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#ConleyDynamics.example_MW_fig03-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig03","text":"lc, mvf = example_MW_fig03()\n\nCreate the Lefschetz complex and multivector field for the example from Figure 3 in the connection matrix paper by Mrozek & Wanner.\n\nThe function returns the Lefschetz complex lc over GF(2) and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_MW_fig03();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0   0]\n[0   0   0   0]\n[0   0   0   0]\n[0   0   0   0]\n\njulia> print(cm.labels)\n[\"BD\", \"DF\", \"AC\", \"CE\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#ConleyDynamics.example_MW_fig04-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig04","text":"lc1, lc2, mvf = example_MW_fig04()\n\nCreate two representations of the Lefschetz complex and the multivector field for the example from Figure 4 in the connection matrix paper by Mrozek & Wanner.\n\nThe complexes lc1 and lc2 are just two representations of the same complex, but they lead to different connection matrices. Both Lefschetz complexes are defined over the finite field GF(2).\n\nThe function returns the Lefschetz complexes lc1 and lc2, as well as the multivector field mvf.\n\nExamples\n\njulia> lc1, lc2, mvf = example_MW_fig04();\n\njulia> cm1 = connection_matrix(lc1, mvf);\n\njulia> cm2 = connection_matrix(lc2, mvf);\n\njulia> full_from_sparse(cm1.matrix)\n44 Matrix{Int64}:\n 0  0  0  0\n 0  0  0  1\n 0  0  0  1\n 0  0  0  0\n\njulia> full_from_sparse(cm2.matrix)\n44 Matrix{Int64}:\n 0  0  0  0\n 0  0  0  0\n 0  0  0  1\n 0  0  0  0\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#ConleyDynamics.example_MW_fig11-Tuple{}","page":"Examples","title":"ConleyDynamics.example_MW_fig11","text":"lc, mvf = example_MW_fig11(mvftype)\n\nCreate the Lefschetz complex and multivector field for the example from Figure 11 in the connection matrix paper by Mrozek & Wanner.\n\nDepending on the value of mvftype, return the multivector (0=default) or one of the two combinatorial vector field (1,2) examples.\n\nThe function returns the Lefschetz complex lc over the rationals and the multivector field mvf.\n\nExamples\n\njulia> lc, mvf = example_MW_fig11(1);\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> full_from_sparse(cm.matrix)\n55 Matrix{Rational{Int64}}:\n 0  0  1  -1  -1\n 0  0  1   0   0\n 0  0  0   0   0\n 0  0  0   0   0\n 0  0  0   0   0\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#Forman-Vector-Field-Examples","page":"Examples","title":"Forman Vector Field Examples","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The following examples are taken from [BKMW20].","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"example_BKMW20_fig1()\nexample_BKMW20_fig3()","category":"page"},{"location":"man/examples/#ConleyDynamics.example_BKMW20_fig1-Tuple{}","page":"Examples","title":"ConleyDynamics.example_BKMW20_fig1","text":"lc, mvf, coords = example_BKMW20_fig1()\n\nCreate the simplicial complex and multivector field for the example from Figure 1 in the FoCM 2020 paper by Batko, Kaczynski, Mrozek, and Wanner.\n\nThe function returns the Lefschetz complex lc and the  multivector field mvf. If desired for plotting, the third return value coords gives a vector of coordinates for the vertices. The Lefschetz complex is defined over the finite field GF(2).\n\nExamples\n\njulia> lc, mvf = example_BKMW20_fig1();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0   0   1]\n[0   0   0   0   0]\n[0   0   0   0   1]\n[0   0   0   0   0]\n[0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"A\", \"AD\", \"F\", \"BF\", \"DE\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#ConleyDynamics.example_BKMW20_fig3-Tuple{}","page":"Examples","title":"ConleyDynamics.example_BKMW20_fig3","text":"lc, mvf, coords = example_BKMW20_fig3()\n\nCreate the simplicial complex and multivector field for the example from Figure 3 in the FoCM 2020 paper by Batko, Kaczynski, Mrozek, and Wanner.\n\nThe function returns the Lefschetz complex lc over the finite field GF(2) and the multivector field mvf. If desired for plotting, the third return value coords gives a vector of coordinates for the vertices.\n\nExamples\n\njulia> lc, mvf = example_BKMW20_fig3();\n\njulia> cm = connection_matrix(lc, mvf);\n\njulia> sparse_show(cm.matrix)\n[0   0   0   0   1   0   1   0   0]\n[0   0   0   0   0   1   0   0   0]\n[0   0   0   0   1   1   1   0   0]\n[0   0   0   0   0   0   0   0   1]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   1   0]\n[0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0]\n\njulia> print(cm.labels)\n[\"D\", \"E\", \"F\", \"GJ\", \"BF\", \"EF\", \"HI\", \"ADE\", \"FGJ\"]\n\n\n\n\n\n","category":"method"},{"location":"man/examples/#refexamples","page":"Examples","title":"References","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"B.Batko, T.Kaczynski, M.Mrozek and T.Wanner. Linking combinatorial and classical dynamics: Conley             index and Morse decompositions. FoundationsofComputationalMathematics 20, 9671012 (2020).\n\n\n\nM.Mrozek and T.Wanner. Connection matrices in combinatorial topological dynamics, arXiv:2103.04269 (2023).\n\n\n\n","category":"page"},{"location":"man/conley/#Conley-Theory","page":"Conley Theory","title":"Conley Theory","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Here we need a more detailed description of Conley theory, and in particular connection matrices.  In particular, this should discuss the various field types that can be used, as well as all the entries in the ConleyMorseCM data structure.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"[KMW16] [MW21] [DLMS24] [SW14b] [SW14a]","category":"page"},{"location":"man/conley/#Morse-Decomposition-Intervals","page":"Conley Theory","title":"Morse Decomposition Intervals","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"We briefly return to one of the examples in the tutorial. More precisely, we consider the planar ordinary differential equation given by","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   beginarrayrcl\n     dotx_1  =  x_1 left( 1 - x_1^2 - 3 x_2^2 right) 1ex\n     dotx_2  =  x_2 left( 1 - 3 x_1^2 - x_2^2 right)\n   endarray","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The dynamics of this system is characterized by the existence of a global attractor in the shape of a closed disk. Inside the attractor, there are nine different Morse sets:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The origin is an equilibrium of index 2, i.e., it is an unstable stationary state with a two-dimensional unstable manifold.\nThe four points (pm 12 pm 12) are unstable equilibria of index 1, i.e., with a one-dimensional unstable manifold.\nFinally, the four points (pm 1 0) and (0 pm 1) are asymptotically stable stationary states.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"We saw in the tutorial that the Morse decomposition of this system can easily be found using ConleyDynamics.jl, as well as the associated connection matrix. Yet, in certain situations one might only be interested in part of the dynamics on the attractor. Moreover, while the Morse sets describe the recurrent part of the dynamics, they do not provide information on the geometry of the connecting sets between the Morse sets. In the following, we illustrate how this can be analyzed further.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The right-hand side of the above vector field can be implemented using the Julia function","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"using ..ConleyDynamics # hide\nusing Random # hide\nRandom.seed!(1234) # hide\nfunction planarvf(x::Vector{Float64})\n    #\n    # Sample planar vector field with nontrivial Morse decomposition\n    #\n    x1, x2 = x\n    y1 = x1 * (1.0 - x1*x1 - 3.0*x2*x2)\n    y2 = x2 * (1.0 - 3.0*x1*x1 - x2*x2)\n    return [y1, y2]\nend","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"To analyze the resulting global dynamical behavior, we first create a simplicial mesh covering the square -65 65^2 using the commands","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"lc, coords = create_simplicial_delaunay(300, 300, 5, 50);\ncoordsN = convert_planar_coordinates(coords,[-1.2,-1.2], [1.2,1.2]);\nlc.ncells","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The integer in the output gives the number of cells in the created Lefschetz complex X. Note that we are using a Delaunay triangulation over an initial box of size 300 times 300, where the target triangle size is about 5. This box is then rescaled to cover the above square. We can then create a  multivector field on the simplicial complex lc and find its Morse decomposition using the commands","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"mvf = create_planar_mvf(lc, coordsN, planarvf);\nmorsedecomp = morse_sets(lc, mvf);\nlength(morsedecomp)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"As expected, ConleyDynamics.jl finds exactly nine Morse sets. Their  Conley indices can be computed and stored in a Vector{Vector{Int}} using the command","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"conleyindices = [conley_index(lc, mset) for mset in morsedecomp]","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"These Conley indices correspond to the dynamical behavior near the equilibrium solutions described above.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Suppose now that rather than finding the connection matrix for the complete Morse decomposition, we would only like to consider a  part of it. This can be done as long as we restrict our attention to an interval in the Morse decomposition. Such an interval mathcalI can be created from a selection mathcalS of the Morse sets in the following way:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In addition to the Morse sets in mathcalS, the interval mathcalI contains all Morse sets that lie between two Morse sets in mathcalS with respect to the poset order underlying the Morse decomposition. Recall that this poset order can be computed via morse_sets by activating the extra return object hasse, which describes the Hasse diagram of the poset.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"With every interval mathcalI of the Morse decomposition one can assign a smallest isolated invariant set X_mathcalI subset X which describes the complete dynamics within and between the Morse sets in mathcalI. In fact, in can be characterized as follows:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The set X_mathcalI consists of all cells in the  underlying Lefschetz complex X through which one can find a solution which originates in one Morse set of mathcalI and ends in another Morse set of mathcalI, where the two involved Morse sets can be the same. In other words, one needs to combine the interval Morse sets with all connecting orbits between them.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The two above steps can be performed in ConleyDynamics.jl using the function morse_interval.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In our example, we consider two intervals. The first interval consists of the five Morse sets corresponding to all unstable equilibrium solutions, while the second one considers the four index 1 and the four stable stationary states. The associated isolated invariant sets for these two intervals can be computed as follows:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"subset1 = findall(x -> x[2]+x[3]>0, conleyindices);\nsubset2 = findall(x -> x[1]+x[2]>0, conleyindices);\nlcsub1 = morse_interval(lc, mvf, morsedecomp[subset1]);\nlcsub2 = morse_interval(lc, mvf, morsedecomp[subset2]);\n[length(subset1), length(subset2), length(lcsub1), length(lcsub2)]","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The output shows that we have in fact extracted five and eight Morse sets, respectively. It also shows that the Lefschetz complexes corresponding to these two isolated invariant sets are much smaller than X.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"So far, we have just determined the collections of cells that  correspond to the two isolated invariant sets for these intervals. We can now restrict the combinatorial dynamics to these subsets.  Note that since they are both isolated invariant sets, they are locally closed in X, and therefore the restrictions provide us with two new Lefschetz complexes lcr1 and lcr2, along with induced multivector fields mvfr1 and mvfr2, respectively. In ConleyDynamics.jl, this is achieved using the commands","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"lcr1, mvfr1 = restrict_dynamics(lc, mvf, lcsub1);\nlcr2, mvfr2 = restrict_dynamics(lc, mvf, lcsub2);\n[lcr1.ncells, lcr2.ncells]","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"It is now easy to find the connection matrices for these two intervals. The first connection matrix is given by","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"cmr1 = connection_matrix(lcr1, mvfr1);\ncmr1.conley","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"full_from_sparse(cmr1.matrix)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"It clearly shows that the unstable index 2 Morse set has connecting orbits to every one of the four index 1  equilibria. Similarly, the second connection matrix can be determined as","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"cmr2 = connection_matrix(lcr2, mvfr2);\ncmr2.conley","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"full_from_sparse(cmr2.matrix)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In this case, every index 1 equilibrium is connected  two its two neighboring stable stationary states via heteroclinics that are detected by the connection matrix.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The Lefschetz complexes associated with the two Morse decomposition intervals can also be visualized in ConleyDynamics.jl. For this, recall that the function plot_planar_simplicial_morse can plot an underlying simplicial complex together with any collection of cell  subsets. For our purposes, we use the following commands:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"show1 = [[lcr1.labels]; cmr1.morse];\nshow2 = [[lcr2.labels]; cmr2.morse];\nfname1 = \"/Users/wanner/Desktop/invariantinterval2d1.png\"\nfname2 = \"/Users/wanner/Desktop/invariantinterval2d2.png\"\nplot_planar_simplicial_morse(lc, coordsN, fname1, show1, vfac=1.1, hfac=2.0)\nplot_planar_simplicial_morse(lc, coordsN, fname2, show2, vfac=1.1, hfac=2.0)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The variable show1 collects not only the Morse sets that are part of the first connection matrix cmr1, but also the support of the Lefschetz complex lcr1. This support is accessed via [lcr1.labels], and we add it as a first vector of cells in show1. Similarly, we determine the support of the second  isolated invariant set, together with the Morse sets of cmr2. The remaining four commands create two images.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Interval support for the first interval)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The first image shows the five Morse sets surrounding the stationary states at the origin and at (pm 12 pm 12). In addition, it highlights the support of the isolated invariant set associated with this Morse decomposition interval. One can clearly see rough outer approxomations for the four heteroclinics which start at the origin and end at the index 1 equilibria. These approximations are necessarily coarse, since we are not working with a very fine triangulation.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Interval support for the second interval)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Finally, the second image depicts the eight Morse sets enclosing the index 1 and the stable stationary states. It also shows the support of the Lefschetz complex lcr2 which is associated with this Morse decomposition interval. In this case, it covers eight different heteroclinic orbits, which are in fact better approximated than the four in the previous image.","category":"page"},{"location":"man/conley/#Cubical-Analysis-of-a-Planar-System","page":"Conley Theory","title":"Cubical Analysis of a Planar System","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Our next example illustrates how ConleyDynamics.jl can be used to analyze the global dynamics of a planar ordinary differential equations. For this, consider the planar system","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   beginarrayrcl\n     dotx_1  =   x_2 - x_1 left( x_1^2 + x_2^2 - 4 right)\n       left( x_1^2 + x_2^2 - 1 right) 1ex\n     dotx_2  =  -x_1 - x_2 left( x_1^2 + x_2^2 - 4 right)\n       left( x_1^2 + x_2^2 - 1 right)\n   endarray","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"This system has already been considered in [MSTW22]. The right-hand side of this vector field can be implemented using the Julia function","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"using ..ConleyDynamics # hide\nfunction circlevf(x::Vector{Float64})\n    #\n    # Sample vector field with nontrivial Morse decomposition\n    #\n    x1, x2 = x\n    c0 = x1*x1 + x2*x2\n    c1 = (c0 - 4.0) * (c0 - 1.0)\n    y1 =  x2 - x1 * c1\n    y2 = -x1 - x2 * c1\n    return [y1, y2]\nend","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"To analyze the global dynamics of this vector field, we first create a cubical complex covering the square -3 3^2 using the commands","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"n = 51\nlc, coords = create_cubical_rectangle(n,n,p=2);\ncoordsN = convert_planar_coordinates(coords,[-3.0,-3.0],[3.0,3.0]);\nlc.ncells","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"As the last result shows, this gives a Lefschetz complex with 10609 cells. The multivector field can be generated using","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"mvf = create_planar_mvf(lc, coordsN, circlevf);\nlength(mvf)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"This multivector field consists of 2437 multivectors. Finally, the  connection matrix can be determined using the command","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"cm = connection_matrix(lc, mvf);\ncm.conley","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Therefore, the above planar system has three isolated invariant sets. One has the Conley index of a stable equilibrium, while the other two have that of a stable and an unstable periodic orbit. The columns of the connection matrix correspond to these invariant sets as follows","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"cm.poset","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The connection matrix itself is given by","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"full_from_sparse(cm.matrix)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"This implies that there are connecting orbits from the unstable  periodic orbit to both the stable equilibrium, and the stable periodic orbit. To visualize these Morse sets, we employ the  commands","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"fname = \"cubicalcircles.pdf\"\nplot_planar_cubical_morse(lc, fname, cm.morse, pv=true)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Morse sets of the planar circles vector field)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In the above example we used the original fixed cubical grid, which is just a scaled version of the grid on the integer lattice. It is also possible to work with a randomized grid, in which the coordinates of the vertices are randomly perturbed. This can be achieved with the following commands:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"nR = 75\nlcR, coordsR = create_cubical_rectangle(nR,nR,p=2,randomize=0.33);\ncoordsRN = convert_planar_coordinates(coordsR,[-3.0,-3.0],[3.0,3.0]);\nmvfR = create_planar_mvf(lcR, coordsRN, circlevf);\ncmR = connection_matrix(lcR, mvfR);\nfnameR = \"cubicalcirclesR.pdf\"\nplot_planar_cubical_morse(lcR, coordsRN, fnameR, cmR.morse, pv=true, vfac=1.1, hfac=2.0)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Morse sets of the planar circles vector field via randomized cubes)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"To constrast the above example with the use of a Delaunay triangulation, we reanalyze the vector field in the following way:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"lc2, coords2 = create_simplicial_delaunay(400, 400, 10, 30, p=2)\ncoords2N = convert_planar_coordinates(coords2,[-3.0,-3.0], [3.0,3.0])\nmvf2 = create_planar_mvf(lc2, coords2N, circlevf)\ncm2 = connection_matrix(lc2, mvf2)\n\nfname2 = \"cubicalcircles2.pdf\"\nplot_planar_simplicial_morse(lc2, coords2N, fname2, cm2.morse, pv=true)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In this case, the Morse sets can be visualized as in the figure.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Morse sets of the planar circles vector field via Delaunay)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Notice that we can also show the individual multivectors in more detail. For the above example, we can plot all multivectors of the multivector field mvf2 which consist of at least 10 cells using the commands","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"mv_indices = findall(x -> (length(x)>9), mvf2)\nlarge_mv = mvf2[mv_indices]\n\nfname3 = \"cubicalcircles3.pdf\"\nplot_planar_simplicial_morse(lc2, coords2N, fname3, large_mv, pv=true)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Large multivectors in the Delaunay multivector field)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Note that in this example, there are only 20 large multivectors.","category":"page"},{"location":"man/conley/#Cubical-Analysis-of-a-Spatial-System","page":"Conley Theory","title":"Cubical Analysis of a Spatial System","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"It is also possible to analyze certain three-dimensional ordinary differential equations in ConleyDynamics.jl. To provide one such example, consider the system","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   beginarrayrcl\n     dotx_1  =  (lambda-1) x_1 - frac3lambda2pi\n       left( (x_1^3 - x_1^2 x_3 + x_2^2 x_3 + 2 x_1\n       left( x_2^2 + x_3^2 right) right) 1ex\n     dotx_2  =  (lambda-4) x_2 - frac3lambda2pi \n       x_2 left( 2 x_1^2 + x_2^2 + 2 x_1 x_3 + 2 x_3^2 right) 1ex\n     dotx_3  =  (lambda-9) x_3 + fraclambda2pi\n       left( x_1 left( x_1^2 - 3 x_2^2 right) - 3 x_3\n       left( 2 x_1^2 + 2 x_2^2 + x_3^2 right) right)\n   endarray","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"This system arises in the study of the so-called Allen-Cahn equation, which is the parabolic partial differential equation given by","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   u_t = Delta u + lambda left( u - u^3 right)\n   text in  Omega = (0pi)\n   quadtext with quad\n   u = 0 text on  partialOmega  ","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"This partial differential equation can be interpreted as an infinite-dimensional system of ordinary differential equations, see for example [SW24, Section 6.1]. For this, one has to expand the unknown function u(tcdot) as a generalized Fourier series with respect to the basis functions","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"   varphi_k(x) = sqrtfrac2pi  sin(k pi x)\n   quadtext for quad\n   k in mathbbN  ","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"If one truncates this series representation after three terms, and projects the right-hand side of the partial differential equation onto the linear space spanned by the first three basis functions, then the three coefficients of the approximating sum satisfy the above three-dimensional ordinary differential equation. Thus, this system provides a model for the dynamics of the partial differential equation, at least for sufficiently small values of the parameter lambda. It can be implemented in Julia using the following commands:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"function allencahn3d(x::Vector{Float64})\n    #\n    # Allen-Cahn projection\n    #\n    lambda = 3.0 * pi\n    c      = lambda / pi\n    x1, x2, x3 = x\n    y1 = (lambda-1)*x1 - 1.5*c * (x1*x1*x1-x1*x1*x3+x2*x2*x3+2*x1*(x2*x2+x3*x3))\n    y2 = (lambda-4)*x2 - 1.5*c * x2 * (2*x1*x1+x2*x2+2*x1*x3+2*x3*x3)\n    y3 = (lambda-9)*x3 + 0.5*c * (x1*(x1*x1-3*x2*x2)-3*x3*(2*x1*x1+2*x2*x2+x3*x3))\n    return [y1, y2, y3]\nend","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Notice that for our example we use the parameter value lambda = 3pi. In this particular case, one can show numerically that the system has seven equilibrium solutions. These are approximately given as follows:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Two equilibria pm(145165  0  024396) of index 0.\nTwo equilibria pm(0  109796  0) of index 1.\nTwo equilibria pm(0  0  0307238) of index 2.\nOne equilibrium (0  0  0) of index 3.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"In order to find the associated Morse decomposition, one can use the commands","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"N = 25\nbmax = [1.8, 1.5, 1.0]\nlc, coordsI = create_cubical_box(N,N,N);\ncoordsN = convert_spatial_coordinates(coordsI, -bmax, bmax);\nmvf = create_spatial_mvf(lc, coordsN, allencahn3d);","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"These commands create a cubical box of size 25 times 25 times 25 which covers the region -1818 times -1515 times -1010. In addition, we construct a multivector field mvf which encapsulates the possible dynamics of the system. After these preparations, the Morse decomposition can be computed via","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"morsedecomp = morse_sets(lc, mvf);\nmorseinterval = morse_interval(lc, mvf, morsedecomp);\nlci, mvfi = restrict_dynamics(lc, mvf, morseinterval);\ncmi = connection_matrix(lci, mvfi);","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"While the first command finds the actual Morse decomposition, the second one restricts the Lefschetz complex and the multivector field to the smallest isolated invariant set which contains all Morse sets and  connecting orbits between them. The last command finds the connection matrix.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"To see whether the above commands did indeed find the correct dynamical behavior, we first inspect the computed Conley indices of the Morse sets:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"julia> cmi.conley\n7-element Vector{Vector{Int64}}:\n [1, 0, 0, 0]\n [1, 0, 0, 0]\n [0, 1, 0, 0]\n [0, 1, 0, 0]\n [0, 0, 1, 0]\n [0, 0, 1, 0]\n [0, 0, 0, 1]","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Clearly, these are the correct indices based on our numerical information  concerning the stationary states of the system. The connection matrix  is given by:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"julia> full_from_sparse(cmi.matrix)\n77 Matrix{Int64}:\n 0  0  1  1  0  0  0\n 0  0  1  1  0  0  0\n 0  0  0  0  1  1  0\n 0  0  0  0  1  1  0\n 0  0  0  0  0  0  1\n 0  0  0  0  0  0  1\n 0  0  0  0  0  0  0","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"Thus, there are a total of ten connecting orbits that are induced through algebraic topology. The index 3 equilibrium at the origin has connections to each of the index 2 solutions, which lie above and below the origin in the direction of the x_3-axis. Each of the latter two stationary states has connections to both index 1 equilibria. Finally, each of these is connected to both stable states.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: The dynamics of an Allen-Cahn model)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"The location of the computed Morse sets is illustrated in the accompanying figure, which uses x, y, and z instead of the variable names x_1, x_2, and x_3, respectively. Notice that while the stationary states of index 0, 2, and 3 are all well-localized, this cannot be said about the two equilibria of index 1. The computed enclosures for the latter two are elongated cubical sets which are shown along the upper left and lower right of the figure. This overestimation is a result of the use of a strict cubical grid, combined with the small discretization size N = 25. Nevertheless, the above simple code does reproduce the overall global dynamical behavior of the ordinary differential equation correctly.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"One can also compute over Morse intervals, rather than the complete Morse decomposition. The final two images show two views of the  Morse interval which corresponds to one of the index 1 equilibria, and the two stable stationary states. These computations were  performed with the finer resolution N = 51.","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Allen-Cahn Morse interval, View 1)","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"(Image: Allen-Cahn Morse interval, View 2)","category":"page"},{"location":"man/conley/#refconley","page":"Conley Theory","title":"References","text":"","category":"section"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/conley/","page":"Conley Theory","title":"Conley Theory","text":"T.K.Dey, M.Lipiski, M.Mrozek and R.Slechta. Computing connection matrices via persistence-like reductions. SIAMJournalonAppliedDynamicalSystems 23, 8197 (2024).\n\n\n\nT.Kaczynski, M.Mrozek and T.Wanner. Towards a formal tie between combinatorial and classical             vector field dynamics. JournalofComputationalDynamics 3, 1750 (2016).\n\n\n\nM.Mrozek, R.Srzednicki, J.Thorpe and T.Wanner. Combinatorial vs. classical dynamics: Recurrence. CommunicationsinNonlinearScienceandNumericalSimulation 108, Paper No. 106226, 30 pages (2022).\n\n\n\nM.Mrozek and T.Wanner. Creating semiflows on simplicial complexes from combinatorial vector fields. JournalofDifferentialEquations 304, 375434 (2021).\n\n\n\nE.Sander and T.Wanner. Theory and Numerics of Partial Differential Equations (SIAM, Philadelphia, 2024). In preparation, 1007pages.\n\n\n\nT.Stephens and T.Wanner. Isolating block validation in Matlab, https://github.com/almost6heads/isoblockval (2014).\n\n\n\nT.Stephens and T.Wanner. Rigorous validation of isolating blocks for flows and               their Conley indices. SIAMJournalonAppliedDynamicalSystems 13, 18471878 (2014).\n\n\n\n","category":"page"},{"location":"man/references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"man/references/","page":"References","title":"References","text":"P.Alexandrov. Diskrete Rume. MathematiceskiiSbornik(N.S.) 2, 501518 (1937).\n\n\n\nB.Batko, T.Kaczynski, M.Mrozek and T.Wanner. Linking combinatorial and classical dynamics: Conley             index and Morse decompositions. FoundationsofComputationalMathematics 20, 9671012 (2020).\n\n\n\nC.Conley. Isolated Invariant Sets and the Morse Index (American Mathematical Society, Providence, R.I., 1978).\n\n\n\nP.Dotko, T.Kaczynski, M.Mrozek and T.Wanner. Coreduction homology algorithm for regular CW-complexes. Discrete&ComputationalGeometry 46, 361388 (2011).\n\n\n\nT.K.Dey, M.Lipiski, M.Mrozek and R.Slechta. Computing connection matrices via persistence-like reductions. SIAMJournalonAppliedDynamicalSystems 23, 8197 (2024).\n\n\n\nP.Dotko and T.Wanner. Rigorous cubical approximation and persistent homology of             continuous functions. Computers&MathematicswithApplications 75, 16481666 (2018).\n\n\n\nH.Edelsbrunner and J.L.Harer. Computational Topology (American Mathematical Society, Providence, 2010).\n\n\n\nR.Forman. Combinatorial vector fields and dynamical systems. MathematischeZeitschrift 228, 629681 (1998).\n\n\n\nR.Forman. Morse theory for cell complexes. AdvancesinMathematics 134, 90145 (1998).\n\n\n\nM.Gameiro, K.Mischaikow and T.Wanner. Evolution of pattern complexity in the Cahn-Hilliard             theory of phase separation. ActaMaterialia 53, 693704 (2005).\n\n\n\nT.Kaczynski, K.Mischaikow and M.Mrozek. Computational Homology. Vol.157 of Applied Mathematical Sciences (Springer-Verlag, New York, 2004).\n\n\n\nT.Kaczynski, M.Mrozek and T.Wanner. Towards a formal tie between combinatorial and classical             vector field dynamics. JournalofComputationalDynamics 3, 1750 (2016).\n\n\n\nS.Lefschetz. Algebraic Topology. Vol. 27 of American Mathematical Society Colloquium Publications (American Mathematical Society, New York, 1942).\n\n\n\nM.Lipinski, J.Kubica, M.Mrozek and T.Wanner. Conley-Morse-Forman theory for generalized combinatorial             multivector fields on finite topological spaces. JournalofAppliedandComputationalTopology 7, 139184 (2023).\n\n\n\nW.S.Massey. A Basic Course in Algebraic Topology. Vol.127 of Graduate Texts in Mathematics (Springer-Verlag, New York, 1991).\n\n\n\nM.Mrozek and B.Batko. Coreduction homology algorithm. Discrete&ComputationalGeometry 41, 96118 (2009).\n\n\n\nM.Mrozek, R.Srzednicki, J.Thorpe and T.Wanner. Combinatorial vs. classical dynamics: Recurrence. CommunicationsinNonlinearScienceandNumericalSimulation 108, Paper No. 106226, 30 pages (2022).\n\n\n\nM.Mrozek and T.Wanner. Creating semiflows on simplicial complexes from combinatorial vector fields. JournalofDifferentialEquations 304, 375434 (2021).\n\n\n\nM.Mrozek and T.Wanner. Connection matrices in combinatorial topological dynamics, arXiv:2103.04269 (2023).\n\n\n\nJ.R.Munkres. Elements of Algebraic Topology (Addison-Wesley, Menlo Park, 1984).\n\n\n\nE.Sander and T.Wanner. Theory and Numerics of Partial Differential Equations (SIAM, Philadelphia, 2024). In preparation, 1007pages.\n\n\n\nT.Stephens and T.Wanner. Isolating block validation in Matlab, https://github.com/almost6heads/isoblockval (2014).\n\n\n\nT.Stephens and T.Wanner. Rigorous validation of isolating blocks for flows and               their Conley indices. SIAMJournalonAppliedDynamicalSystems 13, 18471878 (2014).\n\n\n\nGUDHI Project. GUDHI User and Reference Manual. 3.10.1Edition (GUDHI Editorial Board, 2024).\n\n\n\n","category":"page"},{"location":"man/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial explains the basic usage of the main components of ConleyDynamics.jl.  It is not meant to be exhaustive, and more details will be provided in the more indiviualized sections. Also, precise mathematical definitions will be delayed until then. The presented examples are taken from the papers [BKMW20] and [MW23], with minor modifications.","category":"page"},{"location":"man/tutorial/#Creating-Simplicial-Complexes","page":"Tutorial","title":"Creating Simplicial Complexes","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The fundamental mathematical object for ConleyDynamics.jl is a Lefschetz complex [Lef42]. For now we note that both simplicial complexes and cubical complexes are special cases, and ConleyDynamics.jl provides convenient interfaces for generating them.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"For the sake of simplicity, this tutorial only considers the case of a simplicial complex. Recall that an abstract simplicial complex K is just a collection of finite sets, called simplices, which is closed under taking subsets. In other words, every subset of a simplex is again a simplex. Each simplex sigma has an associated dimension dimsigma, which is one less than the number of its elements. One usually calls simplices of dimension 0 vertices, edges have dimension 1, and simplices of dimension 2 are triangles. It follows easily from these definitions that every simplex is the union of its vertices.  The following notions associated with simplicial complexes are important for this introduction:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A face of a simplex is any of its subsets. Notice that every simplex is a face of itself, and it is the only face that has the same dimension as the simplex. Faces whose dimension is strictly smaller are referrred to as proper faces.\nThe boundary of a simplex sigma is the collection of all proper faces of sigma. For a triangle, this amounts to all three edges and all three vertices which are part of it.\nA facet of a simplex sigma is any face tau with dimension dimtau = dimsigma - 1. Notice that the facets of a simplex are the faces in its boundary of maximal dimension.\nThe closure of a subset K_0 of a simplicial complex K consists of the collection of all faces of simplices in K_0, and we denote the closure by mathrmcl K_0.\nA subset K_0 of a simplicial complex K is called closed, if it equals its closure. In other words, K_0 is closed if and only if for every simplex sigma in K_0 all of its boundary simplices are part of K_0 as well. Thus, a closed subset of a simplicial complex is a simplicial complex in its own right.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In ConleyDynamics.jl it is easy to generate a simplicial complex. This requires two objects:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The vertices are described by a vector labels of string labels for the vertices of the simplicial complex. Thus, the length of the vector equals the number of vertices, and the k-th entry is the label for the k-th vertex.\nIn addition, a second vector simplices has to describe enough simplices so that the simplicial complex is determined. This object is a vector of vectors, and the vector simplices[k] describes the index values of all the vertices in the k-th simplex. These indices are precisely the corresponding locations of the vertices in labels.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Simplices via labels\nIt is also possible to specify the list of simplices using a Vector{Vector{String}}, i.e., as a vector of string vectors. In this case, the entry simplices[k] is a list of the labels of the vertices.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Watch the label length\nIt is expected that the labels in labels all have the same number of characters. This is due to the fact that when creating the simplicial complex, ConleyDynamics.jl automatically creates  labels for each of the simplices in K, by concatenating the vertex labels. Not using a fixed label size could lead to  ambiguities, and will therefore raise an error message.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: A first simplicial complex)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The following first example creates a simple simplicial complex.  The complex is shown in the above figure, and it has six vertices which we label by the first six letters.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"using ..ConleyDynamics # hide\nlabels = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\nsimplices = [[\"A\",\"B\"],[\"A\",\"C\"],[\"B\",\"C\"],[\"B\",\"D\"],[\"D\",\"E\",\"F\"]]\nsc = create_simplicial_complex(labels,simplices)\nfieldnames(typeof(sc))","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Based on the simplex specifications, the generated simplicial complex K consists of three edges connecting each of the vertices A, B, and C, a two-dimensional triangle DEF, as well as the edge BD which connects the triangle boundary and the filled triangle. The created struct sc is of type LefschetzComplex, with fieldnames as indicated in the above output. The number of cells in the complex can be seen as follows:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(sc.ncells)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the final simplicial complex has a total of seven edges, since also the edges of DEF are part of the simplicial complex. They are automatically generated by create_simplicial_complex. The dimension of K is the largest simplex dimensions, and can be recalled via","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(sc.dim)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The sc struct contains a vector of labels, which in this case takes the form","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(sc.labels)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, the Lefschetz complex data structure for our simplicial complex K includes the dimensions for the corresponding cells in the integer vector sc.dimensions, a dictionary sc.indices which associates each simplex label with its integer index, and the boundary map sc.boundary which will be described in more detail in Lefschetz Complexes. The latter map is internally stored as a sparse matrix over either a finite field or over the rationals. See also the discussion of Sparse Matrices.","category":"page"},{"location":"man/tutorial/#Computing-Homology-and-Persistence","page":"Tutorial","title":"Computing Homology and Persistence","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Any simplicial complex, and in fact any Lefschetz complex, has an associated homology. Informally, homology describes the connectivity structure of the simplicial complex. More precisely, the homology consists of a sequence of integers, called the Betti numbers, which are indexed by dimension. There are Betti numbers beta_k(K) for every k = 0ldotsdim K. The zero-dimensional Betti number beta_0(K) gives the number of connected components of K, while beta_1(K) counts the number of independent loops that can be found in K. Finally, beta_2(K) equals the number of cavities. In our case, we have","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"homology(sc)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This means that the simplicial complex K has one component, as well as one loop, and no cavities. The function homology returns a vector of integers, whose k-th entry is beta_k-1(K). We would like to point out that in ConleyDynamics.jl all homology computations are performed over fields, and  therefore homology is completely described by the Betti numbers. Two types of fields are supported, and they are selected by the characteristic p in the sparse boundary matrix:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"If p=0, then the homology computation uses the field of rational numbers.\nFor any prime number p, homology is determined over the finite field GF(p) with p elements. ","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"ConleyDynamics.jl also allows for the computation of relative homology. In the case of relative homology, together with the simplicial complex K one has to specify a closed subcomplex K_0. Intuitively, the relative homology H_*(KK_0) is the homology of a new space, which is obtained from K by identifying K_0 to a single point, and then decreasing the zero-dimensional Betti number by 1. Consider for example the following command:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"relative_homology(sc, [1,6])","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In this case, the subcomplex K_0 consists of the two vertices A and F, which are therefore glued together. This leads to zero Betti numbers in dimension 0 and 2 (remember that the zero-dimensional Betti number is decreased by 1!), and a one-dimensional Betti number of 2. The latter is increased by one since we obtain a second loop by moving from A to F = A along the edges AB, BD, and DF.  Another example is the following:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"relative_homology(sc, [\"DE\",\"DF\",\"EF\"])","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Now the subcomplex K_0 consists of the edges DE, DF, and EF  together with the three vertices D, E, and F which are automatically added by relative_homology. Identifying them all to one point creates a hollow two-dimensional sphere, and the relative Betti numbers reflect that fact.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As the above two examples demonstrate, the subcomplex can be specified either as a list of simplex indices, or through the simplex labels.  Moreover, the specfied subspace simplex list is automatically extended by relative_homology to include all simplex faces, i.e., it computes the simplicial closure to arrive at a closed subcomplex. Finally, note that the subcomplex can be empty:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"relative_homology(sc, [])","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected, in this case one obtains the standard homology of sc.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In addition to regular and relative homology, ConleyDynamics.jl can also compute persistent homology. For this, one has to specify a filtration of closed Lefschetz complexes","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"  K_1 subset K_2 subset ldots subset K_m ","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Persistent homology tracks the appearance and disappearance (also often called the birth and death) of topological features as one moves through the complexes in the filtration. In ConleyDynamics.jl, one can specify a Lefschetz complex filtration by assigning the integer k to each simplex that first appears in K_k. Moreover, it is expected that K_m = K. Then the persistent homology is computed via the following command:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"filtration = [1,1,1,2,2,2,1,1,1,3,2,2,2,4]\nphsingles, phpairs = persistent_homology(sc, filtration)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The function returns the persistence intervals, which give the birth and death indices of each topological feature in each dimension. There are two types of intervals:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Intervals of the form ainfty) correspond to topological features that first appear in K_a and are still present in the final complex. The starting indices of such features in dimension k are contained in the list phsingles[k+1].\nIntervals of the form ab) correspond to topological features that first appear in K_a and first disappear in K_b. The corresponding pairs (a,b) in dimension k are contained in the list phpairs[k+1].","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In our above example, one observes intervals 1infty) in dimensions zero and one  and these correspond to a connected component and the loop generated by the edges AB, AC, and BC. These appear first in K_1 and are still present in K_4. The interval 23) in dimension zero represents the new component created by K_2, and it disappears through merging with the older component from K_1 when the edge BD is introduced with K_3. Similarly, the interval 24) in dimension one is the loop created by the triangle DE, DF, and EF in K_2, which disappears with the introduction of the triangle DEF in K_4. Note that the interval death times respect the elder rule: When for example a component disappears through merging, the younger interval gets killed, and the older one continues to live. Similarly in higher dimensions.","category":"page"},{"location":"man/tutorial/#Forman-Vector-Fields","page":"Tutorial","title":"Forman Vector Fields","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The main focus of ConleyDynamics.jl is on the study of combinatorial topological dynamics on Lefschetz complexes. While the phase space as Lefschetz complex has been discussed above, albeit only for the special case of a simplicial complex, the dynamics part can be given in the simplest form by a combinatorial vector field, also called a Forman vector field [For98a, For98b]. We will soon see that such vector fields are a more restrictive version of multivector fields, but they are easier to start with.  The following command defines a simple Forman vector field on our sample simplicial complex K from above:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"formanvf = [[\"A\",\"AC\"],[\"B\",\"AB\"],[\"C\",\"BC\"],[\"D\",\"BD\"],[\"E\",\"DE\"]]","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The Forman vector field formanvf is viualized in the accompanying figure.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: A first Forman vector field)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"According to the figure, a Forman vector field is comprised of arrows, as well as critical cells which are indicated by red dots. Every simplex of the underlying simplicial complex is either critical, or it is contained in a unique arrow. In other words, the collection of critical cells and arrows forms a partition of the simplicial complex K. Arrows always have to consist of precisely two simplices: The source of the arrow is a simplex sigma^-, while its target is a second simplex sigma^+. These two simplices have to be related in the sense that sigma^- is a facet of sigma^+.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As the above Julia code shows, a forman vector field is described by a vector of string vectors, where each of the latter contains the labels of the two simplices making up an arrow. Note that the critical cells are not explicitly listed, as any simplex of K that is not part of a vector is automatically assumed to be critical. Alternatively, one could define the Forman vector field as a Vector{Vector{Int}}, if the labels are replaced by the corresponding indices in sc.indices.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Intuitively, the visualization of our sample Forman vector field formanvf induces the following dynamical behavior on the simplicial complex sc:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Critical cells can be though of as equilibrium states for the dynamics, i.e., they contain a stationary solution. However, depending on their dimension they can also exhibit nonconstant dynamics  which in backward time converges to the equilibrium, and in forward time flows towards the boundary of the simplex.\nArrow sources always lead to flow into the interior of their target simplex sigma^+.\nArrow targets create flow towards the boundary of sigma^+, except towards the source facet sigma^-.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In the above figure, for example, the simplex EF is a critical cell, so it contains an equilibrium. At the same time, it also allows for flow towards the boundary, which consists of the vertices E and F.  A solution flowing to the former then has to enter DE, flow through D to BD, before entering the periodic orbit given by","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"   B to AB to A to AC to C to BC to B to AB to ldots","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This heuristic description can be made precise. It was shown in [MW21] that for every Forman vector field on a simplicial complex there exists a classical dynamical system which exhibits dynamics consistent with the above interpretation.","category":"page"},{"location":"man/tutorial/#Isolated-Invariant-Sets","page":"Tutorial","title":"Isolated Invariant Sets","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The global dynamical behavior of a Forman vector field on a simplicial complex can be described by first decomposing it into smaller building blocks. An invariant set is a subset S subset K of the simplicial complex such that for every simplex sigma in S there exists a solution through sigma which is contained in S and which exists for all forward and backward time. In our example the following are sample invariant sets:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Every critical cell sigma by itself is an invariant set, since we can choose the constant solution sigma in the above definition. Thus, also every union of critical cells is invariant.\nThe periodic orbit S_P =  A B C AB AC BC  is an invariant set, since the periodic orbit mentioned earlier exists for all forward and backward time in S_P and passes through every simplex of the orbit.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"While it is tempting to try to decompose the dynamics into invariant sets and \"everything else\", Conley realized that a better theory can be built around invariant sets which are isolated [Con78]. In our combinatorial setting, an isolated invariant set is an invariant set S subset K with the following two additional properties:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The set S is locally closed, i.e., the associated set mathrmmo S = mathrmcl S setminus S is closed in the simplicial complex. Recall that the closure mathrmcl A of a set A subset K consists of all simplices which are subsets of simplices in A, and a set is closed if it equals its closure. The set mathrmmo S is called the mouth of S.\nThe set S is compatible with the Forman vector field, i.e., the set is the union of critical cells and arrows. In other words, if one of the  arrow ends is contained in S, then so is the other.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"One can easily see that the periodic orbit S_P is an isolated invariant set, since it is compatible and closed  and therefore mathrmmo S_P = emptyset is closed. Similarly, the single critical simplex S_1 =  DEF  is an isolated invariant set, since in this case the set mathrmmo S_1 =  D E F DE DF EF  is closed, and S_1 is compatible. On the other hand, the invariant set S_2 =  DEF F  is not an isolated invariant set, since the mouth mathrmmo S_2 =  D E DE DF EF  is not closed  despite the fact that S_2 is compatible.  For an example of an invariant set which has a closed mouth but is not compatible, see [KMW16, Figure 5].","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"It follows from the definition of isolation that for every isolated invariant set S subset K the two sets mathrmcl S and mathrmmo S are closed, and that the latter is a (possibly empty) subset of the former. Thus, the relative homology of this pair is defined and we let","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"  CH_*(S) = H_*(mathrmcl S mathrmmo S)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"denote the Conley index of the isolated invariant set. The Conley index can be computed using the command conley_index. For the three critical cells F, DF, and DEF one obtains the following Conley indices:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(conley_index(sc, [\"F\"]))\nprintln(conley_index(sc, [\"DF\"]))\nprintln(conley_index(sc, [\"DEF\"]))","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In other words, the Conley index of a critical cell of dimension k has Betti number beta_k = 1, while the remaining Betti numbers vanish. This is precisely the relative homology of a k-dimensional sphere with respect to a point on the sphere. On the other hand, for the Conley index of the periodic orbit S_P one obtains:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"conley_index(sc, [\"AB\", \"AC\", \"BC\", \"A\", \"B\", \"C\"])","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This Conley index is nontrivial in dimensions 0 and 1. This is exactly the Conley index of an attracting periodic orbit in classical dynamics.","category":"page"},{"location":"man/tutorial/#Connection-Matrices","page":"Tutorial","title":"Connection Matrices","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"One of the main features of ConleyDynamics.jl is its capability to take a given combinatorial vector or multivector field on an arbitrary Lefschetz complex and determine its global dynamical behavior. This is done by computing the connection matrix, which in our setting is discussed in detail in [MW23].  For the sample simplicial complex sc and the Forman vector field formanvf the connection matrix information can be determined as follows:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cm = connection_matrix(sc, formanvf)\nfieldnames(typeof(cm))","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This command calculates the connection matrix over the finite field GF(2) = mathbb Z_2. The base field for this computation is determined by the data type of the boundary matrix in the underlying simplicial complex sc. By default, if one uses the function create_simplicial_complex without specifying the field characteristic p, the simplicial complex is created over the finite field mathbbZ_2, i.e., with p=2.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The connection_matrix function returns a struct which contains the following information regarding the global dynamics of the combinatorial dynamical system:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The field cm.morse contains the Morse decomposition of the Forman vector field. This is a collection of isolated invariant sets which capture all recurrent behavior. Outside of these sets, the dynamics is gradient-like, i.e., it moves from one Morse set to another.\nSince each of the Morse sets is an isolated invariant set, they all have an associated Conley index. These are contained in the field cm.conley.\nIn addition, the struct cm contains information on the actual connection matrix in the field cm.matrix. While the field contains the matrix, the rows and columns of the connection matrix correspond to the simplices in the underlying simplicial complex sc listed in cm.labels. These simplices represent the basis for the homology groups of all the Morse sets. Moreover, a nonzero entry in the connection matrix indicates that there has to be a connecting orbit between the Morse set containing the column label and the Morse set containing the row label.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The remaining field names of the struct cm are described in the section on Conley Theory.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"For our example system, the Morse sets are given by","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cm.morse","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"There are five of them: The stable periodic orbit S_P mentioned earlier, the stable critical state F, the unstable equilibria DF and EF, as well as the two-dimensional unstable critical cell DEF.  The associated Conley indices are","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cm.conley","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Clearly these indices are exactly as described in the homology section, since the underlying field is still mathbbZ_2, as determined by sc. For an example which involves computations over different fields, which also lead to different Conley indices, we refer to the function example_moebius.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, the connection matrix itself is contained in cm.matrix. Since internally the connection matrix is stored in a sparse format, we display it after conversion to a full matrix:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"full_from_sparse(cm.matrix)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to see which simplices represent the columns of the matrix, we use the command","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"println(cm.labels)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The right-most column contains two nonzero entries, and they imply that there are connecting orbits between the critical cell DEF and the two critical cells DF and EF, respectively. The second-to-last column establishes connecting orbits originating from EF. One of these ends at the critical vertex F, while the other one leads to A. Notice, however, that since A is part of the Morse set S_P, i.e., the periodic orbit, this second nonzero entry in the column implies the existence of a heteroclinic orbit between the equilibrium and the complete periodic solution. Similarly, there are connections between DF and both F and the periodic orbit, in view of the fourth column of the connection matrix.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A description of the remaining fields of cm can also be found in the API entry for connection_matrix. We would like to emphasize again that internally, all computations necessary for finding the connection matrix are performed automatically over the rationals or over the finite field GF(p). The choice depends on the data type of the boundary matrix for the underlying Lefschetz complex, in this case the simplicial complex sc. ","category":"page"},{"location":"man/tutorial/#Multivector-Fields","page":"Tutorial","title":"Multivector Fields","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As second example of this tutorial we turn our attention to the logo of ConleyDynamics.jl. It shows a simple multivector field on a simplicial complex, and both the simplicial complex sclogo and the multivector field mvflogo can be defined using the commands","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"using ..ConleyDynamics # hide\nlabels = [\"A\",\"B\",\"C\",\"D\"]\nsimplices = [[\"A\",\"B\",\"C\"],[\"B\",\"C\",\"D\"]]\nsclogo = create_simplicial_complex(labels,simplices)\nmvflogo = [[\"A\",\"AB\"],[\"C\",\"AC\"],[\"B\",\"BC\",\"BD\",\"BCD\"]]","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This example is taken from [MW23, Figure 1], and is visualized in the accompanying figure.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: The logo multivector field)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The multivector field mvflogo clearly has a different structure from the earlier Forman vector field. While the latter consists exclusively of arrows and critical cells, the former is made up of multivectors. In this context a multivector is a collection of simplices which form a locally closed set, as defined earlier in the tutorial. One can show that in the case of a simplicial complex, this is equivalent to requiring that if sigma_1 subset sigma_2 are two simplices in the multivector, then so are all simplices tau with sigma_1 subset tau subset sigma_2.  In other words, multivectors are convex with respect to simplex inclusion,  i.e., with respect to the face relation.  A multivector field is then a partition of the simplicial complex into multivectors. See [LKMW23] for more details.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"It is not difficult to see that every Forman vector field is a multivector field. Every critical cell consists of just one simplex, so it trivially satisfies the above convexity condition. In addition, the two simplices contained in an arrow do not allow for any simplex sigma^- subset tau subset sigma^+ apart from tau = sigma^pm.  As in the case of Forman vector fields, multivector fields in ConleyDynamics.jl only need to list multivectors containing at least two simplices. Any simplex not contained on the list automatically gives rise to a one-element multivector.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"One important difference between Forman vector fields and multivector fields is the definition of criticality. In the multivector field case, the types of multivectors are distinguished as follows:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A multivector V is called critical, if the relative homology H_*(mathrmcl V mathrmmo V) is not trivial, i.e., at least one Betti number is nonzero.\nA multivector V is called regular, if the relative homology H_*(mathrmcl V mathrmmo V) is trivial, i.e., it vanishes in all dimensions.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"One can show that in the case of a Forman vector field, critical cells are always critical in the above sense, while arrows are always regular. In our above example mvflogo, all three multivectors which are not singletons are regular. For example, the following computation shows that the cell ABC is a critical cell:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cl1, mo1 = lefschetz_clomo_pair(sclogo, [\"ABC\"])\nrelative_homology(sclogo, cl1, mo1)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The first command creates the closure-mouth pair associated with the cell ABC, i.e., the variable cl1 is the closed triangle, while mo1 is the closed boundary of the triangle. The next  command determines the relative homology. Notice that this employs another method under the name relative_homology, in contrast to the one used earlier in this tutorial. For more details, see Homology Functions.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, since every multivector is locally closed, one can also use the function conley_index for the same computation:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"conley_index(sclogo, [\"ABC\"])","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, the next sequence of commands verifies that the third nontrivial multivector mvflogo[3] is indeed a regular multivector:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cl2, mo2 = lefschetz_clomo_pair(sclogo, mvflogo[3])\nrelative_homology(sclogo, cl2, mo2)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The global dynamics can again be determined using the function connection_matrix:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cmlogo = connection_matrix(sclogo, mvflogo)\ncmlogo.morse","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As it turns out, our logo gives rise to three Morse sets, which in fact partition the simplicial complex. Their Conley indices are given by","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cmlogo.conley","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, the connection matrix has the form","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"full_from_sparse(cmlogo.matrix)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice that in this example, only the connection between the Morse set ABC and the large index 1 Morse set comprising almost all  of the simplicial complex can be detected algebraically. In fact, there are two connections between the large Morse set and the stable equilibrium D, and they cancel algebraically.","category":"page"},{"location":"man/tutorial/#Analyzing-Planar-Vector-Fields","page":"Tutorial","title":"Analyzing Planar Vector Fields","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Our third and last example of the tutorial briefly indicates how ConleyDynamics.jl can be used to analyze the global dynamics of certain planar ordinary differential equations. For this, consider the planar system given by","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"   beginarrayrcl\n     dotx_1  =  x_1 left( 1 - x_1^2 - 3 x_2^2 right) 1ex\n     dotx_2  =  x_2 left( 1 - 3 x_1^2 - x_2^2 right)\n   endarray","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The right-hand side of this vector field can be implemented using the Julia function","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"using ..ConleyDynamics # hide\nusing Random # hide\nRandom.seed!(1234) # hide\nfunction planarvf(x::Vector{Float64})\n    #\n    # Sample planar vector field with nontrivial Morse decomposition\n    #\n    x1, x2 = x\n    y1 = x1 * (1.0 - x1*x1 - 3.0*x2*x2)\n    y2 = x2 * (1.0 - 3.0*x1*x1 - x2*x2)\n    return [y1, y2]\nend","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"To analyze the global dynamics of this vector field, we first create a Delaunay triangulation of the square -32 32^2 using the commands","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"lc, coords = create_simplicial_delaunay(300, 300, 10, 30);\ncoordsN = convert_planar_coordinates(coords,[-1.5,-1.5], [1.5,1.5]);\ncx = [c[1] for c in coordsN];\n(minimum(cx), maximum(cx))","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The first command generates the triangulation in a square box with  side length 300, while trying to keep a minimum distance of about 10 between vertices. Once this has been accomplished, the second  command transforms the coordinates to the desired square domain. As the last two commands show, the resulting x-coordinates do indeed lie between -3/2 and 3/2.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Next we can create a multivector field which describes the flow behavior through the edges of the triangulation. Basically, for each edge which is traversed in only one direction, the corresponding multivector respects this unidirectionality, while non-transverse edges lead to multivectors which allow for flow in both directions between the adjacent triangles. This is achieved with the commands","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"mvf = create_planar_mvf(lc, coordsN, planarvf);\nmvf[1:3]","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The first command generates the multivector field, while the second one merely displays the first three resulting multivectors. Note that if the discretization is too coarse, this might lead to large multivectors that cannot resolve the underlying dynamics. In our case, we can analyze the global dynamics of the created multivector field using the commands","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"cm = connection_matrix(lc, mvf);\ncm.conley","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As the output shows, this planar system has nine isolated invariant sets:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"One unstable equilibrium of index 2,\nfour unstable equilibria of index 1,\nand four stable equilibria.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"More precisely, this computation does not in fact establish the existence of these equilibria, but of corresponding isolated invariant sets which have the respective Conley indices. The connection matrix is given by","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"full_from_sparse(cm.matrix)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"It shows that there are twelve connecting orbits that are forced by the algebraic topology. Finally, we can visualize the Morse sets using the command","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"fname = \"tutorialplanar.pdf\"\nplot_planar_simplicial_morse(lc, coordsN, fname, cm.morse, pv=true)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Morse sets of a planar vector field)","category":"page"},{"location":"man/tutorial/#reftutorial","page":"Tutorial","title":"References","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"B.Batko, T.Kaczynski, M.Mrozek and T.Wanner. Linking combinatorial and classical dynamics: Conley             index and Morse decompositions. FoundationsofComputationalMathematics 20, 9671012 (2020).\n\n\n\nC.Conley. Isolated Invariant Sets and the Morse Index (American Mathematical Society, Providence, R.I., 1978).\n\n\n\nR.Forman. Combinatorial vector fields and dynamical systems. MathematischeZeitschrift 228, 629681 (1998).\n\n\n\nR.Forman. Morse theory for cell complexes. AdvancesinMathematics 134, 90145 (1998).\n\n\n\nT.Kaczynski, M.Mrozek and T.Wanner. Towards a formal tie between combinatorial and classical             vector field dynamics. JournalofComputationalDynamics 3, 1750 (2016).\n\n\n\nS.Lefschetz. Algebraic Topology. Vol. 27 of American Mathematical Society Colloquium Publications (American Mathematical Society, New York, 1942).\n\n\n\nM.Lipinski, J.Kubica, M.Mrozek and T.Wanner. Conley-Morse-Forman theory for generalized combinatorial             multivector fields on finite topological spaces. JournalofAppliedandComputationalTopology 7, 139184 (2023).\n\n\n\nM.Mrozek and T.Wanner. Creating semiflows on simplicial complexes from combinatorial vector fields. JournalofDifferentialEquations 304, 375434 (2021).\n\n\n\nM.Mrozek and T.Wanner. Connection matrices in combinatorial topological dynamics, arXiv:2103.04269 (2023).\n\n\n\n","category":"page"},{"location":"man/homology/#Homology","page":"Homology","title":"Homology","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Conley's theory for the qualitative study of dynamical systems is based on fundamental concepts from algebraic topology. One of these is homology, which studies the topological properties of spaces using algebraic means. As part of ConleyDynamics.jl a number of homology methods are included. It should be noted that these algorithms are not meant for truly large-scale problems, but mostly for illustrative purposes. They are based on the persistence algorithm described in [EH10], and have been extended to work for arbitrary Lefschetz complexes over either the rationals or a finite field of prime order. For more serious applications one could use professional implementations such as Gudhi, see [GUD24].","category":"page"},{"location":"man/homology/#Lefschetz-Complex-Homology","page":"Homology","title":"Lefschetz Complex Homology","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The most important notion of homology used in ConleyDynamics.jl is  Lefschetz homology. It generalizes both simplicial homology as  described in [Mun84], and cubical homology in the sense of [KMM04]. In order to fix our notation, we provide a brief introduction in the following. For more details, see [Lef42].","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"As we saw earlier, a Lefschetz complex X is a collection of cells which associated nonnegative dimensions, together with a boundary map partial which is induced by the incidence coefficient map kappa. The fundamental idea behind homology is to turn this underlying information into an algebraic form in such a way that the boundary map becomes a linear map. For this, define the k-th chain group as","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   C_k(X) = left sum_i=1^m alpha_i sigma_i   \n   alpha_1 ldots alpha_m in F text and \n   sigma_1 ldots sigma_m in X_k right ","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Since X_k denotes the collection of all cells of dimension k, this definition can be rephrased by saying that C_k(X) consists of all formal linear combinations of k-dimensional cells with coefficients in the underlying field F. It is not difficult to see that C_k(X) is in fact a vector space over F. Moreover, its dimension is equal to the number of k-dimensional cells in X. The collection of all chain groups is C(X) = (C_k(X))_k in mathbb Z, where we let C_k(X) =  0  for all k  0 and k  dim X.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"We now turn our attention to the boundary map. It was already explained how the incidence coefficient map kappa can be used to define a boundary partial sigma in C_k-1(X) for every k-dimensional cell sigma in X_k. If one further defines","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   partial left( sum_i=1^m alpha_i sigma_i right) =\n   sum_i=1^m alpha_i partialsigma_i in C_k-1(X)\n   quadtext for quad\n   sum_i=1^m alpha_i sigma_i in C_k(X)  ","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"then one obtains a map partial  C_k(X) to C_k-1(X). It is not  difficult to verify that this map is both well-defined and linear. Sometimes, we write partial_k instead of partial to emphasize that we consider the boundary map defined on the k-th chain group C_k(X).","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Altogether, the above definitions have equipped us with a sequence of vector spaces and maps between them in the form","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   ldots stackrelpartial_k+2longrightarrow\n   C_k+1(X) stackrelpartial_k+1longrightarrow\n   C_k(X) stackrelpartial_klongrightarrow\n   C_k-1(X) stackrelpartial_k-1longrightarrow ldots\n   stackrelpartial_1longrightarrow\n   C_0(X) stackrelpartial_0longrightarrow  0 \n   stackrelpartial_-1longrightarrow ldots ","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"and the properties of a Lefschetz complex further imply that","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   partial_k circ partial_k+1 = 0\n   quadtext for all quad\n   k in mathbb Z ","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In other words, the pair (C(X) partial) is a chain complex, which consists of a sequence of vector spaces over F and linear maps between them. Recall from linear algebra that any linear map induces two important subspaces, which in the context of algebraic topology are given special names as follows:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The elements of the subspace Z_k(X) = mathrmker partial_k are called the k-cycles of X.\nThe elements of the subspace B_k(X) = mathrmim partial_k+1 are called the k-boundaries of X.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Both of these vector spaces are subspaces of the k-th chain group C_k(X). Furthermore, in view of the above identity partial_k circ partial_k+1 = 0, one immediately obtains the subspace inclusion B_k(X) subset Z_k(X). We can therefore define the quotient space","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   H_k(X)  = \n   Z_k(X)  B_k(X)  = \n   mathrmkerpartial_k  mathrmimpartial_k+1 ","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This vector space is called the k-th homology group of the Lefschetz complex X. It is again a vector space over F, and therefore its dimension provides important information. In view of this, the dimension of the k-th homology group H_k(X) is called the k-th Betti number of X, and abbreviated as beta_k = dim H_k(X).","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In order to shed some light on the actual meaning of homology, and in particular the Betti numbers, we turn to an example. Consider the simplicial complex sc that was already introduced in the Tutorial, and which can be created using the commands","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"labels = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\nsimplices = [[\"A\",\"B\"],[\"A\",\"C\"],[\"B\",\"C\"],[\"B\",\"D\"],[\"D\",\"E\",\"F\"]]\nsc = create_simplicial_complex(labels,simplices)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This two-dimensional simplicial complex is shown in the figure.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"(Image: The simplicial complex from the tutorial)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"For simplicity, we consider the associated Lefschetz complex X over the field F = GF(2). Then chains in a chain group are just a sum of individual cells of the same dimension.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In this simple example, one can determine the cycles and boundaries for k=1 directly. The vector space Z_1(X) of 1-cycles contains the two nonzero chains c_1 = mathrmAB + mathrmBC + mathrmAC and c_2 = mathrmDE + mathrmEF + mathrmDF, since one can verify that partial c_1 = partial c_2 = 0. These are, however, not all nontrivial 1-cycles, as their sum c_1 + c_2 is another one. Thus, the first cycle group is given by Z_1(X) =  0 c_1 c_2 c_1 + c_2 . It is a vector space over F = GF(2) of dimension two, and any two nonzero elements of Z_1(X) form a basis. What about the 1-boundaries? The simplicial complex X contains only one 2-cell, namely mathrmDEF, and its boundary is given by the chain c_2. Thus, the first boundary group is given by B_1(X) =  0 c_2 , which is a one-dimensional vector space over F.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Combined, one can show that the first homology group H_1(X) consists of the two equivalence classes","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   H_1(X) = left B_1(X)   c_1 + B_1(X) right  ","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"where the class B_1(X) is the zero element in H_1(X). This implies that the first homology group is one-dimensional, and we have beta_1(X) = 1. In some sense, the basis element of H_1(X), which is the unique nonzero equivalence class given by c_1 + B_1(X), is represented by the cycle c_1.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The above mathematically precise description can be summarized as follows. All three cycles in Z_1(X) have the potential to enclose two-dimensional holes in the simplicial complex X, since they are chains without boundary. However, some of these potential holes have been filled in by two-dimensional cells. Thus, while c_1 does indeed represent a hole in X, the chain c_2 does not, since its interior is filled in by mathrmDEF. Note that the cycle c_1 + c_2 does not create a second hole, since we have (c_1 + c_2) - c_1 = c_2 in B_1(X). In other words, the first Betti number counts the number of independent holes in the complex X.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"One can extend this discussion also to other dimensions and to general Lefschetz complexes X. In this way, one obtains the following informal interpretations of the Betti numbers:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"beta_0(X) counts the number of connected components of X,\nbeta_1(X) counts the number of independent holes  in X,\nbeta_2(X) counts the number of independent cavities in X.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In general, one can show that beta_k(X) represents the number of independent (k+1)-dimensional holes in the Lefschetz complex X. For more details, see [Mun84].","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The package ConleyDynamics.jl provides one function to compute standard homology:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"homology expects one input argument, which has to be  of the Lefschetz complex type LefschetzComplex. It returns a vector betti of integers, whose length is one more than  the dimension of the complex. The k-th Betti number beta_k(X) is returned in betti[k+1].","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"We would like to point out that the field F is implicit in the data structure for the Lefschetz complex X, and therefore it does not have to be specified. It can always be queried using the function lefschetz_field. For the above example one obtains","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> homology(sc)\n3-element Vector{Int64}:\n 1\n 1\n 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This clearly gives the correct Betti numbers, as we have already seen that this simplicial complex has one hole, and it is obviously connected.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"(Image: Sample simplicial complex)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The simplicial complex shown in the second figure can be created using the commands","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"labels2 = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\"]\nsimplices2 = [[\"A\",\"B\"],[\"A\",\"F\"],[\"B\",\"F\"],[\"B\",\"C\",\"G\"],[\"D\",\"E\",\"H\"],[\"C\",\"D\"],[\"G\",\"H\"]]\nsc2 = create_simplicial_complex(labels2,simplices2)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"and its homology can then be determined as follows:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> homology(sc2)\n3-element Vector{Int64}:\n 1\n 2\n 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This complex is also connected, and therefore one has beta_0(X) = 1. However, this time one obtains two independent holes, which results in beta_1(X) = 2.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"(Image: Sample cubical complex)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Similarly, the cubical complex depicted in the next figure can be generated via","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"cubes = [\"00.11\", \"01.01\", \"02.10\", \"11.10\", \"11.01\", \"22.00\", \"20.11\", \"31.01\"]\ncc = create_cubical_complex(cubes)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"and its Betti numbers are given by","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> homology(cc)\n3-element Vector{Int64}:\n 2\n 1\n 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In  this case, the complex has two components and one hole. As a final example, consider a simplicial complex which consists of the manifold boundary of a  single cube. Such a complex can be generated using the commands","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"cc2,~ = create_cubical_box(1, 1, 1)\nmbcells = manifold_boundary(cc2)\ncc2bnd = lefschetz_subcomplex(cc2, mbcells)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This time, the homology of the resulting cubical complex is given by the Betti numbers","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> homology(cc2bnd)\n3-element Vector{Int64}:\n 1\n 0\n 1","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This complex is connected and has no holes, but it does have one cavity. As shown, these observations translate into the Betti numbers beta_0(X) = 1 and beta_1(X) = 0, as well as beta_2(X) = 1.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Beyond these simple illustrative examples, homology can be a useful tool in a variety of applied settings. For example, it can be used to quantify the evolution of material microstructures during phase separation processes, see for example [GMW05].","category":"page"},{"location":"man/homology/#Relative-Homology","page":"Homology","title":"Relative Homology","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"For the definition of the Conley index of an isolated invariant set another notion of homology is essential, namely relative homology. For this, we assume that X is a Lefschetz complex, and Y subset X is a closed subset. In other words, for every  cell in Y, all of its faces are contained in Y as well.  Then relative homology defines a sequence of groups H_k(XY) for k in mathbbZ which basically measures the topological properties of X if the subset Y is contracted to a point and then forgotten.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This admittedly very vague definition can be made precise in a number of ways. Two of these can easily be described:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"We have already seen that any locally closed subset of a Lefschetz complex is again a Lefschetz complex. Since the subset Y subset X is closed, its complement X setminus Y is open, and hence locally closed as well. Thus, the complement X setminus Y is again a Lefschetz complex. It has been shown in [MB09, Theorem 3.5] that then\n   H_k(XY) cong H_k(X setminus Y)\n   quadtext for all quad\n   k in mathbbZ \nIn other words, the relative homology of the pair (XY) is just the regular homology of the Lefschetz complex given by the set X setminus Y.\nOn a more topological level, one can also think of the relative homology of (XY) in the following way. In the complex X, identify all cells in Y to a single point, in the sense of the quotient space X  Y defined in a standard topology course. Then one can show that\n   H_k(XY) cong tildeH_k(X  Y)\n   quadtext for all quad\n   k in mathbbZ \nwhere tildeH_k(Z) denotes the reduced homology of a space Z. While the details of this latter notion of homology can be found in [Mun84, Section 7], for our purposes it suffices to note that the Betti numbers in reduced homology can be obtained from the one in regular homology by decreasing the 0-th Betti number by 1. All other Betti numbers remain unchanged.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The precise mathematical definition of relative homology can be found in [Mun84, Section 9], and it is briefly introduced in the following. Since the k-th chain group of a Lefschetz complex consists of all formal linear combinations of k-dimensional cells, one can consider the vector space C_k(Y) as a subspace of C_k(X). Thus, it makes sense to form the quotient groups","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   C_k(XY) = C_k(X)  C_k(Y)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"as in linear algebra. Moreover, if one considers a class x in C_k(XY) represented by some x in C_k(X), then the definition","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"   partial x = partial x in C_k-1(X Y)\n   quadtext for quad\n   x in C_k(X Y)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"gives a well-defined linear map partial  C_k(XY) to C_k-1(XY) which satisfies partial circ partial = 0. In other words, the collection (C_k(XY))_k in mathbbZ equipped with this boundary operator partial is a chain complex, and its associated homology groups H_k(XY) are called the relative homology groups of the pair (XY). Notice that by forming the quotient spaces C_k(X)  C_k(Y), the chains in the subspace are all identified and set to zero, as mentioned earlier.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In ConleyDynamics.jl, relative homology can be computed using relative_homology. There are two possible ways to invoke this function:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"The method relative_homology(lc::LefschetzComplex, subc::Cells) expects a Lefschetz complex lc which represents X, together with a list of cells subc. The closure of this cell list determines the closed subcomplex Y.\nThe method relative_homology(lc::LefschetzComplex, subc::Cells, subc0::Cells) expects some ambient Lefschetz complex specified by the argument lc. The Lefschetz complex X is then the closure of the cell list subc, while the subcomplex Y is given by the clourse of the cell list subc0. These closures are automatically computed by the function.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Both versions of relative_homology return the relative  homology as a vector betti of Betti numbers, where betti[k] is the Betti number in dimension k-1. Notice also that the necessary cell list arguments have to be variables of the type Cells = Union{Vector{Int},Vector{String}}, i.e., they can be given in either label or index form.","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"(Image: Sample simplicial complex)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In order to briefly illustrate the different usages of the command relative_homology, we consider again the simplicial complex shown in the figure, which can be generated using the commands","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"labels2 = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\"]\nsimplices2 = [[\"A\",\"B\"],[\"A\",\"F\"],[\"B\",\"F\"],[\"B\",\"C\",\"G\"],[\"D\",\"E\",\"H\"],[\"C\",\"D\"],[\"G\",\"H\"]]\nsc2 = create_simplicial_complex(labels2,simplices2)","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"If we identify the vertices mathrmA and mathrmE, then an additional loop is created along the bottom of the original simplicial complex. This leads to the following relative homology:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> relative_homology(sc2, [\"A\",\"E\"])\n3-element Vector{Int64}:\n 0\n 3\n 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Note that the 0-th Betti number becomes zero, since these identified vertices are considered as zero in the chain group C_0(XY). On the other hand, if we consider the boundary of the triangle mathrmDEH as the subcomplex Y, then one obtains:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> relative_homology(sc2, [\"DE\",\"DH\",\"EH\"])\n3-element Vector{Int64}:\n 0\n 2\n 1","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Again, the 0-th Betti number is reduced by one. But this time, the first Betti number does not change, as no new holes are created. Nevertheless, collapsing the boundary of the triangle to a point does create a cavity, and therefore the 2-nd Betti is now one. One can also just consider the closure of the triangle  mathrmBCG as a Lefschetz complex X, and use its boundary as subcomplex Y. In this case we get:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> relative_homology(sc2, [\"BCG\"], [\"BC\",\"BG\",\"CG\"])\n3-element Vector{Int64}:\n 0\n 0\n 1","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"This is the reduced homology of a two-dimensional sphere, which is the topological space obtained from the quotient space X  Y. As our final example, consider the closed edge mathrmAB as Lefschetz complex X, and the vertex mathrmB as subcomplex Y, then the relative homology of the pair (XY) is given by","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> relative_homology(sc2, [\"AB\"], [\"B\"])\n3-element Vector{Int64}:\n 0\n 0\n 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"In this case, all Betti numbers are zero. This can also be seen by recalling that this relative homology is isomorphic to the relative homology of the two-element Lefschetz complex which consists only of the edge mathrmAB and the vertex mathrmA:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"julia> homology(lefschetz_subcomplex(sc2, [\"A\",\"AB\"]))\n2-element Vector{Int64}:\n 0\n 0","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"Note that one obtains a Betti number vector of length two, since this subcomplex has dimension one.","category":"page"},{"location":"man/homology/#Persistent-Homology","page":"Homology","title":"Persistent Homology","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"[DW18] [EH10]","category":"page"},{"location":"man/homology/#refhomology","page":"Homology","title":"References","text":"","category":"section"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"See the full bibliography for a complete list of references cited throughout this documentation. This section cites the following references:","category":"page"},{"location":"man/homology/","page":"Homology","title":"Homology","text":"P.Dotko and T.Wanner. Rigorous cubical approximation and persistent homology of             continuous functions. Computers&MathematicswithApplications 75, 16481666 (2018).\n\n\n\nH.Edelsbrunner and J.L.Harer. Computational Topology (American Mathematical Society, Providence, 2010).\n\n\n\nM.Gameiro, K.Mischaikow and T.Wanner. Evolution of pattern complexity in the Cahn-Hilliard             theory of phase separation. ActaMaterialia 53, 693704 (2005).\n\n\n\nT.Kaczynski, K.Mischaikow and M.Mrozek. Computational Homology. Vol.157 of Applied Mathematical Sciences (Springer-Verlag, New York, 2004).\n\n\n\nS.Lefschetz. Algebraic Topology. Vol. 27 of American Mathematical Society Colloquium Publications (American Mathematical Society, New York, 1942).\n\n\n\nM.Mrozek and B.Batko. Coreduction homology algorithm. Discrete&ComputationalGeometry 41, 96118 (2009).\n\n\n\nJ.R.Munkres. Elements of Algebraic Topology (Addison-Wesley, Menlo Park, 1984).\n\n\n\nGUDHI Project. GUDHI User and Reference Manual. 3.10.1Edition (GUDHI Editorial Board, 2024).\n\n\n\n","category":"page"},{"location":"apicore/plots/#Plotting-Functions","page":"Plotting Functions","title":"Plotting Functions","text":"","category":"section"},{"location":"apicore/plots/#Visualizing-Simplicial-Complexes","page":"Plotting Functions","title":"Visualizing Simplicial Complexes","text":"","category":"section"},{"location":"apicore/plots/","page":"Plotting Functions","title":"Plotting Functions","text":"plot_planar_simplicial\nplot_planar_simplicial_morse","category":"page"},{"location":"apicore/plots/#ConleyDynamics.plot_planar_simplicial","page":"Plotting Functions","title":"ConleyDynamics.plot_planar_simplicial","text":"plot_planar_simplicial(sc::LefschetzComplex,\n                       coords::Vector{<:Vector{<:Real}},\n                       fname::String;\n                       [mvf::CellSubsets=Vector{Vector{Int}}([]),]\n                       [labeldir::Vector{<:Real}=Vector{Int}([]),]\n                       [labeldis::Real=8,]\n                       [hfac::Real=1.2,]\n                       [vfac::Real=1.2,]\n                       [sfac::Real=0,]\n                       [pdim::Vector{Bool}=[true,true,true],]\n                       [pv::Bool=false])\n\nCreate an image of a planar simplicial complex, and if specified, a Forman vector field on it.\n\nThe vector coords contains coordinates for every one of the vertices of the simplicial complex sc. The image will be saved in the file with name fname, and the ending determines the image type. Accepted are .pdf, .svg, .png, and .eps.\n\nIf the optional mvf is specified and is a Forman vector field, then this Forman vector field is drawn as well. The optional vector labeldir contains directions for the vertex labels, and labeldis the distance from the vertex. The directions have to be reals between 0 and 4, with 0,1,2,3 corresponding to E,N,W,S. The optional constants hfac and vfac contain the horizontal and vertical scale vectors, while sfac describes a uniform scale. If sfac=0 the latter is automatically determined. The vector pdim specifies in which dimensions cells are drawn; the default shows vertices, edges, and triangles. Finally if one passes the argument pv=true, then in addition to saving the file a preview is displayed.\n\nExamples\n\nSuppose we have created a simplicial complex using the commands\n\nsc, coords = create_simplicial_delaunay(300, 300, 30, 20)\nfname = \"sc_plot_test.pdf\"\n\nThen the following code creates an image of the simplicial complex without labels, but with a preview:\n\nplot_planar_simplicial(sc, coords, fname, pv=true)\n\nIf we want to see the labels, we can use\n\nldir = fill(0.5, sc.ncells);\nplot_planar_simplicial(sc, coords, fname, labeldir=ldir, labeldis=10, pv=true)\n\nThis command puts all labels in the North-East direction at a distance of 10.\n\n\n\n\n\n","category":"function"},{"location":"apicore/plots/#ConleyDynamics.plot_planar_simplicial_morse","page":"Plotting Functions","title":"ConleyDynamics.plot_planar_simplicial_morse","text":"plot_planar_simplicial_morse(sc::LefschetzComplex,\n                             coords::Vector{<:Vector{<:Real}},\n                             fname::String,\n                             morsesets::CellSubsets;\n                             [hfac::Real=1.2,]\n                             [vfac::Real=1.2,]\n                             [sfac::Real=0,]\n                             [pdim::Vector{Bool}=[false,true,true],]\n                             [pv::Bool=false])\n\nCreate an image of a planar simplicial complex, together with Morse sets, or also selected multivectors.\n\nThe vector coords contains coordinates for every one of the vertices of the simplicial complex sc. The image will be saved in the file with name fname, and the ending determines the image type. Accepted are .pdf, .svg, .png, and .eps.\n\nThe vector morsesets contains a list of Morse sets, or more general, subsets of the simplicial complex. For every k, the set described by morsesets[k] will be shown in a distinct color.\n\nThe optional constants hfac and vfac contain the horizontal and vertical scale vectors for the margins, while sfac describes a uniform scale. If sfac=0 the latter is automatically determined. The vector pdim specifies in which dimensions cells are drawn; the default only shows edges and triangles. Finally if one passes the argument pv=true, then in addition to saving the file a preview is displayed.\n\n\n\n\n\n","category":"function"},{"location":"apicore/plots/#Visualizing-Cubical-Complexes","page":"Plotting Functions","title":"Visualizing Cubical Complexes","text":"","category":"section"},{"location":"apicore/plots/","page":"Plotting Functions","title":"Plotting Functions","text":"plot_planar_cubical\nplot_planar_cubical_morse","category":"page"},{"location":"apicore/plots/#ConleyDynamics.plot_planar_cubical","page":"Plotting Functions","title":"ConleyDynamics.plot_planar_cubical","text":"plot_planar_cubical(cc::LefschetzComplex,\n                    coords::Vector{<:Vector{<:Real}},\n                    fname::String;\n                    [hfac::Real=1.2,]\n                    [vfac::Real=1.2,]\n                    [cubefac::Real=0,]\n                    [pdim::Vector{Bool}=[true,true,true],]\n                    [pv::Bool=false])\n\nCreate an image of a planar cubical complex.\n\nThe vector coords contains coordinates for every one of the vertices of the cubical complex cc. The image will be saved in the file with name fname, and the ending determines the image type. Accepted are .pdf, .svg, .png, and .eps. The optional constants hfac and vfac contain the horizontal and vertical scale vectors. The optional argument cubefac specifies the side length of an elementary cube for plotting, and it will be automatically determined otherwise. The vector pdim specifies which cell dimensions should be plotted, with pdim[k] representing dimension k-1. Finally if one passes the argument pv=true, then in addition to saving the file a preview is displayed.\n\nExamples\n\nSuppose we have created a cubical complex using the commands\n\ncubes = [\"00.11\", \"01.01\", \"02.10\", \"11.10\", \"11.01\", \"22.00\"]\ncoords = [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,1],[2,2]]\ncc = create_cubical_complex(cubes)\nfname = \"cc_plot_test.pdf\"\n\nThen the following code creates an image of the simplicial complex without labels, but with a preview:\n\nplot_planar_cubical(cc, coords, fname, pv=true)\n\nIf one only wants to plot the edges in the complex, but not the vertices or rectangles, then one can use:\n\nplot_planar_cubical(cc, coords, fname, pv=true, pdim=[false,true,false])\n\n\n\n\n\nplot_planar_cubical(cc::LefschetzComplex,\n                    fname::String;\n                    [hfac::Real=1.2,]\n                    [vfac::Real=1.2,]\n                    [cubefac::Real=0,]\n                    [pdim::Vector{Bool}=[true,true,true],]\n                    [pv::Bool=false])\n\nCreate an image of a planar cubical complex.\n\nThis is an alternative method which does not require the specification of the vertex coordinates. They will be taken from the cube vertex labels.\n\n\n\n\n\n","category":"function"},{"location":"apicore/plots/#ConleyDynamics.plot_planar_cubical_morse","page":"Plotting Functions","title":"ConleyDynamics.plot_planar_cubical_morse","text":"plot_planar_cubical_morse(cc::LefschetzComplex,\n                          coords::Vector{<:Vector{<:Real}},\n                          fname::String,\n                          morsesets::CellSubsets;\n                          [hfac::Real=1.2,]\n                          [vfac::Real=1.2,]\n                          [cubefac::Real=0,]\n                          [pdim::Vector{Bool}=[false,true,true],]\n                          [pv::Bool=false])\n\nCreate an image of a planar cubical complex, together with Morse sets, or also selected multivectors.\n\nThe vector coords contains coordinates for every one of the vertices of the cubical complex cc. The image will be saved in the file with name fname, and the ending determines the image type. Accepted are .pdf, .svg, .png, and .eps.\n\nThe vector morsesets contains a list of Morse sets, or more general, subsets of the cubical complex. For every k, the set described by morsesets[k] will be shown in a distinct color.\n\nThe optional constants hfac and vfac contain the horizontal and vertical scale vectors for the margins, while cubefac describes a uniform scale. If cubefac=0 the latter is automatically determined. The vector pdim specifies in which dimensions cells are drawn; the default only shows edges and squares. Finally if one passes the argument pv=true, then in addition to saving the file a preview is displayed.\n\n\n\n\n\nplot_planar_cubical_morse(cc::LefschetzComplex,\n                          fname::String,\n                          morsesets::CellSubsets;\n                          [hfac::Real=1.2,]\n                          [vfac::Real=1.2,]\n                          [cubefac::Real=0,]\n                          [pdim::Vector{Bool}=[false,true,true],]\n                          [pv::Bool=false])\n\nCreate an image of a planar cubical complex, together with Morse sets, or also selected multivectors.\n\nThis is an alternative method which does not require the specification of the vertex coordinates. They will be taken from the cube vertex labels.\n\n\n\n\n\n","category":"function"},{"location":"man/sparse/#Sparse-Matrices","page":"Sparse Matrices","title":"Sparse Matrices","text":"","category":"section"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"While Julia provides a data structure for sparse matrix computations, the employed design decisions make it difficult to use this implementation for computations over finite fields. This is mainly due to the fact that in the Julia implementation, it is assumed that one can determine the zero and one elements from the data type alone. However, a finite field data type and especially the ones implemented in the package Nemo, generally also depends on additional parameters, such as the characteristic of the field.","category":"page"},{"location":"man/sparse/","page":"Sparse Matrices","title":"Sparse Matrices","text":"Since the algorithms underlying ConleyDynamics.jl only require basic row and column operations, we decided to include a specialized sparse matrix implementation.","category":"page"},{"location":"man/sparse/#Sparse-Matrix-Format","page":"Sparse Matrices","title":"Sparse Matrix Format","text":"","category":"section"},{"location":"apicore/conley/#Conley-Theory-Functions","page":"Conley Theory Functions","title":"Conley Theory Functions","text":"","category":"section"},{"location":"apicore/conley/#Multivector-Fields","page":"Conley Theory Functions","title":"Multivector Fields","text":"","category":"section"},{"location":"apicore/conley/","page":"Conley Theory Functions","title":"Conley Theory Functions","text":"create_mvf_hull\ncreate_planar_mvf\ncreate_spatial_mvf\nextract_multivectors\nplanar_nontransverse_edges","category":"page"},{"location":"apicore/conley/#ConleyDynamics.create_mvf_hull","page":"Conley Theory Functions","title":"ConleyDynamics.create_mvf_hull","text":"create_mvf_hull(lc::LefschetzComplex, mvfbase::Vector{Vector{Int}})\n\nCreate the smallest multivector field containing the given sets.\n\nThe resulting multivector field has the property that every set of the form mvfbase[k] is contained in a minimal multivector. Notice that these sets do not have to be disjoint, and that not even their locally closed hulls have to be disjoint. In the latter case, this leads to two such sets having to be contained in the same multivector. If the sets in mvfbase are poorly chosen, one might end up with extremely large multivectors due to the above potential merging of locally closed hulls.\n\n\n\n\n\ncreate_mvf_hull(lc::LefschetzComplex, mvfbase::Vector{Vector{String}})\n\nCreate the smallest multivector field containing the given sets.\n\nThe resulting multivector field has the property that every set of the form mvfbase[k] is contained in a minimal multivector. Notice that these sets do not have to be disjoint, and that not even their locally closed hulls have to be disjoint. In the latter case, this leads to two such sets having to be contained in the same multivector. If the sets in mvfbase are poorly chosen, one might end up with extremely large multivectors due to the above potential merging of locally closed hulls.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.create_planar_mvf","page":"Conley Theory Functions","title":"ConleyDynamics.create_planar_mvf","text":"create_planar_mvf(lc::LefschetzComplex, coords::Vector{Vector{Float64}}, vf)\n\nCreate a planar multivector field from a regular vector field.\n\nThe function expects a planar Lefschetz complex lc and a coordinate vector coords of coordinates for all the 0-dimensional cells in the complex. Moreover, the underlying vector field is specified by the function vf(z::Vector{Float64})::Vector{Float64}, where both the input and output vectors have length two. The function create_planar_mvf returns a multivector field mvf on lc, which can then be further analyzed using for example the function connection_matrix.\n\nThe input data lc and coords can be generated using one of the following methods:\n\ncreate_cubical_rectangle\ncreate_simplicial_rectangle\ncreate_simplicial_delaunay\n\nIn each case, the provided coordinate vector can be transformed to the correct bounding box using convert_planar_coordinates.\n\nExample 1\n\nSuppose we define a sample vector field using the commands\n\nfunction samplevf(x::Vector{Float64})\n    #\n    # Sample vector field with nontrivial Morse decomposition\n    #\n    x1, x2 = x\n    y1 = x1 * (1.0 - x1*x1 - 3.0*x2*x2)\n    y2 = x2 * (1.0 - 3.0*x1*x1 - x2*x2)\n    return [y1, y2]\nend\n\nOne first creates a triangulation of the enclosing box, which in this case is given by [-2,2] x [-2,2] using the commands\n\nn = 21\nlc, coords = create_simplicial_rectangle(n,n);\ncoordsN = convert_planar_coordinates(coords,[-2.0,-2.0],[2.0,2.0]);\n\nThe multivector field is then generated using\n\nmvf = create_planar_mvf(lc,coordsN,samplevf);\n\nand the commands\n\ncm = connection_matrix(lc, mvf);\ncm.conley\nfull_from_sparse(cm.matrix)\n\nfinally show that this vector field gives rise to a Morse decomposition with nine Morse sets, and twelve connecting orbits. Using the commands\n\nfname = \"morse_test.pdf\"\nplot_planar_simplicial_morse(lc, coordsN, fname, cm.morse, pv=true)\n\nthese Morse sets can be visualized. The image will be saved in fname.\n\nExample 2\n\nAn example with periodic orbits can be generated using the vector field\n\nfunction samplevf2(x::Vector{Float64})\n    #\n    # Sample vector field with nontrivial Morse decomposition\n    #\n    x1, x2 = x\n    c0 = x1*x1 + x2*x2\n    c1 = (c0 - 4.0) * (c0 - 1.0)\n    y1 = -x2 + x1 * c1\n    y2 =  x1 + x2 * c1\n    return [-y1, -y2]\nend\n\nThe Morse decomposition can now be computed via\n\nn2 = 51\nlc2, coords2 = create_cubical_rectangle(n2,n2);\ncoords2N = convert_planar_coordinates(coords2,[-4.0,-4.0],[4.0,4.0]);\nmvf2 = create_planar_mvf(lc2,coords2N,samplevf2);\ncm2 = connection_matrix(lc2, mvf2);\ncm2.conley\ncm2.poset\nfull_from_sparse(cm2.matrix)\n\nfname2 = \"morse_test2.pdf\"\nplot_planar_cubical_morse(lc2, fname2, cm2.morse, pv=true)\n\nIn this case, one obtains three Morse sets: One is a stable equilibrium, one is an unstable periodic orbit, and the last is a stable periodic orbit.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.create_spatial_mvf","page":"Conley Theory Functions","title":"ConleyDynamics.create_spatial_mvf","text":"create_spatial_mvf(lc::LefschetzComplex, coords::Vector{Vector{Float64}}, vf)\n\nCreate a spatial multivector field from a regular vector field.\n\nThe function expects a three-dimensional Lefschetz complex lc and a coordinate vector coords of coordinates for all the 0-dimensional cells in the complex. Moreover, the underlying vector field is specified by the function vf(z::Vector{Float64})::Vector{Float64}, where both the input and output vectors have length three. The function create_spatial_mvf returns a multivector field mvf on lc, which can then be further analyzed using for example the function connection_matrix.\n\nThe input data lc and coords has to be of one of the following two types:\n\nlc is a tetrahedral mesh of a region in three dimensions. In other words, the underlying Lefschetz complex is in fact a simplicial  complex, and the vector coords contains the vertex coordinates.\nlc is a three-dimensional cubical complex, i.e., it is the closure of a collection of three-dimensional cubes in space. The vertex coordinates can be slight;y perturbed from the original position in the cubical lattice, as long as the overall structure  of the complex stays intact. In that case, the faces are interpreted as Bezier surfaces with straight edges.\n\nExample 1\n\nSuppose we define a sample vector field using the commands\n\nfunction samplevf(x::Vector{Float64})\n    #\n    # Sample vector field with nontrivial Morse decomposition\n    #\n    x1, x2, x3 = x\n    y1 = x1 * (1.0 - x1*x1)\n    y2 = -x2\n    y3 = -x3\n    return [y1, y2, y3]\nend\n\nOne first creates a cubical complex covering the interesting dynamics, say the trapping region [-1.5,1.5] x [-1,1] x [-1,1], using the commands\n\nlc, coords = create_cubical_box(3,3,3);\ncoordsN = convert_spatial_coordinates(coords,[-1.5,-1.0,-1.0],[1.5,1.0,1.0]);\n\nThe multivector field is then generated using\n\nmvf = create_spatial_mvf(lc,coordsN,samplevf);\n\nand the commands\n\ncm = connection_matrix(lc, mvf);\ncm.conley\nfull_from_sparse(cm.matrix)\n\nfinally show that this vector field gives rise to a Morse decomposition with three Morse sets, and two connecting orbits.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.extract_multivectors","page":"Conley Theory Functions","title":"ConleyDynamics.extract_multivectors","text":"extract_multivectors(lc::LefschetzComplex, mvf::Vector{Vector{Int}},\n                     scells::Vector{Int})\n\nExtract all multivectors containing a provided selection of cells.\n\nThe function returns all multivectors which contain at least one of the cells in the input vector scells. The return argument has type Vector{Vector{Int}}.\n\n\n\n\n\nextract_multivectors(lc::LefschetzComplex, mvf::Vector{Vector{String}},\n                     scells::Vector{String})\n\nExtract all multivectors containing a provided selection of cells.\n\nThe function returns all multivectors which contain at least one of the cells in the input vector scells. The return argument has type Vector{Vector{String}}.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.planar_nontransverse_edges","page":"Conley Theory Functions","title":"ConleyDynamics.planar_nontransverse_edges","text":"planar_nontransverse_edges(lc::LefschetzComplex, coords::Vector{Vector{Float64}}, vf;\n                           npts::Int=100)\n\nFind all edges of a planar Lefschetz complex which are not flow transverse.\n\nThe Lefschetz complex is given in lc, the coordinates of all vertices of the complex in coords, and the vector field is specified in vf. The optional parameter npts determines how many points along an edge are evaluated for the transversality check. The function returns a list of nontransverse edges as Vector{Int}, which contains the edge indices.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#Conley-Index-Computations","page":"Conley Theory Functions","title":"Conley Index Computations","text":"","category":"section"},{"location":"apicore/conley/","page":"Conley Theory Functions","title":"Conley Theory Functions","text":"conley_index\nmorse_sets\nmorse_interval\nrestrict_dynamics\nremove_exit_set","category":"page"},{"location":"apicore/conley/#ConleyDynamics.conley_index","page":"Conley Theory Functions","title":"ConleyDynamics.conley_index","text":"conley_index(lc::LefschetzComplex, subcomp::Vector{String})\n\nDetermine the Conley index of a Lefschetz complex subset.\n\nThe function raises an error if the subset subcomp is not locally closed. The computations are performed over the field associated with the Lefschetz complex boundary matrix.\n\n\n\n\n\nconley_index(lc::LefschetzComplex, subcomp::Vector{Int})\n\nDetermine the Conley index of a Lefschetz complex subset.\n\nThe function raises an error if the subset subcomp is not locally closed. The computations are performed over the field associated with the Lefschetz complex boundary matrix.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.morse_sets","page":"Conley Theory Functions","title":"ConleyDynamics.morse_sets","text":"morse_sets(lc::LefschetzComplex, mvf::CellSubsets; poset::Bool=false)\n\nFind the nontrivial Morse sets of a multivector field on a Lefschetz complex.\n\nThe input argument lc contains the Lefschetz complex, and mvf describes the multivector field. The function returns the nontrivial Morse sets as a Vector{Vector{Int}}. If the optional argument poset=true is added, then the function returns both the Morse sets and the adjacency matrix of the Hasse diagram of the underlying poset.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.morse_interval","page":"Conley Theory Functions","title":"ConleyDynamics.morse_interval","text":"morse_interval(lc::LefschetzComplex, mvf::CellSubsets,\n               ms::CellSubsets)\n\nFind the isolated invariant set for a Morse set interval.\n\nThe input argument lc contains the Lefschetz complex, and mvf describes the multivector field. The collection of Morse sets are contained inms. All of these sets should be Morse sets in the sense of being strongly connected components of the flow graph. (Nevertheless, this will be enforced in the function!) In other words, the sets in ms should be determined using the function morse_sets!\n\nThe function returns the smallest isolated invariant set which contains the Morse sets and their connections as a Vector{Int}.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.restrict_dynamics","page":"Conley Theory Functions","title":"ConleyDynamics.restrict_dynamics","text":"restrict_dynamics(lc::LefschetzComplex, mvf::CellSubsets, lcsub::Cells)\n\nRestrict a multivector field to a Lefschetz subcomplex.\n\nFor a given multivector field mvf on a Lefschetz complex lc, and a subcomplex which is given by the locally closed set represented by lcsub, create the associated Lefschetz subcomplex lcreduced and the induced multivector field mvfreduced on the subcomplex. The multivectors of the new multivector field are the intersections of the original multivectors and the subcomplex.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.remove_exit_set","page":"Conley Theory Functions","title":"ConleyDynamics.remove_exit_set","text":"remove_exit_set(lc::LefschetzComplex, mvf::CellSubsets)\n\nExit set removal for a multivector field on a Lefschetz subcomplex.\n\nIt is assumed that the Lefschetz complex lc is a topological manifold and that mvf contains a multivector field that is created via either create_planar_mvf or create_spatial_mvf. The function identifies cells on the boundary at which the flows exits the region covered by the Lefschetz complex. If this exit set is closed, we have found an  isolated invariant set and the function returns a Lefschetz complex lcr restricted to it, as well as the restricted multivector field mvfr. If the exit set is not closed, a warning is displayed and the function returns the restricted Lefschetz complex and multivector field obtained by removing the closure of the exit set. In the latter case, unexpected results might be obtained.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#Connection-Matrix-Computation","page":"Conley Theory Functions","title":"Connection Matrix Computation","text":"","category":"section"},{"location":"apicore/conley/","page":"Conley Theory Functions","title":"Conley Theory Functions","text":"connection_matrix\ncm_reduce!","category":"page"},{"location":"apicore/conley/#ConleyDynamics.connection_matrix","page":"Conley Theory Functions","title":"ConleyDynamics.connection_matrix","text":"connection_matrix(lc::LefschetzComplex, mvf::CellSubsets;\n                  [returnbasis::Bool])\n\nCompute a connection matrix for the multivector field mvf on the Lefschetz complex lc over the field associated with the Lefschetz complex boundary matrix.\n\nThe function returns an object of type ConleyMorseCM. If the optional argument returnbasis::Bool=true is given, then the function also returns a dictionary which gives the basis for the connection matrix columns in terms of the original labels.\n\n\n\n\n\n","category":"function"},{"location":"apicore/conley/#ConleyDynamics.cm_reduce!","page":"Conley Theory Functions","title":"ConleyDynamics.cm_reduce!","text":"cm_reduce!(matrix::SparseMatrix, psetvec::Vector{Int};\n           [returnbasis::Bool],[returntm::Bool])\n\nCompute the connection matrix.\n\nAssumes that matrix is upper triangular and filtered according to psetvec. Modifies the argument matrix.\n\nReturn values:\n\ncmatrix: Connection matrix\ncmatrix_cols: Columns of the connection matrix in the boundary\nbasisvecs (optional): If the argument returnbasis=true is given, this returns information about the computed basis. The k-th entry of basisvecs is a vector containing the columns making up the k-th basis vector, which corresponds to column cmatrix_cols[k].\ntmatrix (optional): If the argument returntm=true is given in addition to returnbasis=true, then instead of basisvecs the function returns the complete transformation matrix. In this case, basicvecs is not returned.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#Sparse-Matrix-Functions","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"","category":"section"},{"location":"apicore/sparse/#Internal-Sparse-Matrix-Representation","page":"Sparse Matrix Functions","title":"Internal Sparse Matrix Representation","text":"","category":"section"},{"location":"apicore/sparse/","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"SparseMatrix","category":"page"},{"location":"apicore/sparse/#ConleyDynamics.SparseMatrix","page":"Sparse Matrix Functions","title":"ConleyDynamics.SparseMatrix","text":"SparseMatrix{T}\n\nComposite data type for a sparse matrix with entries of type T.\n\nThe struct has the following fields:\n\nconst nrow::Int: Number of rows\nconst ncol::Int: Number of columns\nconst char::Int: Characteristic of type T\nconst zero::T: Number 0 of type T\nconst one::T:  Number 1 of type T\nentries::Vector{Vector{T}}: Matrix entries corresponding to columns\ncolumns::Vector{Vector{Int}}: column[k] points to nonzero entries in column k\nrows::Vector{Vector{Int}}: rows[k] points to nonzero entries in the k-th row\n\n\n\n\n\n","category":"type"},{"location":"apicore/sparse/#Access-Functions","page":"Sparse Matrix Functions","title":"Access Functions","text":"","category":"section"},{"location":"apicore/sparse/","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"sparse_get_entry\nBase.getindex(matrix::SparseMatrix, ri::Int, ci::Int)\nsparse_set_entry!\nBase.setindex!(matrix::SparseMatrix, val, ri::Int, ci::Int)\nsparse_get_column\nsparse_get_nz_column\nsparse_minor","category":"page"},{"location":"apicore/sparse/#ConleyDynamics.sparse_get_entry","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_get_entry","text":"sparse_get_entry(matrix::SparseMatrix, ri::Int, ci::Int)\n\nGet the sparse matrix entry at location (ri,ci).\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#Base.getindex-Tuple{SparseMatrix, Int64, Int64}","page":"Sparse Matrix Functions","title":"Base.getindex","text":"Base.getindex(matrix::SparseMatrix, ri::Int, ci::Int)\n\nGet the sparse matrix entry at location (ri,ci).\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_set_entry!","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_set_entry!","text":"sparse_set_entry!(matrix::SparseMatrix, ri::Int, ci::Int, val)\n\nSet the sparse matrix entry at location (ri,ci) to val.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#Base.setindex!-Tuple{SparseMatrix, Any, Int64, Int64}","page":"Sparse Matrix Functions","title":"Base.setindex!","text":"Base.setindex!(matrix::SparseMatrix, val, ri::Int, ci::Int)\n\nSet the sparse matrix entry at location (ri,ci) to val.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#ConleyDynamics.sparse_get_column","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_get_column","text":"sparse_get_column(matrix::SparseMatrix, ci::Int)\n\nGet the ci-th column of the sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_get_nz_column","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_get_nz_column","text":"sparse_get_nz_column(matrix::SparseMatrix, ci::Int)\n\nGet the row indices for the nonzero entries in the ci-th column of the sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_minor","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_minor","text":"smp = sparse_minor(sm::SparseMatrix, rvec::Vector{Int}, cvec::Vector{Int})\n\nCreate sparse submatrix by specifying the desired row and column indices.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#Basic-Functions","page":"Sparse Matrix Functions","title":"Basic Functions","text":"","category":"section"},{"location":"apicore/sparse/","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"sparse_size\nsparse_low\nsparse_is_sut\nsparse_identity\nsparse_fullness\nsparse_sparsity\nsparse_show","category":"page"},{"location":"apicore/sparse/#ConleyDynamics.sparse_size","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_size","text":"sparse_size(matrix::SparseMatrix, dim::Int)\n\nNumber of rows (dim=1) or columns (dim=2) of a sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_low","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_low","text":"sparse_low(matrix::SparseMatrix, col::Int)\n\nRow index of the lowest nonzero matrix entry in column col.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_is_sut","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_is_sut","text":"bool = sparse_is_sut(sm::SparseMatrix)\n\nCheck whether the sparse matrix is strictly upper triangular.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_identity","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_identity","text":"sparse_identity(n::Int; p::Int=0)\n\nCreate a sparse identity matrix with n rows and columns.\n\nThe optional argument p specifies the field characteristic. If p=0 then the sparse matrix is over the rationals, while if p>0 is a prime, then the matrix is an integer matrix  whose entries are interpreted in GF(p).\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_fullness","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_fullness","text":"sparse_fullness(sm::SparseMatrix)\n\nDisplay the fullness of the sparse matrix sm.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_sparsity","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_sparsity","text":"sparse_sparsity(sm::SparseMatrix)\n\nDisplay the sparsity of the sparse matrix sm.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_show","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_show","text":"sparse_show(sm::SparseMatrix)\n\nDisplay the sparse matrix sm.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#Elementary-Matrix-Operations","page":"Sparse Matrix Functions","title":"Elementary Matrix Operations","text":"","category":"section"},{"location":"apicore/sparse/","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"sparse_add_column!\nsparse_add_row!\nsparse_permute\nsparse_remove!\nsparse_multiply\nBase.:*(::SparseMatrix,::SparseMatrix)","category":"page"},{"location":"apicore/sparse/#ConleyDynamics.sparse_add_column!","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_add_column!","text":"sparse_add_column!(matrix::SparseMatrix, ci1::Int, ci2::Int, cn, cd)\n\nReplace column[ci1] by column[ci1] + (cn/cd) * column[ci2].\n\n\n\n\n\nsparse_add_column!(matrix::SparseMatrix{Int}, ci1::Int, ci2::Int,\n                   cn::Int, cd::Int)\n\nReplace column[ci1] by column[ci1] + (cn/cd) * column[ci2].\n\nThe computation is performed mod p, where the characteristic is taken from matrix.char. An error is thrown if matrix.char==0.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_add_row!","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_add_row!","text":"sparse_add_row!(matrix::SparseMatrix, ri1::Int, ri2::Int, cn, cd)\n\nReplace row[ri1] by row[ri1] + (cn/cd) * row[ri2].\n\n\n\n\n\nsparse_add_row!(matrix::SparseMatrix{Int}, ri1::Int, ri2::Int,\n                cn::Int, cd::Int)\n\nReplace row[ri1] by row[ri1] + (cn/cd) * row[ri2].\n\nThe computation is performed mod p, where the characteristic is taken from matrix.char. An error is thrown if matrix.char==0.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_permute","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_permute","text":"sparse_permute(sm::SparseMatrix, pr::Vector{Int}, pc::Vector{Int})\n\nCreate sparse matrix by permuting the row and column indices.\n\nThe vector pr describes the row permutation, and pc the column permutation.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_remove!","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_remove!","text":"sparse_remove!(matrix::SparseMatrix, ri::Int, ci::Int)\n\nRemove the sparse matrix entry at location (ri,ci).\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_multiply","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_multiply","text":"sparse_multiply(A::SparseMatrix, B::SparseMatrix)\n\nMultiply two sparse matrices.\n\nExceptions are raised if the matrix product is not defined  or the entry types do not match.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#Base.:*-Tuple{SparseMatrix, SparseMatrix}","page":"Sparse Matrix Functions","title":"Base.:*","text":"Base.:*(A::SparseMatrix, B::SparseMatrix)\n\nMultiply two sparse matrices.\n\nExceptions are raised if the matrix product is not defined  or the entry types do not match.\n\n\n\n\n\n","category":"method"},{"location":"apicore/sparse/#Conversion-Functions","page":"Sparse Matrix Functions","title":"Conversion Functions","text":"","category":"section"},{"location":"apicore/sparse/","page":"Sparse Matrix Functions","title":"Sparse Matrix Functions","text":"sparse_from_full\nfull_from_sparse\nsparse_from_lists\nlists_from_sparse","category":"page"},{"location":"apicore/sparse/#ConleyDynamics.sparse_from_full","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_from_full","text":"sparse_from_full(matrix::Matrix{Int}; [p::Int=0])\n\nCreate sparse matrix from full integer matrix. If the optional argument p is specified and positive, then the returned matrix is an integer matrix which is interpreted over GF(p). On the other hand, if p is omitted or equal to zero, then the return matrix has rational type.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.full_from_sparse","page":"Sparse Matrix Functions","title":"ConleyDynamics.full_from_sparse","text":"full_from_sparse(sm::SparseMatrix)\n\nCreate full matrix from sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.sparse_from_lists","page":"Sparse Matrix Functions","title":"ConleyDynamics.sparse_from_lists","text":"sparse_from_lists(nr, nc, tchar, tzero, tone, r, c, v)\n\nCreate sparse matrix from lists describing the entries.\n\nThe vectors r, c, and v have to have the same length and the matric has entry v[k] at (r[k],c[k]). Zero entries will be ignored, and multiple entries for the same matrix position raise an error.\n\nThe input arguments have the following meaning:\n\nnr::Int: Number of rows\nnc::Int: Number of columns\ntchar: Field characteristic if T==Int\ntzero::T: Number 0 of type T\ntone::T:  Number 1 of type T\nr::Vector{Int}: Vector of row indices\nc::Vector{Int}: Vector of column indices\nv::Vector{T}: Vector of matrix entries\n\nIf tchar>0, then the entries in v are all replaced by their values mod tchar.\n\n\n\n\n\n","category":"function"},{"location":"apicore/sparse/#ConleyDynamics.lists_from_sparse","page":"Sparse Matrix Functions","title":"ConleyDynamics.lists_from_sparse","text":"nr, nc, tchar, tzero, tone, r, c, v = lists_from_sparse(sm::SparseMatrix)\n\nCreate list representation from sparse matrix.\n\nThe output variables are exactly what is needed to create a sparse matrix object using sparse_from_lists.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Lefschetz-Complex-Functions","page":"Lefschetz Complex Functions","title":"Lefschetz Complex Functions","text":"","category":"section"},{"location":"apicore/lefschetz/","page":"Lefschetz Complex Functions","title":"Lefschetz Complex Functions","text":"DocTestSetup = quote\n    push!(LOAD_PATH,\"../../../src/\")\n    using ConleyDynamics\nend","category":"page"},{"location":"apicore/lefschetz/#Simplicial-Complexes","page":"Lefschetz Complex Functions","title":"Simplicial Complexes","text":"","category":"section"},{"location":"apicore/lefschetz/","page":"Lefschetz Complex Functions","title":"Lefschetz Complex Functions","text":"create_simplicial_complex\ncreate_simplicial_rectangle\ncreate_simplicial_delaunay","category":"page"},{"location":"apicore/lefschetz/#ConleyDynamics.create_simplicial_complex","page":"Lefschetz Complex Functions","title":"ConleyDynamics.create_simplicial_complex","text":"create_simplicial_complex(labels::Vector{String},\n                          simplices::Vector{Vector{Int}};\n                          p::Int=2)\n\nInitialize a Lefschetz complex from a simplicial complex. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe vector labels contains a label for every vertex, while simplices contains all the highest-dimensional simplices necessary to define the simplicial complex. Every simplex is represented as a vector of Int, with entries corresponding to the vertex indices.\n\nwarning: Warning\nNote that the labels all have to have the same character length!\n\n\n\n\n\ncreate_simplicial_complex(labels::Vector{String},\n                          simplices::Vector{Vector{String}};\n                          p::Int=2)\n\nInitialize a Lefschetz complex from a simplicial complex. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe vector labels contains a label for every vertex, while simplices contains all the highest-dimensional simplices necessary to define the simplicial complex.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.create_simplicial_rectangle","page":"Lefschetz Complex Functions","title":"ConleyDynamics.create_simplicial_rectangle","text":"create_simplicial_rectangle(nx::Int, ny::Int; p::Int=2)\n\nCreate a simplicial complex covering a rectangle in the plane. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe rectangle is given by the subset [0,nx] x [0,ny] of the plane. Each unit square is represented by four triangles, which meet in the center point of the square. Labels have the following meaning:\n\nThe label XXXYYYb corresponds to the point (XXX, YYY).\nThe label XXXYYYc corresponds to (XXX + 1/2, YYY + 1/2).\n\nThe number of characters in XXX and YYY matches the number  of digits of the larger number of nx and ny. The function returns the following objects:\n\nA simplicial complex sc::LefschetzComplex.\nA vector coords::Vector{Vector{Float64}} of vertex coordinates.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.create_simplicial_delaunay","page":"Lefschetz Complex Functions","title":"ConleyDynamics.create_simplicial_delaunay","text":"create_simplicial_delaunay(boxw::Real, boxh::Real, pdist::Real, attmpt::Int;\n                           p::Int=2)\n\nCreate a planar Delaunay triangulation inside a box. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe function selects a random sample of points inside the rectangular box [0,boxw] x [0,boxh], while trying to maintain a minimum distance  of pdist between the points. The argument attmpt specifies the number of attempts when trying to add points. A standard value is 20, and larger values tend to fill holes better, but at the expense of runtime. From the random sample, the function then creates a Delaunay triangulation, and returns the following objects:\n\nA simplicial complex sc::LefschetzComplex.\nA vector coords::Vector{Vector{Float64}} of vertex coordinates.\n\nNote that the function does not provide a full triangulation of the given rectangle. Close to the boundary there will be gaps.\n\n\n\n\n\ncreate_simplicial_delaunay(boxw::Real, boxh::Real, npoints::Int;\n                           p::Int=2)\n\nCreate a planar Delaunay triangulation inside a box. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe function selects a random sample of npoints points inside the rectangular box [0,boxw] x [0,boxh]. From the random sample, the function then creates a Delaunay triangulation, and returns the following objects:\n\nA simplicial complex sc::LefschetzComplex.\nA vector coords::Vector{Vector{Float64}} of vertex coordinates.\n\nNote that the function does not provide a full triangulation of the given rectangle. Close to the boundary there will be gaps.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Cubical-Complexes","page":"Lefschetz Complex Functions","title":"Cubical Complexes","text":"","category":"section"},{"location":"apicore/lefschetz/","page":"Lefschetz Complex Functions","title":"Lefschetz Complex Functions","text":"create_cubical_complex\ncreate_cubical_rectangle\ncreate_cubical_box\ncube_field_size\ncube_information\ncube_label\nget_cubical_coords","category":"page"},{"location":"apicore/lefschetz/#ConleyDynamics.create_cubical_complex","page":"Lefschetz Complex Functions","title":"ConleyDynamics.create_cubical_complex","text":"create_cubical_complex(cubes::Vector{String}; p::Int=2)\n\nInitialize a Lefschetz complex from a cubical complex. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe vector cubes contains a list of all the highest-dimensional cubes necessary to define the cubical complex. Every cube is represented as a string as follows:\n\nd integers, which correspond to the coordinates of a point in d-dimensional Euclidean space\na point .\nd integers 0 or 1, which give the interval length in the respective dimension\n\nThe first d integers all have to occupy the same number of characters. In addition, if the occupied space is L characters for each coordinate, the coordinates only can take values from 0 to 10^L - 2. This is due to the fact that the boundary operator will add one to certain coordinates, and they still need to be  representable withing the same L digits.\n\nFor example, the string 030600.101 corresponds to the point (3,6,0) in three dimensions. The dimensions are 1, 0, and 1, and therefore this string corresponds to the cube [3,4] x [6] x [0,1]. The same cube could have also been represented by 360.101 or by 003006000.101.\n\nwarning: Warning\nNote that the labels all have to have the same format!\n\nExample\n\njulia> cubes = [\"00.11\", \"01.01\", \"02.10\", \"11.10\", \"11.01\", \"22.00\"];\n\njulia> lc = create_cubical_complex(cubes);\n\njulia> lc.ncells\n17\n\njulia> homology(lc)\n3-element Vector{Int64}:\n 2\n 1\n 0\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.create_cubical_rectangle","page":"Lefschetz Complex Functions","title":"ConleyDynamics.create_cubical_rectangle","text":"create_cubical_rectangle(nx::Int, ny::Int;\n                         p::Int=2, randomize::Real=0.0)\n\nCreate a cubical complex covering a rectangle in the plane. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe rectangle is given by the subset [0,nx] x [0,ny] of the plane, and each unit square gives a two-dimensional cube in the resulting cubical complex. The function returns the following objects:\n\nA cubical complex cc::LefschetzComplex\nA vector coords::Vector{Vector{Float64}} of vertex coordinates\n\nIf the optional parameter randomize is assigned a positive real fraction r less that 0.5, then the actual coordinates will be randomized. They are chosen uniformly from discs of radius r centered at each vertex.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.create_cubical_box","page":"Lefschetz Complex Functions","title":"ConleyDynamics.create_cubical_box","text":"create_cubical_box(nx::Int, ny::Int, nz::Int;\n                   p::Int=2, randomize::Real=0.0)\n\nCreate a cubical complex covering a box in space. The complex is over the rationals if p=0, and over GF(p) if p>0.\n\nThe box is given by the subset [0,nx] x [0,ny] x [0,nz] of space, and each unit cube gives a three-dimensional cube in the resulting cubical complex. The function returns the following objects:\n\nA cubical complex cc::LefschetzComplex\nA vector coords::Vector{Vector{Float64}} of vertex coordinates\n\nIf the optional parameter randomize is assigned a positive real fraction r less that 0.5, then the actual coordinates will be randomized. They are chosen uniformly from balls of radius r centered at each vertex.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.cube_field_size","page":"Lefschetz Complex Functions","title":"ConleyDynamics.cube_field_size","text":"cube_field_size(cube::String)\n\nDetermine the field sizes of a given cube label.\n\nThe function returns the dimension of the ambient space in the first output parameter pointdim, and the length of the individual coordinate fields in the second return variable pointlen.\n\nExample\n\njulia> cube_field_size(\"011654003020.0110\")\n(4, 3)\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.cube_information","page":"Lefschetz Complex Functions","title":"ConleyDynamics.cube_information","text":"cube_information(cube::String)\n\nCompute a cube's coordinate information.\n\nThe function returns an integer vector with the cubes coordinate information. The return vector intinfo contains in its components the following data:\n\n1:pointdim: Coordinates of the anchor point\n1+pointdim:2*pointdim: Interval length in each dimension\n1+2*pointdim: Dimension of the cube\n\nNote that pointdim equals the dimension of the points specifying the cube.\n\nExample\n\njulia> cube_information(\"011654003.011\")\n7-element Vector{Int64}:\n  11\n 654\n   3\n   0\n   1\n   1\n   2\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.cube_label","page":"Lefschetz Complex Functions","title":"ConleyDynamics.cube_label","text":"cube_label(pointdim::Int, pointlen::Int, pointinfo::Vector{Int})\n\nCreate a label from a cube's coordinate information.\n\nThe dimension of the ambient Eucliden space is pointdim, while the field length for each coordinate is pointlen. The vector pointinfo has to be of length at least two times pointdim. The first pointdim entries contain the coordinates of the anchor point, while the next pointdim entries are either 0 or 1 depending on the size of the interval. For example, if poindim = 3 and pointinfo = [1,2,3,1,0,1], then we represent the cube in three-dimensional space given by [1,2] x [2] x [3 4].\n\nExample\n\njulia> cube_label(3,2,[10,23,5,1,1,0])\n\"102305.110\"\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.get_cubical_coords","page":"Lefschetz Complex Functions","title":"ConleyDynamics.get_cubical_coords","text":"get_cubical_coords(cc::LefschetzComplex)\n\nCompute the vertex coordinates for a cubical complex.\n\nThe variable cc has to contain a cubical complex, and the function returns a vector of coordinates for the vertices of the complex, that can then be used for plotting. ```\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Lefschetz-Complex-Queries","page":"Lefschetz Complex Functions","title":"Lefschetz Complex Queries","text":"","category":"section"},{"location":"apicore/lefschetz/","page":"Lefschetz Complex Functions","title":"Lefschetz Complex Functions","text":"lefschetz_field\nlefschetz_is_closed\nlefschetz_is_locally_closed","category":"page"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_field","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_field","text":"fieldstr = lefschetz_field(lc::LefschetzComplex)\n\nReturns the Lefschetz complex coefficient field.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_is_closed","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_is_closed","text":"lefschetz_is_closed(lc::LefschetzComplex, subcomp::Vector{Int})\n\nDetermine whether a Lefschetz complex subset is closed.\n\n\n\n\n\nlefschetz_is_closed(lc::LefschetzComplex, subcomp::Vector{String})\n\nDetermine whether a Lefschetz complex subset is closed.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_is_locally_closed","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_is_locally_closed","text":"lefschetz_is_locally_closed(lc::LefschetzComplex, subcomp::Vector{Int})\n\nDetermine whether a Lefschetz complex subset is locally closed.\n\n\n\n\n\nlefschetz_is_locally_closed(lc::LefschetzComplex, subcomp::Vector{String})\n\nDetermine whether a Lefschetz complex subset is locally closed.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Topological-Features","page":"Lefschetz Complex Functions","title":"Topological Features","text":"","category":"section"},{"location":"apicore/lefschetz/","page":"Lefschetz Complex Functions","title":"Lefschetz Complex Functions","text":"lefschetz_boundary\nlefschetz_coboundary\nlefschetz_closure\nlefschetz_openhull\nlefschetz_lchull\nlefschetz_clomo_pair\nlefschetz_skeleton\nmanifold_boundary","category":"page"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_boundary","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_boundary","text":"lefschetz_boundary(lc::LefschetzComplex, cellI::Int)\n\nCompute the support of the boundary of a Lefschetz complex cell.\n\nThis method returns the boundary support as a Vector{Int}.\n\n\n\n\n\nlefschetz_boundary(lc::LefschetzComplex, cellS::String)\n\nCompute the support of the boundary of a Lefschetz complex cell.\n\nThis method returns the boundary support as a Vector{String}.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_coboundary","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_coboundary","text":"lefschetz_coboundary(lc::LefschetzComplex, cellI::Int)\n\nCompute the support of the coboundary of a Lefschetz complex cell.\n\nThis method returns the boundary support as a Vector{Int}.\n\n\n\n\n\nlefschetz_coboundary(lc::LefschetzComplex, cellS::String)\n\nCompute the support of the coboundary of a Lefschetz complex cell.\n\nThis method returns the boundary support as a Vector{String}.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_closure","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_closure","text":"lefschetz_closure(lc::LefschetzComplex, subcomp::Vector{Int})\n\nCompute the closure of a Lefschetz complex subset.\n\n\n\n\n\nlefschetz_closure(lc::LefschetzComplex, subcomp::Vector{String})\n\nCompute the closure of a Lefschetz complex subset.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_openhull","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_openhull","text":"lefschetz_openhull(lc::LefschetzComplex, subcomp::Vector{Int})\n\nCompute the open hull of a Lefschetz complex subset.\n\n\n\n\n\nlefschetz_openhull(lc::LefschetzComplex, subcomp::Vector{String})\n\nCompute the open hull of a Lefschetz complex subset.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_lchull","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_lchull","text":"lefschetz_lchull(lc::LefschetzComplex, subcomp::Vector{Int})\n\nCompute the locally closed hull of a Lefschetz complex subset.\n\nThe locally closed hull is the smallest locally closed set which contains the given cells. It is the intersection of the closure and the open hull.\n\n\n\n\n\nlefschetz_lchull(lc::LefschetzComplex, subcomp::Vector{String})\n\nCompute the locally closed hull of a Lefschetz complex subset.\n\nThe locally closed hull is the smallest locally closed set which contains the given cells. It is the intersection of the closure and the open hull.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_clomo_pair","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_clomo_pair","text":"lefschetz_clomopair(lc::LefschetzComplex, subcomp::Vector{Int})\n\nDetermine the closure-mouth-pair associated with a Lefschetz complex subset.\n\nThe function returns the pair (closure,mouth).\n\n\n\n\n\nlefschetz_clomopair(lc::LefschetzComplex, subcomp::Vector{String})\n\nDetermine the closure-mouth-pair associated with a Lefschetz complex subset.\n\nThe function returns the pair (closure,mouth).\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_skeleton","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_skeleton","text":"lefschetz_skeleton(lc::LefschetzComplex, subcomp::Vector{Int}, skdim::Int)\n\nCompute the skdim-dimensional skeleton of a Lefschetz complex subset.\n\nThe computed skeleton is for the closure of the subcomplex given by subcomp.\n\n\n\n\n\nlefschetz_skeleton(lc::LefschetzComplex, subcomp::Vector{String}, skdim::Int)\n\nCompute the skdim-dimensional skeleton of a Lefschetz complex subset.\n\nThe computed skeleton is for the closure of the subcomplex given by subcomp.\n\n\n\n\n\nlefschetz_skeleton(lc::LefschetzComplex, skdim::Int)\n\nCompute the skdim-dimensional skeleton of a Lefschetz complex.\n\nThe computed skeleton is for the full Lefschetz complex.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.manifold_boundary","page":"Lefschetz Complex Functions","title":"ConleyDynamics.manifold_boundary","text":"manifold_boundary(lc::LefschetzComplex)\n\nExtract the manifold boundary from a Lefschetz complex.\n\nThe function expects a Lefschetz complex which represents a compact d-dimensional manifold with boundary. It returns a  list of all cells which lie on the topological boundary of the manifold, in the form of a Vector{Int}.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Lefschetz-Subcomplexes","page":"Lefschetz Complex Functions","title":"Lefschetz Subcomplexes","text":"","category":"section"},{"location":"apicore/lefschetz/","page":"Lefschetz Complex Functions","title":"Lefschetz Complex Functions","text":"lefschetz_subcomplex\nlefschetz_closed_subcomplex\npermute_lefschetz_complex","category":"page"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_subcomplex","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_subcomplex","text":"lefschetz_subcomplex(lc::LefschetzComplex, subcomp::Vector{Int})\n\nExtract a subcomplex from a Lefschetz complex. The subcomplex has to be locally closed, and is given by the collection of cells in subcomp.\n\n\n\n\n\nlefschetz_subcomplex(lc::LefschetzComplex, subcomp::Vector{String})\n\nExtract a subcomplex from a Lefschetz complex. The subcomplex has to be locally closed, and is given by the collection of cells in subcomp.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_closed_subcomplex","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_closed_subcomplex","text":"lefschetz_closed_subcomplex(lc::LefschetzComplex, subcomp::Vector{Int})\n\nExtract a closed subcomplex from a Lefschetz complex. The subcomplex is the closure of the collection of cells given in subcomp.\n\n\n\n\n\nlefschetz_closed_subcomplex(lc::LefschetzComplex, subcomp::Vector{String})\n\nExtract a closed subcomplex from a Lefschetz complex. The subcomplex is the closure of the collection of cells given in subcomp.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.permute_lefschetz_complex","page":"Lefschetz Complex Functions","title":"ConleyDynamics.permute_lefschetz_complex","text":"permute_lefschetz_complex(lc::LefschetzComplex,\n                          permutation::Vector{Int})\n\nPermute the indices of a Lefschetz complex.\n\nThe vector permutation contains a permutation of the indices for the given Lefschetz complex lc. If no permutation is specified, or if the length of the vector is not correct, then a randomly generated one will be used.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Lefschetz-Helper-Functions","page":"Lefschetz Complex Functions","title":"Lefschetz Helper Functions","text":"","category":"section"},{"location":"apicore/lefschetz/","page":"Lefschetz Complex Functions","title":"Lefschetz Complex Functions","text":"lefschetz_gfp_conversion\nlefschetz_filtration","category":"page"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_gfp_conversion","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_gfp_conversion","text":"lcgfp = lefschetz_gfp_conversion(lc::LefschetzComplex, p::Int)\n\nConvert a Lefschetz complex to the same complex over a finite field.\n\nIt is expected that the boundary matrix of the given Lefschetz complex lc is defined over the rationals, and that the target characteristic p is a prime.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.lefschetz_filtration","page":"Lefschetz Complex Functions","title":"ConleyDynamics.lefschetz_filtration","text":"lefschetz_filtration(lc::LefschetzComplex, fvalues::Vector{Int})\n\nCompute a filtration on a Lefschetz subset.\n\nThe considered Lefschetz complex is given in lc. The vector fvalues assigns an integer between 0 and N to every cell in lc. For every k the complex L_k is given by the closure of all cells with values between 1 and k. The function returns the following variables:\n\nlcsub: The subcomplex L_N\nfvalsub: The filtration on the subcomplex with values 1,...,N\n\nExample\n\njulia> labels = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"];\n\njulia> simplices = [[\"A\",\"B\",\"D\"],[\"B\",\"D\",\"E\"],[\"B\",\"C\",\"E\"],[\"C\",\"E\",\"F\"],[\"F\",\"G\"]];\n\njulia> sc = create_simplicial_complex(labels,simplices);\n\njulia> filtration = [0,0,0,0,0,0,0,1,1,0,1,2,0,4,2,4,0,5,3,7,6];\n\njulia> lcsub, fvalsub = lefschetz_filtration(sc,filtration);\n\njulia> phinf, phint = persistent_homology(lcsub,fvalsub);\n\njulia> phinf\n3-element Vector{Vector{Int64}}:\n [1]\n []\n []\n\njulia> phint\n3-element Vector{Vector{Tuple{Int64, Int64}}}:\n []\n [(1, 5), (2, 7), (4, 6)]\n []\n\n\n\n\n\nlefschetz_filtration(lc::LefschetzComplex, strfilt::Vector{Vector{String}})\n\nCompute a filtration on a Lefschetz subset.\n\nThe considered Lefschetz complex is given in lc. The vector of string vectors strfilt contains the necessary simplices to build the filtration. The list strfilt[k] contains the simplices that are added at the k-th step, together with their closures. Thus, for every k the complex L_k is given by the closure of all cells listed in strfilt[i] for i between 1 and k. The function returns the following variables:\n\nlcsub: The subcomplex L_N, where N = length(strfilt)\nfvalsub: The filtration on the subcomplex with values 1,...,N\n\nExample\n\njulia> labels = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"];\n\njulia> simplices = [[\"A\",\"B\",\"D\"],[\"B\",\"D\",\"E\"],[\"B\",\"C\",\"E\"],[\"C\",\"E\",\"F\"],[\"F\",\"G\"]];\n\njulia> sc = create_simplicial_complex(labels,simplices);\n\njulia> strfiltration = [[\"AB\",\"AD\",\"BD\"],[\"BE\",\"DE\"],[\"BCE\"],[\"CF\",\"EF\"],[\"ABD\"],[\"CEF\"],[\"BDE\"]];\n\njulia> lcsub, fvalsub = lefschetz_filtration(sc, strfiltration);\n\njulia> phinf, phint = persistent_homology(lcsub,fvalsub);\n\njulia> phinf\n3-element Vector{Vector{Int64}}:\n [1]\n []\n []\n\njulia> phint\n3-element Vector{Vector{Tuple{Int64, Int64}}}:\n []\n [(1, 5), (2, 7), (4, 6)]\n []\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Cell-Subset-Helper-Functions","page":"Lefschetz Complex Functions","title":"Cell Subset Helper Functions","text":"","category":"section"},{"location":"apicore/lefschetz/","page":"Lefschetz Complex Functions","title":"Lefschetz Complex Functions","text":"convert_cells\nconvert_cellsubsets","category":"page"},{"location":"apicore/lefschetz/#ConleyDynamics.convert_cells","page":"Lefschetz Complex Functions","title":"ConleyDynamics.convert_cells","text":"convert_cells(lc::LefschetzComplex, cl::Vector{Int})\n\nConvert cell list cl in the Lefschetz complex lc from  index form to label form.\n\n\n\n\n\nconvert_cells(lc::LefschetzComplex, cl::Vector{String})\n\nConvert cell list cl in the Lefschetz complex lc from  label form to index form.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.convert_cellsubsets","page":"Lefschetz Complex Functions","title":"ConleyDynamics.convert_cellsubsets","text":"convert_cellsubsets(lc::LefschetzComplex, clsub::Vector{Vector{Int}})\n\nConvert CellSubsets clsub in the Lefschetz complex lc from  index form to label form.\n\n\n\n\n\nconvert_cellsubsets(lc::LefschetzComplex, clsub::Vector{Vector{String}})\n\nConvert CellSubsets clsub in the Lefschetz complex lc from  label form to index form.\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#Coordinate-Helper-Functions","page":"Lefschetz Complex Functions","title":"Coordinate Helper Functions","text":"","category":"section"},{"location":"apicore/lefschetz/","page":"Lefschetz Complex Functions","title":"Lefschetz Complex Functions","text":"convert_planar_coordinates\nconvert_spatial_coordinates","category":"page"},{"location":"apicore/lefschetz/#ConleyDynamics.convert_planar_coordinates","page":"Lefschetz Complex Functions","title":"ConleyDynamics.convert_planar_coordinates","text":"convert_planar_coordinates(coords::Vector{Vector{Float64}},\n                           p0::Vector{Float64},\n                           p1::Vector{Float64})\n\nConvert a given collection of planar coordinates.\n\nThe vector coords contains pairs of coordinates, which are then transformed to fit into the box with vertices p0 = (p0x,p0y) and p1 = (p1x,p1y). It is assumed that p0 denotes the lower left box corner, while p1 is the upper right corner. The function shifts and scales the coordinates in such a way that every side of the box contains at least one point. Upon completion, it returns a new coordinate vector coordsNew.\n\nMore precisely, if the x-coordinates are spanning the interval [xmin,xmax] and the y-coordinates span [ymin,ymax], then the point (x,y) is transformed to (xn,yn) with:\n\nxn = p0x + (p1x-p0x) * (x-cxmin) / (cxmax-cxmin)\nyn = p0y + (p1y-p0y) * (y-cymin) / (cymax-cymin)\n\n\n\n\n\n","category":"function"},{"location":"apicore/lefschetz/#ConleyDynamics.convert_spatial_coordinates","page":"Lefschetz Complex Functions","title":"ConleyDynamics.convert_spatial_coordinates","text":"convert_spatial_coordinates(coords::Vector{Vector{Float64}},\n                            p0::Vector{Float64},\n                            p1::Vector{Float64})\n\nConvert a given collection of spatial coordinates.\n\nThe vector coords contains triples of coordinates, which are then transformed to fit into the box with vertices p0 = (p0x,p0y,p0z) and p1 = (p1x,p1y,p1z). It is assumed that each coordinate of p0 is strictly smaller than the corresponding coordinate of p1. The function shifts and scales the coordinates in such a way that every side of the box contains at least one point. Upon completion, it returns a new coordinate vector coordsNew.\n\nMore precisely, if the x-coordinates are spanning the interval [xmin,xmax], the y-coordinates span [ymin,ymax], and the z-coordinates span [zmin,zmax], then the point (x,y,z) is transformed to (xn,yn,zn) with:\n\nxn = p0x + (p1x-p0x) * (x-cxmin) / (cxmax-cxmin)\nyn = p0y + (p1y-p0y) * (y-cymin) / (cymax-cymin)\nzn = p0z + (p1z-p0z) * (z-czmin) / (czmax-czmin)\n\n\n\n\n\n","category":"function"},{"location":"#ConleyDynamics.jl","page":"Overview","title":"ConleyDynamics.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Conley index and multivector fields for Julia.","category":"page"},{"location":"#Introduction","page":"Overview","title":"Introduction","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"ConleyDynamics.jl is a Julia package for studying combinatorial multivector fields using Conley theory. The multivector fields can be studied on arbitrary Lefschetz complexes, which include both simplicial and cubical complexes as important special cases. The concept of combinatorial multivector field generalizes Forman vector fields, which were originally introduced to study Morse theory in a discrete combinatorial setting.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"note: Note\nThis package and the documentation is still very much work in progress!","category":"page"},{"location":"#Features","page":"Overview","title":"Features","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Data structures for Lefschetz complexes, in particular simplicial and cubical complexes.\nClassical Forman combinatorial vector fields and multivector fields are supported.\nComputation of Conley indices, connection matrices, and Conley-Morse graphs.\nBasic homology algorithms over finite fields and the rationals, including persistent homology and relative homology.\nAlgorithms rely on a built-in sparse matrix implementation which is geared towards computations over finite fields and the rationals.","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"To use ConleyDynamics.jl please install Julia 1.10 or higher. See https://julialang.org/downloads/ for instructions on how to obtain Julia for your system.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"At the Julia prompt simply type","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> using Pkg; Pkg.add(\"ConleyDynamics\")","category":"page"},{"location":"#Manual-Outline","page":"Overview","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The Tutorial briefly explains how to get started with ConleyDynamics.jl. More details, including on the underlying mathematics, are provided in the following four sections, which cover Lefschetz complexes, homology, Conley theory including connection matrices, and sparse matrices, respectively. Finally, a discussion of all included examples can be found in the Examples section.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Pages = [\n    \"man/tutorial.md\",\n    \"man/lefschetz.md\",\n    \"man/homology.md\",\n    \"man/conley.md\",\n    \"man/sparse.md\",\n    \"man/examples.md\",\n]\nDepth = 2","category":"page"},{"location":"apicore/datastruct/#Composite-Data-Structures","page":"Composite Data Structures","title":"Composite Data Structures","text":"","category":"section"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"The package relies on a number of basic composite data structures that encompass more complicated objects. For the internal representation of sparse matrices we refer to Internal Sparse Matrix Representation.","category":"page"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"ConleyDynamics","category":"page"},{"location":"apicore/datastruct/#ConleyDynamics","page":"Composite Data Structures","title":"ConleyDynamics","text":"module ConleyDynamics\n\nCollection of tools for computational Conley theory.\n\n\n\n\n\n","category":"module"},{"location":"apicore/datastruct/#Lefschetz-Complex-Type","page":"Composite Data Structures","title":"Lefschetz Complex Type","text":"","category":"section"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"LefschetzComplex","category":"page"},{"location":"apicore/datastruct/#ConleyDynamics.LefschetzComplex","page":"Composite Data Structures","title":"ConleyDynamics.LefschetzComplex","text":"LefschetzComplex\n\nCollect the Lefschetz complex information in a struct.\n\nThe struct has the following fields:\n\nncells::Int: Number of cells\ndim::Int: Dimension of the complex\nboundary::SparseMatrix: Boundary matrix, columns give the cell boundaries\nlabels::Vector{String}: Vector of labels associated with cell indices\nindices::Dict{String,Int}: Dictionary for finding cell index from label\ndimensions::Vector{Int}: Vector cell dimensions\n\nThe coefficient field is specified by the boundary matrix.\n\n\n\n\n\n","category":"type"},{"location":"apicore/datastruct/#Cell-Subset-Types","page":"Composite Data Structures","title":"Cell Subset Types","text":"","category":"section"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"Cells\nCellSubsets","category":"page"},{"location":"apicore/datastruct/#ConleyDynamics.Cells","page":"Composite Data Structures","title":"ConleyDynamics.Cells","text":"Cells = Union{Vector{Int},Vector{String}}\n\nA list of cells of a Lefschetz complex.\n\nThis data type is used to represent subsets of a Lefschetz complex. It is used for individual isolated invariant sets, locally closed subsets, and multivectors.\n\n\n\n\n\n","category":"type"},{"location":"apicore/datastruct/#ConleyDynamics.CellSubsets","page":"Composite Data Structures","title":"ConleyDynamics.CellSubsets","text":"CellSubsets = Union{Vector{Vector{Int}},Vector{Vector{String}}}\n\nA collection of cell lists.\n\nThis data type is used to represent a collection of subsets of a Lefschetz complex. It is used for Morse decompositions and for multivector fields.\n\n\n\n\n\n","category":"type"},{"location":"apicore/datastruct/#Conley-Morse-Graph-Type","page":"Composite Data Structures","title":"Conley-Morse Graph Type","text":"","category":"section"},{"location":"apicore/datastruct/","page":"Composite Data Structures","title":"Composite Data Structures","text":"ConleyMorseCM","category":"page"},{"location":"apicore/datastruct/#ConleyDynamics.ConleyMorseCM","page":"Composite Data Structures","title":"ConleyDynamics.ConleyMorseCM","text":"ConleyMorseCM{T}\n\nCollect the connection matrix information in a struct.\n\nThe struct has the following fields:\n\nmatrix::SparseMatrix{T}: Connection matrix\ncolumns::Vector{Int}: Corresponding columns in the boundary matrix\nposet::Vector{Int}: Poset indices for the connection matrix columns\nlabels::Vector{String}: Labels for the connection matrix columns\nmorse::Vector{Vector{String}}: Vector of Morse sets in original complex\nconley::Vector{Vector{Int}}: Vector of Conley indices for the Morse sets\ncomplex::LefschetzComplex: The Conley complex as a Lefschetz complex\n\n\n\n\n\n","category":"type"}]
}
