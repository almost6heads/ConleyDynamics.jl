export lefschetz_filtration_mvf

"""
    lefschetz_filtration_mvf(lc::LefschetzComplex, fvalues::Vector{Int})

Compute the multivector field associated with a Lefschetz complex filtration.

For the Lefschetz complex `lc`, and the filtration `fvalues` given on the
Lefschetz complex, this function determines the multivector field generated 
by the filtration in the following way. For every filtration value `k`,
the cells which are assigned this value form a locally closed set, which
can be decomposed into connected components that are all locally closed.
The union of all these connected components, as `k` ranges from `1` to `N`,
forms the multivector field `mvf` that is returned by the function. The
filtration should be generated by the function `lefschetz_filtration`.
"""
function lefschetz_filtration_mvf(lc::LefschetzComplex, fvalues::Vector{Int})
    #
    # Compute a multivector field from a Lefschetz complex filtration
    #

    # Basic consistency check

    maxf = maximum(fvalues)
    fval = sort(unique(fvalues))
    @assert (fval[1]==1) && (length(fval)==maxf) "This is not a filtration!"

    # Create the dynamical transitions in parallel

    tchannel = Channel{Vector{Int}}(Inf)
    cindices = findall(x -> x<lc.dim, lc.dimensions)

    # We know that the cells with value k form a locally closed set.
    # Therefore, we only need to record the necessary dynamical
    # transitions between a cell and its coboundary cells. Then 
    # the minimal multivector field which respects these transitions
    # is the one we are looking for.

    Threads.@threads for c in cindices
        ccbd = lefschetz_coboundary(lc, c)
        tindices = findall(x -> fvalues[x]==fvalues[c], ccbd)
        if length(tindices)>0
            tcells = ccbd[tindices]
            push!(tcells, c)
            put!(tchannel, tcells)
        end
    end

    close(tchannel)
    transitions = collect(tchannel)

    # Determine the multivector field
    
    mvf = create_mvf_hull(lc, transitions)
end

