# Tutorial

This tutorial explains the basic usage of the main components
of ConleyDynamics. It is not meant to be exhaustive, since more 
details will be provided in the more indiviualized sections. Also,
precise mathematical definitions will be delayed until then.

## Creating Lefschetz Complexes

The fundamental mathematical object for ConleyDynamics is a Lefschetz
complex. For now we note that both simplicial complexes and cubical
complexes are special cases, and ConleyDynamics provides convenient
interfaces for generating them.

We begin by considering the case of a simplicial complex. Recall that
an *abstract simplicial complex* ``K`` is just a collection of finite
sets, called *simplices*, which is closed under taking subsets. In
other words, every subset of a simplex is again a simplex. Each
simplex has an associated *dimension*, which is one less than the 
number of its elements. One usually calls simplices of dimension
0 *vertices*, *edges* have dimension 1, and simplices of dimension 2
are *triangles*. It follows easily from these definitions that every
simplex is the union of its vertices.

In ConleyDynamics it is easy to generate a simplicial complex. This
requires two objects:

- The vertices are described by a vector `labels` of string labels
  for the vertices of the simplicial complex. Thus, the length of the
  vector equals the number of vertices, and the k-th entry is the
  label for the k-th vertex.
- In addition, a second vector `simplices` has to describe enough
  simplices so that the simplicial complex is determined. This object
  is a vector of vectors, and the vector `simplices[k]` describes the
  index values of all the vertices in the k-th simplex. These indices
  are precisely the corresponding locations of the vertices in
  `labels`.

!!! tip "Simplices via labels"
    It is also possible to specify the list of simplices using
    a `Vector{Vector{String}}`, i.e., as a vector of string vectors.
    In this case, the entry `simplices[k]` is a list of the labels
    of the vertices.

!!! warning "Watch the label length"
    It is expected that the labels in `labels` all have the same
    number of characters. This is due to the fact that when creating
    the simplicial complex, ConleyDynamics automatically creates 
    labels for each of the simplices in ``K``, by concatenating the
    vertex labels. Not using a fixed label size could lead to 
    ambiguities, and will therefore raise an error message.

![A first simplicial complex](img/tutorialsimplex.png)

The following first example creates a simple simplicial complex.
The complex is shown in the above figure, and it has six
vertices which we label by the first six letters.

```@example T1
using ..ConleyDynamics # hide
labels = ["A","B","C","D","E","F"]
simplices = [["A","B"],["A","C"],["B","C"],["B","D"],["D","E","F"]]
sc = create_simplicial_complex(labels,simplices)
fieldnames(typeof(sc))
```

Based on the simplex specifications, the generated simplicial complex ``K``
consists of three edges connecting each of the vertices `A`, `B`, and `C`,
a two-dimensional triangle `DEF`, as well as the edge `BD` which connects
the triangle boundary and the filled triangle. The created struct `sc` is
of type `LefschetzComplex`, with fieldnames as indicated in the above
output. The number of cells in the complex can be seen as follows:

```@example T1
println(sc.ncells)
```

Note that the final simplicial complex has a total of seven edges, since
also the edges of `DEF` are part of the simplicial complex. They are
automatically generated by `create_simplicial_complex`. The dimension
of `K` is the largest simplex dimensions, and can be seen via

```@example T1
println(sc.dim)
```

The `sc` struct also contains a vector of labels, which in this case
takes the form

```@example T1
println(sc.labels)
```

Finally, the Lefschetz complex data structure for our simplicial
complex ``K`` also includes the dimensions for the corresponding
cells in the integer vector `sc.dimensions`, a dictionary `sc.indices`
which associates each simplex label with its integer index, and the
boundary map `sc.boundary` which will be described in more detail
in [Lefschetz Complexes](@ref).

## Computing Homology and Persistence

Any simplicial complex, and in fact any Lefschetz complex, has
an associated *homology*. Informally, the latter describes the
connectivity structure of the simplicial complex. More precisely,
the homology consists of a sequence of integers, called the *Betti
numbers*, which are indexed by dimension. There are Betti numbers
``\beta_k(K)`` for every ``k = 0,\ldots,\dim K``. The zero-dimensional
Betti number ``\beta_0(K)`` gives the number of connected components
of ``K``, while ``\beta_1(K)`` counts the number of independent
loops that can be found in ``K``. Finally, ``\beta_2(K)`` equals
the number of cavities. In our case, we have

```@example T1
homology(sc, p=0)
```

This means that the simplicial complex ``K`` has one component, as
well as one loop, and no cavities. The function `homology` returns 
a vector of integers, whose k-th entry is ``\beta_{k-1}(K)``.

ConleyDynamics also allows for the computation of *relative 
homology*. In the case of relative homology, together with the
simplicial complex ``K`` one has to specify a closed subcomplex
``K_0``. Intuitively, the relative homology ``H_*(K,K_0)`` is
the homology of a new space, which is obtained from ``K`` by
identifying ``K_0`` to a single point, and then decreasing the
zero-dimensional Betti number by 1. Consider for example the 
following command:

```@example T1
relative_homology(sc, [1,6], p=0)
```

In this case, the subcomplex ``K_0`` consists of the two vertices
`A` and `F`, which are therefore glued together. This leads to zero
Betti numbers in dimension 0 and 2 (remember that the zero-dimensional
Betti number is decreased by 1!), and a one-dimensional Betti number
of 2. The latter is increased by one since we obtain a second loop by
moving from `A` to `F = A` along the edges `AB`, `BD`, and `DF`.
Another example is the following:

```@example T1
relative_homology(sc, ["DE","DF","EF"], p=0)
```

In this case, the subcomplex ``K_0`` consists of the edges `DE`,
`DF`, and `EF` -- together with the three vertices `D`, `E`, and
`F` which are automatically added by `relative_homology`. Identifying
them all to one point creates a hollow two-dimensional sphere, and
the relative Betti numbers reflect that fact.

As the above two examples demonstrate, the subcomplex can be specified
either as a list of simplex indices, or through the simplex labels.
Moreover, the specfied subspace simplex list is automatically extended
by `relative_homology` to include all simplex faces, i.e., it computes
the simplicial closure to arrive at a closed subcomplex. Finally,
note that the subcomplex can be empty:

```@example T1
relative_homology(sc, [], p=0)
```

As expected, in this case one obtains the standard homology of `sc`.

In addition to regular and relative homology, ConleyDynamics can also
compute *persistent homology*. In this case, one has to specify a 
*filtration* of closed Lefschetz complexes

```math
  K_1 \subset K_2 \subset \ldots \subset K_m .
```

Then persistent homology tracks the appearance and disappearance
(also often called the birth and death) of topological features
as one moves through the complexes in the filtration. In
ConleyDynamics, one can specify a Lefschetz complex filtration
by assigning the integer ``k`` to each simplex that first appears
in ``K_k``. Moreover, it is expected that ``K_m = K``. Then the
persistent homology is computed via the following command:

```@example T1
filtration = [1,1,1,2,2,2,1,1,1,3,2,2,2,4]
phsingles, phpairs = persistent_homology(sc, filtration, p=0)
```

The function returns the *persistence intervals*, which give
the birth and death indices of each topological feature in each
dimension. There are two types of intervals:

- Intervals of the form ``[a,\infty)`` correspond to topological
  features that first appear in ``K_a`` and are still present
  in the final complex. The starting indices of such features
  in dimension `k` are contained in the list `phsingles[k+1]`.
- Intervals of the form ``[a,b)`` correspond to topological
  features that first appear in ``K_a`` and first disappear
  in ``K_b``. The corresponding pairs `(a,b)` in dimension
  `k` are contained in the list `phsingles[k+1]`.

In our above example, one observes intervals ``[1,\infty)``
in dimensions zero and one -- and these correspond to a
connected component and the loop generated by the edges
`AB`, `AC`, and `BC`. These appear first in ``K_1`` and are
still present in ``K_4``. The interval ``[2,3)`` in dimension
zero represents the new component created by ``K_2``, and it
disappears through merging with the older component from
``K_1`` when the edge `BD` is introduced with ``K_3``.
Similarly, the interval ``[2,4)`` in dimension one is the
loop created by the triangle `DE`, `DF`, and `EF` in ``K_2``,
which disappears with the introduction of the triangle `DEF`
in ``K_4``. Note that the interval death times respect the
*elder rule*: When for example a component disappears through
merging, the younger interval gets killed, and the older one
continues to live. Similarly in higher dimensions.

## Forman Vector Fields and Isolated Invariant Sets







![A first Forman vector field](img/tutorialforman.png)


## Finding Connection Matrices

We now turn our attention to an example from
[mrozek:wanner:p21a; Figure 1](@citet*), which happens to 
be also the logo for `ConleyDynamics.jl`.


![The logo multivector field](img/multivectorex.png)


## Working with Sparse Matrices



## Tutorial References

See the [full bibliography](@ref References) for a complete list
of references cited throughout this documentation. This page cites
the following references:

```@bibliography
Pages = ["guide.md"]
Canonical = false
```

