# Tutorial

This tutorial explains the basic usage of the main components of ConleyDynamics.
It is not meant to be exhaustive, since more details will be provided in the
more indiviualized sections. Also, precise mathematical definitions will be
delayed until then. The presented examples are taken from the papers
[batko:etal:20a](@cite) and [mrozek:wanner:p21a](@cite), with minor
modifications.

## Creating Lefschetz Complexes

The fundamental mathematical object for ConleyDynamics is a Lefschetz complex
[lefschetz:42a](@cite). For now we note that both simplicial complexes and
cubical complexes are special cases, and ConleyDynamics provides convenient
interfaces for generating them.

For the sake of simplicity, this tutorial only considers the case of a
simplicial complex. Recall that an *abstract simplicial complex* ``K`` is just a
collection of finite sets, called *simplices*, which is closed under taking
subsets. In other words, every subset of a simplex is again a simplex. Each
simplex has an associated *dimension*, which is one less than the number of its
elements. One usually calls simplices of dimension 0 *vertices*, *edges* have
dimension 1, and simplices of dimension 2 are *triangles*. It follows easily
from these definitions that every simplex is the union of its vertices.

In ConleyDynamics it is easy to generate a simplicial complex. This requires two
objects:

- The vertices are described by a vector `labels` of string labels
  for the vertices of the simplicial complex. Thus, the length of the
  vector equals the number of vertices, and the k-th entry is the
  label for the k-th vertex.
- In addition, a second vector `simplices` has to describe enough
  simplices so that the simplicial complex is determined. This object
  is a vector of vectors, and the vector `simplices[k]` describes the
  index values of all the vertices in the k-th simplex. These indices
  are precisely the corresponding locations of the vertices in
  `labels`.

!!! tip "Simplices via labels"
    It is also possible to specify the list of simplices using
    a `Vector{Vector{String}}`, i.e., as a vector of string vectors.
    In this case, the entry `simplices[k]` is a list of the labels
    of the vertices.

!!! warning "Watch the label length"
    It is expected that the labels in `labels` all have the same
    number of characters. This is due to the fact that when creating
    the simplicial complex, ConleyDynamics automatically creates 
    labels for each of the simplices in ``K``, by concatenating the
    vertex labels. Not using a fixed label size could lead to 
    ambiguities, and will therefore raise an error message.

![A first simplicial complex](img/tutorialsimplex.png)

The following first example creates a simple simplicial complex.  The complex is
shown in the above figure, and it has six vertices which we label by the first
six letters.

```@example T1
using ..ConleyDynamics # hide
labels = ["A","B","C","D","E","F"]
simplices = [["A","B"],["A","C"],["B","C"],["B","D"],["D","E","F"]]
sc = create_simplicial_complex(labels,simplices)
fieldnames(typeof(sc))
```

Based on the simplex specifications, the generated simplicial complex ``K``
consists of three edges connecting each of the vertices `A`, `B`, and `C`, a
two-dimensional triangle `DEF`, as well as the edge `BD` which connects the
triangle boundary and the filled triangle. The created struct `sc` is of type
`LefschetzComplex`, with fieldnames as indicated in the above output. The number
of cells in the complex can be seen as follows:

```@example T1
println(sc.ncells)
```

Note that the final simplicial complex has a total of seven edges, since also
the edges of `DEF` are part of the simplicial complex. They are automatically
generated by `create_simplicial_complex`. The dimension of `K` is the largest
simplex dimensions, and can be recalled via

```@example T1
println(sc.dim)
```

The `sc` struct also contains a vector of labels, which in this case takes the
form

```@example T1
println(sc.labels)
```

Finally, the Lefschetz complex data structure for our simplicial complex ``K``
also includes the dimensions for the corresponding cells in the integer vector
`sc.dimensions`, a dictionary `sc.indices` which associates each simplex label
with its integer index, and the boundary map `sc.boundary` which will be
described in more detail in [Lefschetz Complexes](@ref). The latter map
is internally stored as an integer sparse matrix.

## Computing Homology and Persistence

Any simplicial complex, and in fact any Lefschetz complex, has an associated
*homology*. Informally, homology describes the connectivity structure of the
simplicial complex. More precisely, the homology consists of a sequence of
integers, called the *Betti numbers*, which are indexed by dimension. There are
Betti numbers ``\beta_k(K)`` for every ``k = 0,\ldots,\dim K``. The
zero-dimensional Betti number ``\beta_0(K)`` gives the number of connected
components of ``K``, while ``\beta_1(K)`` counts the number of independent loops
that can be found in ``K``. Finally, ``\beta_2(K)`` equals the number of
cavities. In our case, we have

```@example T1
homology(sc, p=0)
```

This means that the simplicial complex ``K`` has one component, as well as one
loop, and no cavities. The function `homology` returns a vector of integers,
whose k-th entry is ``\beta_{k-1}(K)``. We would like to point out that in
ConleyDynamics all homology computations are performed over fields, and 
therefore homology is completely described by the Betti numbers. Two
types of fields are supported, and they are selected by specifying the
field characteristic `p`:

- If `p=0`, then the homology computation uses the field of rational numbers.
- For any prime number `p`, homology is determined over the finite field
  ``GF(p)`` with `p` elements. 

ConleyDynamics also allows for the computation of *relative homology*. In the
case of relative homology, together with the simplicial complex ``K`` one has to
specify a closed subcomplex ``K_0``. Intuitively, the relative homology
``H_*(K,K_0)`` is the homology of a new space, which is obtained from ``K`` by
identifying ``K_0`` to a single point, and then decreasing the zero-dimensional
Betti number by 1. Consider for example the following command:

```@example T1
relative_homology(sc, [1,6], p=0)
```

In this case, the subcomplex ``K_0`` consists of the two vertices `A` and `F`,
which are therefore glued together. This leads to zero Betti numbers in
dimension 0 and 2 (remember that the zero-dimensional Betti number is decreased
by 1!), and a one-dimensional Betti number of 2. The latter is increased by one
since we obtain a second loop by moving from `A` to `F = A` along the edges
`AB`, `BD`, and `DF`.  Another example is the following:

```@example T1
relative_homology(sc, ["DE","DF","EF"], p=0)
```

Now the subcomplex ``K_0`` consists of the edges `DE`, `DF`, and `EF` --
together with the three vertices `D`, `E`, and `F` which are automatically added
by `relative_homology`. Identifying them all to one point creates a hollow
two-dimensional sphere, and the relative Betti numbers reflect that fact.

As the above two examples demonstrate, the subcomplex can be specified either as
a list of simplex indices, or through the simplex labels.  Moreover, the
specfied subspace simplex list is automatically extended by `relative_homology`
to include all simplex faces, i.e., it computes the simplicial closure to arrive
at a closed subcomplex. Finally, note that the subcomplex can be empty:

```@example T1
relative_homology(sc, [], p=0)
```

As expected, in this case one obtains the standard homology of `sc`.

In addition to regular and relative homology, ConleyDynamics can also compute
*persistent homology*. For this, one has to specify a *filtration* of closed
Lefschetz complexes

```math
  K_1 \subset K_2 \subset \ldots \subset K_m .
```

Then persistent homology tracks the appearance and disappearance (also often
called the birth and death) of topological features as one moves through the
complexes in the filtration. In ConleyDynamics, one can specify a Lefschetz
complex filtration by assigning the integer ``k`` to each simplex that first
appears in ``K_k``. Moreover, it is expected that ``K_m = K``. Then the
persistent homology is computed via the following command:

```@example T1
filtration = [1,1,1,2,2,2,1,1,1,3,2,2,2,4]
phsingles, phpairs = persistent_homology(sc, filtration, p=0)
```

The function returns the *persistence intervals*, which give the birth and death
indices of each topological feature in each dimension. There are two types of
intervals:

- Intervals of the form ``[a,\infty)`` correspond to topological
  features that first appear in ``K_a`` and are still present
  in the final complex. The starting indices of such features
  in dimension `k` are contained in the list `phsingles[k+1]`.
- Intervals of the form ``[a,b)`` correspond to topological
  features that first appear in ``K_a`` and first disappear
  in ``K_b``. The corresponding pairs `(a,b)` in dimension
  `k` are contained in the list `phsingles[k+1]`.

In our above example, one observes intervals ``[1,\infty)`` in dimensions zero
and one -- and these correspond to a connected component and the loop generated
by the edges `AB`, `AC`, and `BC`. These appear first in ``K_1`` and are still
present in ``K_4``. The interval ``[2,3)`` in dimension zero represents the new
component created by ``K_2``, and it disappears through merging with the older
component from ``K_1`` when the edge `BD` is introduced with ``K_3``.
Similarly, the interval ``[2,4)`` in dimension one is the loop created by the
triangle `DE`, `DF`, and `EF` in ``K_2``, which disappears with the introduction
of the triangle `DEF` in ``K_4``. Note that the interval death times respect the
*elder rule*: When for example a component disappears through merging, the
younger interval gets killed, and the older one continues to live. Similarly in
higher dimensions.

## Forman Vector Fields

The main focus of ConleyDynamics is on the study of *combinatorial topological
dynamics* on Lefschetz complexes. While the phase space as Lefschetz complex has
been discussed above, albeit only for the special case of a simplicial complex,
the dynamics part can be given in the simplest form by a *combinatorial vector
field*, also called a *Forman vector field* [forman:98a, forman:98b](@cite).  We
will soon see that such vector fields are a more restrictive version of
*multivector fields*, but they are easier to start with.  The following command
defines a simple Forman vector field on our sample simplicial complex ``K`` from
above:

```@example T1
formanvf = [["A","AC"],["B","AB"],["C","BC"],["D","BD"],["E","DE"]]
```

The Forman vector field `formanvf` is viualized in the accompanying figure.

![A first Forman vector field](img/tutorialforman.png)

According to the figure, a Forman vector field is comprised of *arrows*, as well
as *critical cells* which are indicated by red dots. Every simplex of the
underlying simplicial complex is either critical, or it is contained in a unique
arrow. In other words, the collection of critical cells and arrows forms a
partition of the simplicial complex ``K``. Arrows always have to consist of
precisely two simplices: The source of the arrow is a simplex ``\sigma^-``,
while its target is a second simplex ``\sigma^+``. These two simplices have to
be related in the sense that ``\sigma^-`` is a *facet* of ``\sigma^+``. Recall
that a facet of a simplex ``\tau`` is any subsimplex obtained from ``\tau`` by
removing precisely one vertex, i.e., its dimension is exactly one less that
``\dim\tau``, and it is therefore contained in the boundary of ``\tau``.

As the above Julia code shows, a forman vector field is described by a vector of
string vectors, where each of the latter contains the labels of the two
simplices making up an arrow. Note that the critical cells are not explicitly
listed, as any simplex of ``K`` that is not part of a vector is automatically
critical. Alternatively, one could define the Forman vector field as a
`Vector{Vector{Int}}`, if the labels are replaced by the corresponding
indices in `sc.indices`.

Intuitively, the above visualization of the Forman vector field `formanvf`
clearly induces *dynamical behavior* on the simplicial complex `sc`:

- __Critical cells__ can be though of as *equilibrium states* for the
  dynamics, i.e., they contain a stationary solution. Depending
  on their dimension, they can also exhibit nonconstant dynamics --
  which in backward time converges to the equilibrium, and in forward
  time flows towards the boundary of the simplex.
- __Arrow sources__ always lead to flow into the interior of their
  target simplex ``\sigma^+``.
- __Arrow targets__ create flow towards the boundary of ``\sigma^+``,
  except towards the source facet ``\sigma^-``.

In the above figure, for example, the simplex `EF` is a critical cell, so it
contains an equilibrium. At the same time, it also allows for flow towards the
boundary, which consists of the vertices `E` and `F`.  A solution flowing to the
former then has to enter `DE`, flow through `D` to `BD`, before entering the
periodic orbit given by

```math
   B \to AB \to A \to AC \to C \to BC \to B \to AB \to \ldots
```

This heuristic description can be made precise. It was shown in
[mrozek:wanner:21a](@cite) that for every Forman vector field on a simplicial
complex there exists a classical dynamical system which exhibits dynamics
consistent with the above interpretation.

## Isolated Invariant Sets

The global dynamical behavior of a Forman vector field on a simplicial complex
can be described by first decomposing it into smaller building blocks. An
*invariant set* is a subset ``S \subset K`` of the simplicial complex such that
for every simplex ``\sigma \in S`` there exists a solution through ``\sigma``
which is contained in ``S`` and which exists for all forward and backward time.
For example, in our example the following are sample invariant sets:

- Every critical cell ``\sigma`` by itself is an invariant set, since we can
  choose the constant solution ``\sigma`` in the above definition. Thus, also
  every union of critical cells is invariant.
- The periodic orbit ``S_P = \{ A, B, C, AB, AC, BC \}`` is an invariant set,
  since the periodic orbit mentioned earlier exists for all forward and
  backward time in ``S_P`` and passes through every simplex of the orbit.

While it is tempting to try to decompose the dynamics into invariant sets and
"everything else", Conley realized that a better theory can be built around
invariant sets which are isolated [conley:78a](@cite). In our combinatorial
setting, an *isolated invariant set* is an invariant set ``S \subset K`` with
the following two additional properties:

- The set ``S`` is *locally closed*, i.e., the associated set ``\mathrm{mo} S
  = \mathrm{cl} S \setminus S`` is closed in the simplicial complex. Recall
  that the closure ``\mathrm{cl} A`` of a set ``A \subset K`` consists of all
  simplices which are subsets of simplices in ``A``, and a set is closed if
  it equals its closure. The set ``\mathrm{mo} S`` is called the *mouth*
  of ``S``.
- The set ``S`` is *compatible* with the Forman vector field, i.e., the set
  is the union of critical cells and arrows. In other words, if one of the 
  arrow ends is contained in ``S``, then so is the other.

One can easily see that the periodic orbit ``S_P`` is an isolated invariant set,
since it is compatible and closed -- and therefore ``\mathrm{mo} S_P =
\emptyset`` is closed. Similarly, the single critical simplex ``S_1 = \{ DEF
\}`` is an isolated invariant set, since in this case the set ``\mathrm{mo} S_1
= \{ D, E, F, DE, DF, EF \}`` is closed, and ``S_1`` is compatible. On the other
hand, the invariant set ``S_2 = \{ DEF, F \}`` is not an isolated invariant set,
since the mouth ``\mathrm{mo} S_2 = \{ D, E, DE, DF, EF \}`` is not closed --
despite the fact that ``S_2`` is compatible.  For an example of an invariant set
which has a closed mouth but is not compatible, see [kaczynski:etal:16a; Figure
5](@cite).

It follows from the definition of isolation that for every isolated invariant
set ``S \subset K`` the two sets ``\mathrm{cl} S`` and ``\mathrm{mo} S`` are
closed, and that the latter is a (possibly empty) subset of the former. Thus,
the relative homology of this pair is defined and we let

```math
  CH_*(S) = H_*(\mathrm{cl} S, \mathrm{mo} S)
```

denote the *Conley index* of the isolated invariant set. The Conley index can be
computed using the command `conley_index`. For example, for the three critical
cells ``F``, ``DF``, and ``DEF`` one obtains the following Conley indices:

```@example T1
println(conley_index(sc, ["F"], p=0))
println(conley_index(sc, ["DF"], p=0))
println(conley_index(sc, ["DEF"], p=0))
```

In other words, the Conley index of a critical cell of dimension ``k`` has
Betti number ``\beta_k = 1``, while the remaining Betti numbers vanish. This
is precisely the relative homology of a ``k``-dimensional sphere, relative
to a point on the sphere. On the other hand, for the Conley index of the
periodic orbit ``S_P`` one obtains:

```@example T1
conley_index(sc, ["AB", "AC", "BC", "A", "B", "C"], p=0)
```

This Conley index is nontrivial in dimensions ``0`` and ``1``.

## Connection Matrices



```@example T1
cm = connection_matrix(sc, formanvf, p=2)
fieldnames(typeof(cm))
```


```@example T1
full_from_sparse(cm.cm)
```


```@example T1
cm.labels
```


```@example T1
cm.morsesets
```


```@example T1
cm.poincare
```







## Multivector Fields

We now turn our attention to an example from
[mrozek:wanner:p21a; Figure 1](@citet*), which happens to 
be also the logo for `ConleyDynamics.jl`.


![The logo multivector field](img/multivectorex.png)






## Tutorial References

See the [full bibliography](@ref References) for a complete list
of references cited throughout this documentation. This section cites
the following references:

```@bibliography
Pages = ["tutorial.md"]
Canonical = false
```

